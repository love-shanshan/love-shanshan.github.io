<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2021/04/25/Netty%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/25/Netty%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><pre><code class="hljs routeros">Netty is an asynchronous event-driven<span class="hljs-built_in"> network </span>application framework<span class="hljs-keyword">for</span> rapid development of maintainable high performance protocol servers &amp; clients.</code></pre><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如 </p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 1、启动器，负责装配netty组件，启动服务器</span>        <span class="hljs-keyword">new</span> ServerBootstrap()                <span class="hljs-comment">// 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector</span>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                <span class="hljs-comment">// 3、选择服务器的 ServerSocketChannel 实现</span>                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                // 4、<span class="hljs-title">child</span> 负责处理读写，该方法决定了 <span class="hljs-title">child</span> 执行哪些操作</span><span class="hljs-class">            // <span class="hljs-title">ChannelInitializer</span> 处理器（仅执行一次）</span><span class="hljs-class">            // 它的作用是待客户端<span class="hljs-title">SocketChannel</span>建立连接后，执行<span class="hljs-title">initChannel</span>以便添加更多的处理器</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">NioSocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">// 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf=&gt;String</span>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());                        <span class="hljs-comment">// 6、SocketChannel的业务处理，使用上一个处理器的处理结果</span>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                System.out.println(s);                            &#125;                        &#125;);                    &#125;                    <span class="hljs-comment">// 7、ServerSocketChannel绑定8080端口</span>                &#125;).bind(<span class="hljs-number">8080</span>);    &#125;&#125;</code></pre><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Bootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                <span class="hljs-comment">// 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现</span>                .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                // <span class="hljs-title">ChannelInitializer</span> 处理器（仅执行一次）</span><span class="hljs-class">                // 它的作用是待客户端<span class="hljs-title">SocketChannel</span>建立连接后，执行<span class="hljs-title">initChannel</span>以便添加更多的处理器</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">// 消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 编码发出</span>                        channel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());                    &#125;                &#125;)                <span class="hljs-comment">// 指定要连接的服务器和端口</span>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>))                <span class="hljs-comment">// Netty 中很多方法都是异步的，如 connect</span>                <span class="hljs-comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span>                .sync()                <span class="hljs-comment">// 获取 channel 对象，它即为通道抽象，可以进行数据读写操作</span>                .channel()                <span class="hljs-comment">// 写入消息并清空缓冲区</span>                .writeAndFlush(<span class="hljs-string">"hello world"</span>);    &#125;&#125;</code></pre><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端        右：服务器端</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png" srcset="/img/loading.gif" alt=""></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li>channel 可以理解为数据的通道</li><li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>handler 可以理解为数据的处理工序<ul><li>工序有多道，<strong>合在一起就是 pipeline（传递途径）</strong>，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li>handler 分 Inbound 和 Outbound 两类<ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li>eventLoop 可以理解为处理数据的工人<ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong>  EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEventLoop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);        <span class="hljs-comment">// 通过next方法可以获得下一个 EventLoop</span>        System.out.println(group.next());        System.out.println(group.next());        <span class="hljs-comment">// 通过EventLoop执行普通任务</span>        group.next().execute(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" hello"</span>);        &#125;);        <span class="hljs-comment">// 通过EventLoop执行定时任务</span>        group.next().scheduleAtFixedRate(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" hello2"</span>);        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);                <span class="hljs-comment">// 优雅地关闭</span>        group.shutdownGracefully();    &#125;&#125;</code></pre><p>输出结果如下</p><pre><code class="hljs angelscript">io.netty.channel.nio.<span class="hljs-symbol">NioEventLoop@</span><span class="hljs-number">7</span>bb11784io.netty.channel.nio.<span class="hljs-symbol">NioEventLoop@</span><span class="hljs-number">33</span>a10788nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-1</span> hellonioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> hello2nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> hello2nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> hello2</code></pre><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> ServerBootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                ByteBuf buf = (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + buf.toString(StandardCharsets.UTF_8));                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(<span class="hljs-number">8080</span>);    &#125;&#125;</code></pre><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        Channel channel = <span class="hljs-keyword">new</span> Bootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());                    &#125;                &#125;)                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>))                .sync()                .channel();        System.out.println(channel);        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span>        System.in.read();    &#125;&#125;</code></pre><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> ServerBootstrap()            <span class="hljs-comment">// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))            ...    &#125;&#125;</code></pre><p>多个客户端分别发送 <code>hello</code>  结果</p><pre><code class="hljs java">nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello1nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello2nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello3nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello4nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello4</code></pre><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png" srcset="/img/loading.gif" alt=""></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 增加自定义的非NioEventLoopGroup</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> DefaultEventLoopGroup();                <span class="hljs-keyword">new</span> ServerBootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span>                        socketChannel.pipeline().addLast(<span class="hljs-string">"nioHandler"</span>,<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                ByteBuf buf = (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + buf.toString(StandardCharsets.UTF_8));                                <span class="hljs-comment">// 调用下一个handler</span>                                ctx.fireChannelRead(msg);                            &#125;                        &#125;)                        <span class="hljs-comment">// 该handler绑定自定义的Group</span>                        .addLast(group, <span class="hljs-string">"myHandler"</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                ByteBuf buf = (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + buf.toString(StandardCharsets.UTF_8));                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(<span class="hljs-number">8080</span>);    &#125;&#125;</code></pre><p>启动四个客户端发送数据</p><pre><code class="hljs angelscript">nioEventLoopGroup<span class="hljs-number">-4</span><span class="hljs-number">-1</span> hello1defaultEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-1</span> hello1nioEventLoopGroup<span class="hljs-number">-4</span><span class="hljs-number">-2</span> hello2defaultEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> hello2nioEventLoopGroup<span class="hljs-number">-4</span><span class="hljs-number">-1</span> hello3defaultEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-3</span> hello3nioEventLoopGroup<span class="hljs-number">-4</span><span class="hljs-number">-2</span> hello4defaultEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-4</span> hello4</code></pre><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png" srcset="/img/loading.gif" alt=""></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">"msg"</span>), next);    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span>    EventExecutor executor = next.executor();        <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span>        next.invokeChannelRead(m);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                next.invokeChannelRead(m);            &#125;        &#125;);    &#125;&#125;</code></pre><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());                    &#125;                &#125;)                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span>            <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>));                <span class="hljs-comment">// 该方法用于等待连接真正建立</span>        channelFuture.sync();                <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span>        Channel channel = channelFuture.channel();        channel.writeAndFlush(<span class="hljs-string">"hello world"</span>);        System.in.read();    &#125;&#125;</code></pre><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());                    &#125;                &#125;)                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>));        <span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span>        channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                Channel channel = channelFuture.channel();                channel.writeAndFlush(<span class="hljs-string">"hello world"</span>);            &#125;        &#125;);        System.in.read();    &#125;&#125;</code></pre><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 创建EventLoopGroup，使用完毕后关闭</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();                ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()                .group(group)                .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());                    &#125;                &#125;)                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>));        channelFuture.sync();        Channel channel = channelFuture.channel();        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-comment">// 创建一个线程用于输入并向服务器发送</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                String msg = scanner.next();                <span class="hljs-keyword">if</span> (<span class="hljs-string">"q"</span>.equals(msg)) &#123;                    <span class="hljs-comment">// 关闭操作是异步的，在NIO线程中执行</span>                    channel.close();                    <span class="hljs-keyword">break</span>;                &#125;                channel.writeAndFlush(msg);            &#125;        &#125;, <span class="hljs-string">"inputThread"</span>).start();        <span class="hljs-comment">// 获得closeFuture对象</span>        ChannelFuture closeFuture = channel.closeFuture();        System.out.println(<span class="hljs-string">"waiting close..."</span>);                <span class="hljs-comment">// 同步等待NIO线程执行完close操作</span>        closeFuture.sync();                <span class="hljs-comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span>        System.out.println(<span class="hljs-string">"关闭之后执行一些额外操作..."</span>);                <span class="hljs-comment">// 关闭EventLoopGroup</span>        group.shutdownGracefully();    &#125;&#125;</code></pre><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><pre><code class="hljs java"><span class="hljs-comment">// 获得closeFuture对象</span>ChannelFuture closeFuture = channel.closeFuture();<span class="hljs-comment">// 同步等待NIO线程执行完close操作</span>closeFuture.sync();</code></pre></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><pre><code class="hljs java">closeFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 等待channel关闭后才执行的操作</span>        System.out.println(<span class="hljs-string">"关闭之后执行一些额外操作..."</span>);        <span class="hljs-comment">// 关闭EventLoopGroup</span>        group.shutdownGracefully();    &#125;&#125;);</code></pre></li></ul><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkFuture</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">"JdkFuture"</span>);            &#125;        &#125;;        <span class="hljs-comment">// 创建线程池</span>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>), factory);        <span class="hljs-comment">// 获得Future对象</span>        Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;            &#125;        &#125;);        <span class="hljs-comment">// 通过阻塞的方式，获得运行结果</span>        System.out.println(future.get());    &#125;&#125;</code></pre><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyFuture</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-comment">// 获得 EventLoop 对象</span>        EventLoop eventLoop = group.next();        Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;            &#125;        &#125;);        <span class="hljs-comment">// 主线程中获取结果</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 获取结果"</span>);        System.out.println(<span class="hljs-string">"getNow "</span> + future.getNow());        System.out.println(<span class="hljs-string">"get "</span> + future.get());        <span class="hljs-comment">// NIO线程中异步获取结果</span>        future.addListener(<span class="hljs-keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="hljs-keyword">super</span> Integer&gt;&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-keyword">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 获取结果"</span>);                System.out.println(<span class="hljs-string">"getNow "</span> + future.getNow());            &#125;        &#125;);    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">main 获取结果getNow <span class="hljs-literal">null</span><span class="hljs-keyword">get</span> <span class="hljs-number">50</span>nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-1</span> 获取结果getNow <span class="hljs-number">50</span></code></pre><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyPromise</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">// 创建EventLoop</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        EventLoop eventLoop = group.next();        <span class="hljs-comment">// 创建Promise对象，用于存放结果</span>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 自定义线程向Promise中存放结果</span>            promise.setSuccess(<span class="hljs-number">50</span>);        &#125;).start();        <span class="hljs-comment">// 主线程从Promise中获取结果</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + promise.get());    &#125;&#125;</code></pre><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipeLineServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> ServerBootstrap()                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">// 在socketChannel的pipeline中添加handler</span>                        <span class="hljs-comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span>     <span class="hljs-comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span>                        <span class="hljs-comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span>                        <span class="hljs-comment">// 入站时，handler是从head向后调用的</span>                        socketChannel.pipeline().addLast(<span class="hljs-string">"handler1"</span> ,<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Inbound handler 1"</span>);                                <span class="hljs-comment">// 父类该方法内部会调用fireChannelRead</span>                                <span class="hljs-comment">// 将数据传递给下一个handler</span>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);                            &#125;                        &#125;);                        socketChannel.pipeline().addLast(<span class="hljs-string">"handler2"</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Inbound handler 2"</span>);                                <span class="hljs-comment">// 执行write操作，使得Outbound的方法能够得到调用</span>          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="hljs-string">"Server..."</span>.getBytes(StandardCharsets.UTF_8)));                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);                            &#125;                        &#125;);                        <span class="hljs-comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span>                        <span class="hljs-comment">// 出站时，handler的调用是从tail向前调用的</span>                        socketChannel.pipeline().addLast(<span class="hljs-string">"handler3"</span> ,<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Outbound handler 1"</span>);                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);                            &#125;                        &#125;);                        socketChannel.pipeline().addLast(<span class="hljs-string">"handler4"</span> ,<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Outbound handler 2"</span>);                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(<span class="hljs-number">8080</span>);    &#125;&#125;</code></pre><p><strong>运行结果如下</strong></p><pre><code class="hljs angelscript">nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> Inbound handler <span class="hljs-number">1</span>nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> Inbound handler <span class="hljs-number">2</span>nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> Outbound handler <span class="hljs-number">2</span>nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span> Outbound handler <span class="hljs-number">1</span></code></pre><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png" srcset="/img/loading.gif" alt=""></p><p><strong>调用顺序如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png" srcset="/img/loading.gif" alt=""></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" srcset="/img/loading.gif" alt=""></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" srcset="/img/loading.gif" alt=""></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEmbeddedChannel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ChannelInboundHandlerAdapter h1 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">"1"</span>);                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);            &#125;        &#125;;        ChannelInboundHandlerAdapter h2 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">"2"</span>);                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);            &#125;        &#125;;        ChannelOutboundHandlerAdapter h3 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">"3"</span>);                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);            &#125;        &#125;;        ChannelOutboundHandlerAdapter h4 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">"4"</span>);                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);            &#125;        &#125;;        <span class="hljs-comment">// 用于测试Handler的Channel</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(h1, h2, h3, h4);                <span class="hljs-comment">// 执行Inbound操作 </span>        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">"hello"</span>.getBytes(StandardCharsets.UTF_8)));        <span class="hljs-comment">// 执行Outbound操作</span>        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">"hello"</span>.getBytes(StandardCharsets.UTF_8)));    &#125;&#125;</code></pre><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(ByteBuf buffer)</span> </span>&#123;    <span class="hljs-keyword">int</span> length = buffer.readableBytes();    <span class="hljs-keyword">int</span> rows = length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;    StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)        .append(<span class="hljs-string">"read index:"</span>).append(buffer.readerIndex())        .append(<span class="hljs-string">" write index:"</span>).append(buffer.writerIndex())        .append(<span class="hljs-string">" capacity:"</span>).append(buffer.capacity())        .append(NEWLINE);    appendPrettyHexDump(buf, buffer);    System.out.println(buf.toString());&#125;</code></pre><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建ByteBuf</span>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);        ByteBufUtil.log(buffer);        <span class="hljs-comment">// 向buffer中写入数据</span>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;            sb.append(<span class="hljs-string">"a"</span>);        &#125;        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));        <span class="hljs-comment">// 查看写入结果</span>        ByteBufUtil.log(buffer);    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">0</span> capacity:<span class="hljs-number">16</span>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">20</span> capacity:<span class="hljs-number">64</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> |aaaaaaaaaaaaaaaa||<span class="hljs-number">00000010</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span>                                     |aaaa            |+--------+-------------------------------------------------+----------------+</code></pre><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);</code></pre><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);</code></pre><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);</code></pre><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);        System.out.println(buffer.getClass());        buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);        System.out.println(buffer.getClass());        buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);        System.out.println(buffer.getClass());    &#125;&#125;</code></pre><pre><code class="hljs stylus"><span class="hljs-comment">// 使用池化的直接内存</span>class io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.buffer</span>.PooledUnsafeDirectByteBuf    <span class="hljs-comment">// 使用池化的堆内存    </span>class io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.buffer</span>.PooledUnsafeHeapByteBuf    <span class="hljs-comment">// 使用池化的直接内存    </span>class io<span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.buffer</span>.PooledUnsafeDirectByteBuf</code></pre><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><pre><code class="hljs java">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</code></pre><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li>最大容量与当前容量<ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li>读写操作不同于ByteBuffer只用position进行控制，<strong>ByteBuf分别由读指针和写指针两个指针控制</strong>。进行读写操作时，无需进行模式的切换<ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png" srcset="/img/loading.gif" alt=""></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建ByteBuf</span>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);        ByteBufUtil.log(buffer);        <span class="hljs-comment">// 向buffer中写入数据</span>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);        ByteBufUtil.log(buffer);        buffer.writeInt(<span class="hljs-number">5</span>);        ByteBufUtil.log(buffer);        buffer.writeIntLE(<span class="hljs-number">6</span>);        ByteBufUtil.log(buffer);        buffer.writeLong(<span class="hljs-number">7</span>);        ByteBufUtil.log(buffer);    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">0</span> capacity:<span class="hljs-number">16</span>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">4</span> capacity:<span class="hljs-number">16</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span>                                     |....            |+--------+-------------------------------------------------+----------------+read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                         |........        |+--------+-------------------------------------------------+----------------+read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">12</span> capacity:<span class="hljs-number">16</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             |............    |+--------+-------------------------------------------------+----------------+read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">20</span> capacity:<span class="hljs-number">20</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span>                                     |....            |+--------+-------------------------------------------------+----------------+</code></pre><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><pre><code class="hljs java">buffer.writeLong(<span class="hljs-number">7</span>);ByteBufUtil.log(buffer);</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 扩容前</span>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">12</span> capacity:<span class="hljs-number">16</span>...<span class="hljs-comment">// 扩容后</span>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">20</span> capacity:<span class="hljs-number">20</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span>                                     |....            |+--------+-------------------------------------------------+----------------+</code></pre><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容<ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li>如果写入后数据大小超过 512 字节，则选择下一个  2<sup>n</sup> <ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 2<sup>10</sup>=1024 字节（2<sup>9</sup>=512 已经不够了）</li></ul></li><li>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.IndexOutOfBoundsException: writer<span class="hljs-constructor">Index(20)</span> + min<span class="hljs-constructor">WritableBytes(8)</span> exceeds max<span class="hljs-constructor">Capacity(20)</span>: <span class="hljs-constructor">PooledUnsafeDirectByteBuf(<span class="hljs-params">ridx</span>: 0, <span class="hljs-params">widx</span>: 20, <span class="hljs-params">cap</span>: 20<span class="hljs-operator">/</span>20)</span>...</code></pre><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建ByteBuf</span>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);        <span class="hljs-comment">// 向buffer中写入数据</span>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);        buffer.writeInt(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 读取4个字节</span>        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        ByteBufUtil.log(buffer);        <span class="hljs-comment">// 通过mark与reset实现重复读取</span>        buffer.markReaderIndex();        System.out.println(buffer.readInt());        ByteBufUtil.log(buffer);        <span class="hljs-comment">// 恢复到mark标记处</span>        buffer.resetReaderIndex();        ByteBufUtil.log(buffer);    &#125;&#125;</code></pre><pre><code class="hljs angelscript"><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |+--------+-------------------------------------------------+----------------+<span class="hljs-number">5</span>read index:<span class="hljs-number">8</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span>         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |+--------+-------------------------------------------------+----------------+</code></pre><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!buffer.release()) &#123;&#125;</code></pre></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        logger.debug(<span class="hljs-string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration."</span>, msg);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 具体的释放方法</span>        ReferenceCountUtil.release(msg);    &#125;&#125;</code></pre><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(Object msg)</span> </span>&#123;<span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="hljs-keyword">false</span>;&#125;</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSlice</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建ByteBuf</span>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);        <span class="hljs-comment">// 向buffer中写入数据</span>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);        <span class="hljs-comment">// 将buffer分成两部分</span>        ByteBuf slice1 = buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        ByteBuf slice2 = buffer.slice(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span>        slice1.retain();        slice2.retain();                ByteBufUtil.log(slice1);        ByteBufUtil.log(slice2);        <span class="hljs-comment">// 更改原始buffer中的值</span>        System.out.println(<span class="hljs-string">"===========修改原buffer中的值==========="</span>);        buffer.setByte(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);        System.out.println(<span class="hljs-string">"===========打印slice1==========="</span>);        ByteBufUtil.log(slice1);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs asciidoc">read index:0 write index:5 capacity:5<span class="hljs-code">         +-------------------------------------------------+</span><span class="hljs-code">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>|00000000| 01 02 03 04 05                                  |.....           |<span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>read index:0 write index:5 capacity:5<span class="hljs-code">         +-------------------------------------------------+</span><span class="hljs-code">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>|00000000| 06 07 08 09 0a                                  |.....           |<span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>===========修改原buffer中的值======================打印slice1===========read index:0 write index:5 capacity:5<span class="hljs-code">         +-------------------------------------------------+</span><span class="hljs-code">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>|00000000| 05 02 03 04 05                                  |.....           |<span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span></code></pre><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyServer</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            serverBootstrap.group(boss, worker);            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">// 连接建立时会执行该方法</span>                            log.debug(<span class="hljs-string">"connected &#123;&#125;"</span>, ctx.channel());                            <span class="hljs-keyword">super</span>.channelActive(ctx);                        &#125;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">// 连接断开时会执行该方法</span>                            log.debug(<span class="hljs-string">"disconnect &#123;&#125;"</span>, ctx.channel());                            <span class="hljs-keyword">super</span>.channelInactive(ctx);                        &#125;                    &#125;);                &#125;            &#125;);            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>);            log.debug(<span class="hljs-string">"&#123;&#125; binding..."</span>, channelFuture.channel());            channelFuture.sync();            log.debug(<span class="hljs-string">"&#123;&#125; bound..."</span>, channelFuture.channel());            <span class="hljs-comment">// 关闭channel</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            log.error(<span class="hljs-string">"server error"</span>, e);        &#125; <span class="hljs-keyword">finally</span> &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();            log.debug(<span class="hljs-string">"stopped"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> StudyServer().start();    &#125;&#125;</code></pre><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyClient</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.group(worker);            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    log.debug(<span class="hljs-string">"connected..."</span>);                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            log.debug(<span class="hljs-string">"sending..."</span>);                            <span class="hljs-comment">// 每次发送16个字节的数据，共发送10次</span>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                                ByteBuf buffer = ctx.alloc().buffer();                                buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);                                ctx.writeAndFlush(buffer);                            &#125;                        &#125;                    &#125;);                &#125;            &#125;);            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            log.error(<span class="hljs-string">"client error"</span>, e);        &#125; <span class="hljs-keyword">finally</span> &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p><strong>服务器接收结果</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">7999</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x5b43ecb0</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">53797</span>] READ: <span class="hljs-number">160</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000020</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000030</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000040</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000050</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000060</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000070</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000080</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000090</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................|+--------+-------------------------------------------------+----------------+</code></pre><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 调整channel的容量</span>serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);</code></pre><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">5901</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: <span class="hljs-number">36</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................||<span class="hljs-number">00000020</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span>                                     |....            |+--------+-------------------------------------------------+----------------+<span class="hljs-number">5901</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: <span class="hljs-number">40</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................||<span class="hljs-number">00000020</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b                         |........        |+--------+-------------------------------------------------+----------------+<span class="hljs-number">5901</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: <span class="hljs-number">40</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b |................||<span class="hljs-number">00000020</span>| <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span>                         |........        |+--------+-------------------------------------------------+----------------+<span class="hljs-number">5901</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: <span class="hljs-number">40</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................||<span class="hljs-number">00000010</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................||<span class="hljs-number">00000020</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b                         |........        |+--------+-------------------------------------------------+----------------+<span class="hljs-number">5901</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: <span class="hljs-number">4</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span>                                     |....            |+--------+-------------------------------------------------+----------------+</code></pre><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    log.debug(<span class="hljs-string">"sending..."</span>);    ByteBuf buffer = ctx.alloc().buffer(<span class="hljs-number">16</span>);    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);    ctx.writeAndFlush(buffer);    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span>    ctx.channel().close();&#125;</code></pre><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 发送10次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        send();    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">6452</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x3eb6a684</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65024</span>] ACTIVE<span class="hljs-number">6468</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x3eb6a684</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65024</span>] READ: <span class="hljs-number">16</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................|+--------+-------------------------------------------------+----------------+<span class="hljs-number">6468</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x3eb6a684</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> ! R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65024</span>] INACTIVE<span class="hljs-number">6483</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x7dcc31ff</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65057</span>] ACTIVE<span class="hljs-number">6483</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x7dcc31ff</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65057</span>] READ: <span class="hljs-number">16</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>a <span class="hljs-number">0</span>b <span class="hljs-number">0</span>c <span class="hljs-number">0</span>d <span class="hljs-number">0</span>e <span class="hljs-number">0f</span> |................|+--------+-------------------------------------------------+----------------+<span class="hljs-number">6483</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x7dcc31ff</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> ! R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65057</span>] INACTIVE...</code></pre><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">16</span>));</code></pre><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为16</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">16</span>;<span class="hljs-comment">// 被发送的数据</span><span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>;<span class="hljs-comment">// 向服务器发送10个报文</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    ByteBuf buffer = ctx.alloc().buffer(maxLength);    <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[maxLength];    <span class="hljs-comment">// 生成长度为0~15的数据</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(Math.random()*(maxLength-<span class="hljs-number">1</span>)); j++) &#123;        bytes[j] = (<span class="hljs-keyword">byte</span>) c;    &#125;    buffer.writeBytes(bytes);    c++;    <span class="hljs-comment">// 将数据发送给服务器</span>    ctx.writeAndFlush(buffer);&#125;</code></pre><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><pre><code class="hljs java"><span class="hljs-comment">// 通过定长解码器对粘包数据进行拆分</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">16</span>));ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">8222</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xbc122d07</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52954</span>] READ: <span class="hljs-number">16</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |aaaa............|+--------+-------------------------------------------------+----------------+<span class="hljs-number">8222</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xbc122d07</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52954</span>] READ: <span class="hljs-number">16</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |bbb.............|+--------+-------------------------------------------------+----------------+<span class="hljs-number">8222</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xbc122d07</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52954</span>] READ: <span class="hljs-number">16</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">63</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |cc..............|+--------+-------------------------------------------------+----------------+...</code></pre><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)</strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来<strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为 64</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">64</span>;<span class="hljs-comment">// 被发送的数据</span><span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    ByteBuf buffer = ctx.alloc().buffer(maxLength);    <span class="hljs-comment">// 生成长度为0~62的数据</span>    Random random = <span class="hljs-keyword">new</span> Random();    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(random.nextInt(maxLength-<span class="hljs-number">2</span>)); j++) &#123;        sb.append(c);    &#125;    <span class="hljs-comment">// 数据以 \n 结尾</span>    sb.append(<span class="hljs-string">"\n"</span>);    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));    c++;    <span class="hljs-comment">// 将数据发送给服务器</span>    ctx.writeAndFlush(buffer);&#125;</code></pre><p>服务器代码</p><pre><code class="hljs java"><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \n 为分隔符</span><span class="hljs-comment">// 需要指定最大长度</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> DelimiterBasedFrameDecoder(<span class="hljs-number">64</span>));ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));</code></pre><p>运行结果</p><pre><code class="hljs angelscript"><span class="hljs-number">4184</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x9d6ac701</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58282</span>] READ: <span class="hljs-number">10</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span>                   |aaaaaaaaaa      |+--------+-------------------------------------------------+----------------+<span class="hljs-number">4184</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x9d6ac701</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58282</span>] READ: <span class="hljs-number">11</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span>                |bbbbbbbbbbb     |+--------+-------------------------------------------------+----------------+<span class="hljs-number">4184</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x9d6ac701</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58282</span>] READ: <span class="hljs-number">2</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">63</span>                                           |cc              |+--------+-------------------------------------------------+----------------+...</code></pre><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><pre><code class="hljs java">...    <span class="hljs-comment">// 数据以 \c 结尾</span>sb.append(<span class="hljs-string">"\\c"</span>);buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));...</code></pre><p>服务器代码</p><pre><code class="hljs java"><span class="hljs-comment">// 将分隔符放入ByteBuf中</span>ByteBuf bufSet = ch.alloc().buffer().writeBytes(<span class="hljs-string">"\\c"</span>.getBytes(StandardCharsets.UTF_8));<span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> DelimiterBasedFrameDecoder(<span class="hljs-number">64</span>, ch.alloc().buffer().writeBytes(bufSet)));ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));</code></pre><p>运行结果</p><pre><code class="hljs angelscript"><span class="hljs-number">8246</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x86215ccd</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65159</span>] READ: <span class="hljs-number">14</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span>       |aaaaaaaaaaaaaa  |+--------+-------------------------------------------------+----------------+<span class="hljs-number">8247</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x86215ccd</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65159</span>] READ: <span class="hljs-number">3</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span>                                        |bbb             |+--------+-------------------------------------------------+----------------+...</code></pre><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> maxFrameLength,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> lengthFieldOffset, <span class="hljs-keyword">int</span> lengthFieldLength,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> lengthAdjustment, <span class="hljs-keyword">int</span> initialBytesToStrip)</span></span></code></pre><p><strong>参数解析</strong></p><ul><li><p>maxFrameLength 数据最大长度</p><ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li><p>lengthFieldOffset  <strong>数据长度标识的起始偏移量</strong></p><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li><p>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）</p><ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li><p>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong></p><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li><p>initialBytesToStrip <strong>数据读取起点</strong></p><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs sql">lengthFieldOffset   = 0lengthFieldLength   = 2lengthAdjustment    = 0initialBytesToStrip = 0 (= <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> strip header)  <span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">DECODE</span> (<span class="hljs-number">14</span> <span class="hljs-keyword">bytes</span>)         <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">DECODE</span> (<span class="hljs-number">14</span> <span class="hljs-keyword">bytes</span>)+<span class="hljs-comment">--------+----------------+      +--------+----------------+</span>| <span class="hljs-keyword">Length</span> | Actual <span class="hljs-keyword">Content</span> |<span class="hljs-comment">-----&gt;| Length | Actual Content |</span>| <span class="hljs-number">0x000C</span> | <span class="hljs-string">"HELLO, WORLD"</span> |      | <span class="hljs-number">0x000C</span> | <span class="hljs-string">"HELLO, WORLD"</span> |+<span class="hljs-comment">--------+----------------+      +--------+----------------+</span></code></pre><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><pre><code class="hljs gherkin">lengthFieldOffset   = 0lengthFieldLength   = 2lengthAdjustment    = 0initialBytesToStrip = 2 (= the length of the Length field)  BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)+--------+----------------+      +----------------+|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Actual Content </span>||<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|+--------+----------------+      +----------------+</code></pre><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><pre><code class="hljs gherkin">lengthFieldOffset   = 2 (= the length of Header 1)lengthFieldLength   = 3lengthAdjustment    = 0initialBytesToStrip = 0  BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)+----------+----------+----------------+      +----------+----------+----------------+|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>||<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|+----------+----------+----------------+      +----------+----------+----------------+</code></pre><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><pre><code class="hljs gherkin">lengthFieldOffset   = 0lengthFieldLength   = 3lengthAdjustment    = 2 (= the length of Header 1)initialBytesToStrip = 0  BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)+----------+----------+----------------+      +----------+----------+----------------+|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>||<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|+----------+----------+----------------+      +----------+----------+----------------+</code></pre><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是<strong>从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code></strong>，不包括0xCAFE</p><hr><pre><code class="hljs gherkin">lengthFieldOffset   = 1 (= the length of HDR1)lengthFieldLength   = 2lengthAdjustment    = 1 (= the length of HDR2)initialBytesToStrip = 3 (= the length of HDR1 + LEN)  BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)+------+--------+------+----------------+      +------+----------------+|<span class="hljs-string"> HDR1 </span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>||<span class="hljs-string"> 0xCA </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> "HELLO, WORLD" </span>|+------+--------+------+----------------+      +------+----------------+</code></pre><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncoderStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 模拟服务器</span>        <span class="hljs-comment">// 使用EmbeddedChannel测试handler</span>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(                <span class="hljs-comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span>                <span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),                <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG)        );        <span class="hljs-comment">// 模拟客户端，写入数据</span>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();        send(buffer, <span class="hljs-string">"Hello"</span>);        channel.writeInbound(buffer);        send(buffer, <span class="hljs-string">"World"</span>);        channel.writeInbound(buffer);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ByteBuf buf, String msg)</span> </span>&#123;        <span class="hljs-comment">// 得到数据的长度</span>        <span class="hljs-keyword">int</span> length = msg.length();        <span class="hljs-keyword">byte</span>[] bytes = msg.getBytes(StandardCharsets.UTF_8);        <span class="hljs-comment">// 将数据信息写入buf</span>        <span class="hljs-comment">// 写入长度标识前的其他信息</span>        buf.writeByte(<span class="hljs-number">0xCA</span>);        <span class="hljs-comment">// 写入数据长度标识</span>        buf.writeInt(length);        <span class="hljs-comment">// 写入长度标识后的其他信息</span>        buf.writeByte(<span class="hljs-number">0xFE</span>);        <span class="hljs-comment">// 写入具体的数据</span>        buf.writeBytes(bytes);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript"><span class="hljs-number">146</span>  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xe</span>mbedded, L:embedded - R:embedded] READ: <span class="hljs-number">11</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| ca <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> fe <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span>                |......Hello     |+--------+-------------------------------------------------+----------------+<span class="hljs-number">146</span>  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xe</span>mbedded, L:embedded - R:embedded] READ: <span class="hljs-number">11</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| ca <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> fe <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span>                |......World     |+--------+-------------------------------------------------+----------------+</code></pre><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><pre><code class="hljs taggerscript">// 该指令一共有3部分，每条指令之后都要添加回车与换行符*3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>// 第一个指令的长度是3$3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>// 第一个指令是set指令set<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>// 下面的指令以此类推$4<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>name<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>$5<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>Nyima<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span></code></pre><p><strong>客户端代码如下</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisClient</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup group =  <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()                    .group(group)                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;                            <span class="hljs-comment">// 打印日志</span>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;                                <span class="hljs-meta">@Override</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                    <span class="hljs-comment">// 回车与换行符</span>                                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] LINE = &#123;<span class="hljs-string">'\r'</span>,<span class="hljs-string">'\n'</span>&#125;;                                    <span class="hljs-comment">// 获得ByteBuf</span>                                    ByteBuf buffer = ctx.alloc().buffer();                                    <span class="hljs-comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span>                                    <span class="hljs-comment">// set name Nyima</span>                                    buffer.writeBytes(<span class="hljs-string">"*3"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(<span class="hljs-string">"$3"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(<span class="hljs-string">"set"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(<span class="hljs-string">"$4"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(<span class="hljs-string">"name"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(<span class="hljs-string">"$5"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(<span class="hljs-string">"Nyima"</span>.getBytes());                                    buffer.writeBytes(LINE);                                    ctx.writeAndFlush(buffer);                                &#125;                            &#125;);                        &#125;                    &#125;)                    .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6379</span>));            channelFuture.sync();            <span class="hljs-comment">// 关闭channel</span>            channelFuture.channel().close().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 关闭group</span>            group.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p><strong>控制台打印结果</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">1600</span> [nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x28c994f1</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">60792</span> - R:localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>] WRITE: <span class="hljs-number">34</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">2</span>a <span class="hljs-number">33</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">24</span> <span class="hljs-number">33</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">73</span> <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">24</span> <span class="hljs-number">34</span> <span class="hljs-number">0</span>d |*<span class="hljs-number">3.</span>.$<span class="hljs-number">3.</span>.<span class="hljs-keyword">set</span>..$<span class="hljs-number">4.</span>||<span class="hljs-number">00000010</span>| <span class="hljs-number">0</span>a <span class="hljs-number">6</span>e <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">24</span> <span class="hljs-number">35</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">4</span>e <span class="hljs-number">79</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> |.name..$<span class="hljs-number">5.</span>.Nyima||<span class="hljs-number">00000020</span>| <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a                                           |..              |+--------+-------------------------------------------------+----------------+</code></pre><p><strong>Redis中查询执行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" srcset="/img/loading.gif" alt=""></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><pre><code class="hljs java"><span class="hljs-comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span><span class="hljs-comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpServerUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span></span></code></pre><p><strong>服务器代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">new</span> ServerBootstrap()                .group(group)                .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));                        <span class="hljs-comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec());                        <span class="hljs-comment">// 服务器只处理HTTPRequest</span>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpRequest msg)</span> </span>&#123;                                <span class="hljs-comment">// 获得请求uri</span>                                log.debug(msg.uri());                                <span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span>                                DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);                                <span class="hljs-comment">// 设置响应内容</span>                                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">"&lt;h1&gt;Hello, World!&lt;/h1&gt;"</span>.getBytes(StandardCharsets.UTF_8);                                <span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span>                                response.headers().setInt(CONTENT_LENGTH, bytes.length);                                <span class="hljs-comment">// 设置响应体</span>                                response.content().writeBytes(bytes);                                <span class="hljs-comment">// 写回响应</span>                                ctx.writeAndFlush(response);                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(<span class="hljs-number">8080</span>);    &#125;&#125;</code></pre><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><pre><code class="hljs java"><span class="hljs-comment">// 服务器只处理HTTPRequest</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;()</code></pre><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><pre><code class="hljs java"><span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span>DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);<span class="hljs-comment">// 设置响应内容</span><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">"&lt;h1&gt;Hello, World!&lt;/h1&gt;"</span>.getBytes(StandardCharsets.UTF_8);<span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span>response.headers().setInt(CONTENT_LENGTH, bytes.length);<span class="hljs-comment">// 设置响应体</span>response.content().writeBytes(bytes);</code></pre><p><strong>运行结果</strong></p><p>浏览器</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png" srcset="/img/loading.gif" alt=""></p><p>控制台</p><pre><code class="hljs angelscript"><span class="hljs-comment">// 请求内容</span><span class="hljs-number">1714</span> [nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x72630ef7</span>, L:/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">55503</span>] READ: <span class="hljs-number">688</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">47</span> <span class="hljs-number">45</span> <span class="hljs-number">54</span> <span class="hljs-number">20</span> <span class="hljs-number">2f</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">69</span> <span class="hljs-number">63</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>e <span class="hljs-number">69</span> <span class="hljs-number">63</span> <span class="hljs-number">6f</span> |GET /favicon.ico||<span class="hljs-number">00000010</span>| <span class="hljs-number">20</span> <span class="hljs-number">48</span> <span class="hljs-number">54</span> <span class="hljs-number">54</span> <span class="hljs-number">50</span> <span class="hljs-number">2f</span> <span class="hljs-number">31</span> <span class="hljs-number">2</span>e <span class="hljs-number">31</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">48</span> <span class="hljs-number">6f</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>a | HTTP/<span class="hljs-number">1.1</span>..Host:||<span class="hljs-number">00000020</span>| <span class="hljs-number">20</span> <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">68</span> <span class="hljs-number">6f</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>a <span class="hljs-number">38</span> <span class="hljs-number">30</span> <span class="hljs-number">38</span> <span class="hljs-number">30</span> <span class="hljs-number">0</span>d | localhost:<span class="hljs-number">8080.</span>||<span class="hljs-number">00000030</span>| <span class="hljs-number">0</span>a <span class="hljs-number">43</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e <span class="hljs-number">6</span>e <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e <span class="hljs-number">3</span>a <span class="hljs-number">20</span> <span class="hljs-number">6</span>b <span class="hljs-number">65</span> <span class="hljs-number">65</span> |.Connection: kee||<span class="hljs-number">00000040</span>| <span class="hljs-number">70</span> <span class="hljs-number">2</span>d <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">69</span> <span class="hljs-number">76</span> <span class="hljs-number">65</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">3</span>a |p-alive..Pragma:|....<span class="hljs-comment">// 响应内容</span><span class="hljs-number">1716</span> [nioEventLoopGroup<span class="hljs-number">-2</span><span class="hljs-number">-2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x72630ef7</span>, L:/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">55503</span>] WRITE: <span class="hljs-number">61</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">48</span> <span class="hljs-number">54</span> <span class="hljs-number">54</span> <span class="hljs-number">50</span> <span class="hljs-number">2f</span> <span class="hljs-number">31</span> <span class="hljs-number">2</span>e <span class="hljs-number">31</span> <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">30</span> <span class="hljs-number">30</span> <span class="hljs-number">20</span> <span class="hljs-number">4f</span> <span class="hljs-number">4</span>b <span class="hljs-number">0</span>d |HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK.||<span class="hljs-number">00000010</span>| <span class="hljs-number">0</span>a <span class="hljs-number">43</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">2</span>d <span class="hljs-number">4</span>c <span class="hljs-number">65</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">3</span>a |.Content-Length:||<span class="hljs-number">00000020</span>| <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">3</span>c <span class="hljs-number">68</span> <span class="hljs-number">31</span> <span class="hljs-number">3</span>e <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> | <span class="hljs-number">22.</span>...&lt;h1&gt;Hello||<span class="hljs-number">00000030</span>| <span class="hljs-number">2</span>c <span class="hljs-number">20</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">21</span> <span class="hljs-number">3</span>c <span class="hljs-number">2f</span> <span class="hljs-number">68</span> <span class="hljs-number">31</span> <span class="hljs-number">3</span>e          |, World!&lt;/h1&gt;   |+--------+-------------------------------------------------+----------------+</code></pre><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</li><li><strong>版本号</strong>：可以支持协议的升级</li><li><strong>序列化算法</strong>：消息正文到底采用哪种序列化反序列化方式<ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</li><li><strong>请求序号</strong>：为了双工通信，提供异步能力</li><li><strong>正文长度</strong></li><li><strong>消息正文</strong></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 设置魔数 4个字节</span>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">'N'</span>,<span class="hljs-string">'Y'</span>,<span class="hljs-string">'I'</span>,<span class="hljs-string">'M'</span>&#125;);        <span class="hljs-comment">// 设置版本号 1个字节</span>        out.writeByte(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 设置序列化方式 1个字节</span>        out.writeByte(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 设置指令类型 1个字节</span>        out.writeByte(msg.getMessageType());        <span class="hljs-comment">// 设置请求序号 4个字节</span>        out.writeInt(msg.getSequenceId());        <span class="hljs-comment">// 为了补齐为16个字节，填充1个字节的数据</span>        out.writeByte(<span class="hljs-number">0xff</span>);        <span class="hljs-comment">// 获得序列化后的msg</span>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);        oos.writeObject(msg);        <span class="hljs-keyword">byte</span>[] bytes = bos.toByteArray();        <span class="hljs-comment">// 获得并设置正文长度 长度用4个字节标识</span>        out.writeInt(bytes.length);        <span class="hljs-comment">// 设置消息正文</span>        out.writeBytes(bytes);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 获取魔数</span>        <span class="hljs-keyword">int</span> magic = in.readInt();        <span class="hljs-comment">// 获取版本号</span>        <span class="hljs-keyword">byte</span> version = in.readByte();        <span class="hljs-comment">// 获得序列化方式</span>        <span class="hljs-keyword">byte</span> seqType = in.readByte();        <span class="hljs-comment">// 获得指令类型</span>        <span class="hljs-keyword">byte</span> messageType = in.readByte();        <span class="hljs-comment">// 获得请求序号</span>        <span class="hljs-keyword">int</span> sequenceId = in.readInt();        <span class="hljs-comment">// 移除补齐字节</span>        in.readByte();        <span class="hljs-comment">// 获得正文长度</span>        <span class="hljs-keyword">int</span> length = in.readInt();        <span class="hljs-comment">// 获得正文</span>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];        in.readBytes(bytes, <span class="hljs-number">0</span>, length);        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));        Message message = (Message) ois.readObject();<span class="hljs-comment">// 将信息放入List中，传递给下一个handler</span>        out.add(message);                <span class="hljs-comment">// 打印获得的信息正文</span>        System.out.println(<span class="hljs-string">"===========魔数==========="</span>);        System.out.println(magic);        System.out.println(<span class="hljs-string">"===========版本号==========="</span>);        System.out.println(version);        System.out.println(<span class="hljs-string">"===========序列化方法==========="</span>);        System.out.println(seqType);        System.out.println(<span class="hljs-string">"===========指令类型==========="</span>);        System.out.println(messageType);        System.out.println(<span class="hljs-string">"===========请求序号==========="</span>);        System.out.println(sequenceId);        System.out.println(<span class="hljs-string">"===========正文长度==========="</span>);        System.out.println(length);        System.out.println(<span class="hljs-string">"===========正文==========="</span>);        System.out.println(message);    &#125;&#125;</code></pre><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt;</span></code></pre></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2<sup>n</sup>，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCodec</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.slf4j.Logger log = LoggerFactory.getLogger(StudyServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel();        <span class="hljs-comment">// 添加解码器，避免粘包半包问题</span>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        channel.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));        channel.pipeline().addLast(<span class="hljs-keyword">new</span> MessageCodec());        LoginRequestMessage user = <span class="hljs-keyword">new</span> LoginRequestMessage(<span class="hljs-string">"Nyima"</span>, <span class="hljs-string">"123"</span>);        <span class="hljs-comment">// 测试编码与解码</span>        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();        <span class="hljs-keyword">new</span> MessageCodec().encode(<span class="hljs-keyword">null</span>, user, byteBuf);        channel.writeInbound(byteBuf);    &#125;&#125;</code></pre><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png" srcset="/img/loading.gif" alt=""></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><pre><code class="hljs java">LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span>channel1.pipeline().addLast(loggingHandler);channel2.pipeline().addLast(loggingHandler);</code></pre><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png" srcset="/img/loading.gif" alt=""></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">ByteBuf</span>, <span class="hljs-title">Message</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ...    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;...    &#125;&#125;</code></pre><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span></span>;&#125;</code></pre><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Session</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定会话</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Channel channel, String username)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 解绑会话</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">(Channel channel)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取属性</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(Channel channel, String name)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置属性</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(Channel channel, String name, Object value)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据用户名获取 channel</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Channel <span class="hljs-title">getChannel</span><span class="hljs-params">(String username)</span></span>;&#125;</code></pre><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GroupSession</span> </span>&#123;    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 组名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param members 成员</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 成功时返回组对象, 失败返回 null</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    Group createGroup(<span class="hljs-built_in">String</span> name, <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; members);    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>加入聊天组</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 组名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param member 成员名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 如果组不存在返回 null, 否则返回组对象</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    Group joinMember(<span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> member);    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>移除组成员</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 组名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param member 成员名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 如果组不存在返回 null, 否则返回组对象</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    Group removeMember(<span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> member);    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>移除聊天组</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 组名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 如果组不存在返回 null, 否则返回组对象</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    Group removeGroup(<span class="hljs-built_in">String</span> name);    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>获取组成员</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 组名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 成员集合, 如果群不存在或没有成员会返回 empty set</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; getMembers(<span class="hljs-built_in">String</span> name);    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 组名</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 成员 channel 集合</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    <span class="hljs-built_in">List</span>&lt;Channel&gt; getMembersChannel(<span class="hljs-built_in">String</span> name);        <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>判断群聊是否一被创建</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@param name 群聊名称</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">     * </span>@return 是否存在</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">     */</span></span></span>    boolean isCreated(<span class="hljs-built_in">String</span> name);&#125;</code></pre><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>client包：存放客户端相关类</p></li><li><p>message包：存放各种类型的消息</p></li><li><p>protocol包：存放自定义协议</p></li><li><p>server包：存放服务器相关类</p><ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClient</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();        <span class="hljs-keyword">try</span> &#123;            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.group(group);            bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                &#125;            &#125;);            Channel channel = bootstrap.connect().sync().channel();            channel.closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;           group.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            bootstrap.group(boss, worker);            bootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                &#125;            &#125;);            Channel channel = bootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();            channel.closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建连接时执行的处理器，用于执行登陆操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 开辟额外线程，用于用户登陆及后续操作</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);            System.out.println(<span class="hljs-string">"请输入用户名"</span>);            String username = scanner.next();            System.out.println(<span class="hljs-string">"请输入密码"</span>);            String password = scanner.next();            <span class="hljs-comment">// 创建包含登录信息的请求体</span>            LoginRequestMessage message = <span class="hljs-keyword">new</span> LoginRequestMessage(username, password);            <span class="hljs-comment">// 发送到channel中</span>            ctx.writeAndFlush(message);            System.out.println(<span class="hljs-string">"等待后续操作..."</span>);            <span class="hljs-comment">// 阻塞，直到登陆成功后CountDownLatch被设置为0</span>            <span class="hljs-keyword">try</span> &#123;                waitLogin.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 执行后续操作</span>            <span class="hljs-keyword">if</span> (!loginStatus.get()) &#123;                <span class="hljs-comment">// 登陆失败，关闭channel并返回</span>                ctx.channel().close();                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// 登录成功后，执行其他操作</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                System.out.println(<span class="hljs-string">"=================================="</span>);                System.out.println(<span class="hljs-string">"send [username] [content]"</span>);                System.out.println(<span class="hljs-string">"gsend [group name] [content]"</span>);                System.out.println(<span class="hljs-string">"gcreate [group name] [m1,m2,m3...]"</span>);                System.out.println(<span class="hljs-string">"gmembers [group name]"</span>);                System.out.println(<span class="hljs-string">"gjoin [group name]"</span>);                System.out.println(<span class="hljs-string">"gquit [group name]"</span>);                System.out.println(<span class="hljs-string">"quit"</span>);                System.out.println(<span class="hljs-string">"=================================="</span>);                String command = scanner.nextLine();                <span class="hljs-comment">// 获得指令及其参数，并发送对应类型消息</span>                String[] commands = command.split(<span class="hljs-string">" "</span>);                <span class="hljs-keyword">switch</span> (commands[<span class="hljs-number">0</span>])&#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"send"</span>:                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatRequestMessage(username, commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"gsend"</span>:                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatRequestMessage(username,commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"gcreate"</span>:                        <span class="hljs-comment">// 分割，获得群员名</span>                        String[] members = commands[<span class="hljs-number">2</span>].split(<span class="hljs-string">","</span>);                        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(members));                        <span class="hljs-comment">// 把自己加入到群聊中</span>                        set.add(username);                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateRequestMessage(commands[<span class="hljs-number">1</span>],set));                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"gmembers"</span>:                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersRequestMessage(commands[<span class="hljs-number">1</span>]));                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"gjoin"</span>:                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinRequestMessage(username, commands[<span class="hljs-number">1</span>]));                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"gquit"</span>:                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitRequestMessage(username, commands[<span class="hljs-number">1</span>]));                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">"quit"</span>:                        ctx.channel().close();                        <span class="hljs-keyword">return</span>;                    <span class="hljs-keyword">default</span>:                        System.out.println(<span class="hljs-string">"指令有误，请重新输入"</span>);                        <span class="hljs-keyword">continue</span>;                &#125;            &#125;        &#125;, <span class="hljs-string">"login channel"</span>).start();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        log.debug(<span class="hljs-string">"&#123;&#125;"</span>, msg);        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> LoginResponseMessage) &#123;            <span class="hljs-comment">// 如果是登录响应信息</span>            LoginResponseMessage message = (LoginResponseMessage) msg;            <span class="hljs-keyword">boolean</span> isSuccess = message.isSuccess();            <span class="hljs-comment">// 登录成功，设置登陆标记</span>            <span class="hljs-keyword">if</span> (isSuccess) &#123;                loginStatus.set(<span class="hljs-keyword">true</span>);            &#125;            <span class="hljs-comment">// 登陆后，唤醒登陆线程</span>            waitLogin.countDown();        &#125;    &#125;&#125;);</code></pre><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LoginRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 获得登录信息</span>        String username = msg.getUsername();        String password = msg.getPassword();        <span class="hljs-comment">// 校验登录信息</span>        <span class="hljs-keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);        LoginResponseMessage message;        <span class="hljs-keyword">if</span> (login) &#123;            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">"登陆成功"</span>);            <span class="hljs-comment">// 绑定channel与user</span>            SessionFactory.getSession().bind(ctx.channel(), username);        &#125; <span class="hljs-keyword">else</span> &#123;            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">"登陆失败"</span>);        &#125;        ctx.writeAndFlush(message);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理登录请求</span>LoginRequestMessageHandler loginRequestMessageHandler = <span class="hljs-keyword">new</span> LoginRequestMessageHandler();ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoginRequestMessageHandler());</code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><pre><code class="hljs java"><span class="hljs-number">5665</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - <span class="hljs-number">1314474317</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">279</span><span class="hljs-number">5667</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success=<span class="hljs-keyword">true</span>, reason=<span class="hljs-string">'登陆成功'</span>&#125;<span class="hljs-number">5667</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="hljs-keyword">true</span>, reason=<span class="hljs-string">'登陆成功'</span>&#125;success</code></pre><p><strong>服务器</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">11919</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - <span class="hljs-number">1314474317</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">217</span><span class="hljs-number">11919</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username=<span class="hljs-string">'Nyima'</span>, password=<span class="hljs-string">'123'</span>&#125;<span class="hljs-number">7946</span> [nioEventLoopGroup<span class="hljs-number">-3</span><span class="hljs-number">-1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x8e7c07f6</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">60572</span>] WRITE: <span class="hljs-number">295</span>B         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">4</span>e <span class="hljs-number">59</span> <span class="hljs-number">49</span> <span class="hljs-number">4</span>d <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ff <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">17</span> |NYIM............||<span class="hljs-number">00000010</span>| ac ed <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">73</span> <span class="hljs-number">72</span> <span class="hljs-number">00</span> <span class="hljs-number">31</span> <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>e <span class="hljs-number">6</span>e <span class="hljs-number">79</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> |....sr<span class="hljs-number">.1</span>cn.nyima||<span class="hljs-number">00000020</span>| <span class="hljs-number">63</span> <span class="hljs-number">2</span>e <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">75</span> <span class="hljs-number">64</span> <span class="hljs-number">79</span> <span class="hljs-number">2</span>e <span class="hljs-number">64</span> <span class="hljs-number">61</span> <span class="hljs-number">79</span> <span class="hljs-number">38</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> |c.study.day8.mes||<span class="hljs-number">00000030</span>| <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> <span class="hljs-number">2</span>e <span class="hljs-number">4</span>c <span class="hljs-number">6f</span> <span class="hljs-number">67</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">52</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">70</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e |sage.LoginRespon||<span class="hljs-number">00000040</span>| <span class="hljs-number">73</span> <span class="hljs-number">65</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> e2 <span class="hljs-number">34</span> <span class="hljs-number">49</span> <span class="hljs-number">24</span> <span class="hljs-number">72</span> <span class="hljs-number">52</span> f3 |seMessage<span class="hljs-number">.4</span>I$rR.||<span class="hljs-number">00000050</span>| <span class="hljs-number">07</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">78</span> <span class="hljs-number">72</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>e <span class="hljs-number">6</span>e <span class="hljs-number">79</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> |....xr<span class="hljs-number">.4</span>cn.nyima||<span class="hljs-number">00000060</span>| <span class="hljs-number">63</span> <span class="hljs-number">2</span>e <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">75</span> <span class="hljs-number">64</span> <span class="hljs-number">79</span> <span class="hljs-number">2</span>e <span class="hljs-number">64</span> <span class="hljs-number">61</span> <span class="hljs-number">79</span> <span class="hljs-number">38</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> |c.study.day8.mes||<span class="hljs-number">00000070</span>| <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> <span class="hljs-number">2</span>e <span class="hljs-number">41</span> <span class="hljs-number">62</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">52</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> |sage.AbstractRes||<span class="hljs-number">00000080</span>| <span class="hljs-number">70</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e <span class="hljs-number">73</span> <span class="hljs-number">65</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> b3 <span class="hljs-number">7</span>e <span class="hljs-number">19</span> <span class="hljs-number">32</span> |ponseMessage.~<span class="hljs-number">.2</span>||<span class="hljs-number">00000090</span>| <span class="hljs-number">9</span>b <span class="hljs-number">88</span> <span class="hljs-number">4</span>d <span class="hljs-number">7</span>b <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">5</span>a <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">73</span> <span class="hljs-number">75</span> <span class="hljs-number">63</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> |..M&#123;...Z..succes||<span class="hljs-number">000000</span>a0| <span class="hljs-number">73</span> <span class="hljs-number">4</span>c <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">6f</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> |sL..reasont..Lja||<span class="hljs-number">000000</span>b0| <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">78</span> |va/lang/String;x||<span class="hljs-number">000000</span>c0| <span class="hljs-number">72</span> <span class="hljs-number">00</span> <span class="hljs-number">24</span> <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>e <span class="hljs-number">6</span>e <span class="hljs-number">79</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">63</span> <span class="hljs-number">2</span>e <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">75</span> |r.$cn.nyimac.stu||<span class="hljs-number">000000</span>d0| <span class="hljs-number">64</span> <span class="hljs-number">79</span> <span class="hljs-number">2</span>e <span class="hljs-number">64</span> <span class="hljs-number">61</span> <span class="hljs-number">79</span> <span class="hljs-number">38</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> <span class="hljs-number">2</span>e |dy.day8.message.||<span class="hljs-number">000000e0</span>| <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> dd e9 <span class="hljs-number">84</span> b7 <span class="hljs-number">21</span> db <span class="hljs-number">18</span> <span class="hljs-number">52</span> <span class="hljs-number">02</span> |Message....!..R.||<span class="hljs-number">000000f</span>0| <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">49</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">73</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">79</span> <span class="hljs-number">70</span> <span class="hljs-number">65</span> |..I..messageType||<span class="hljs-number">00000100</span>| <span class="hljs-number">49</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">73</span> <span class="hljs-number">65</span> <span class="hljs-number">71</span> <span class="hljs-number">75</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>e <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">49</span> <span class="hljs-number">64</span> <span class="hljs-number">78</span> <span class="hljs-number">70</span> <span class="hljs-number">00</span> |I..sequenceIdxp.||<span class="hljs-number">00000110</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">74</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c e7 <span class="hljs-number">99</span> bb e9 <span class="hljs-number">99</span> |........t.......||<span class="hljs-number">00000120</span>| <span class="hljs-number">86</span> e6 <span class="hljs-number">88</span> <span class="hljs-number">90</span> e5 <span class="hljs-number">8</span>a <span class="hljs-number">9f</span>                            |.......         |+--------+-------------------------------------------------+----------------+</code></pre><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ChatRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 获得user所在的channel</span>        Channel channel = SessionFactory.getSession().getChannel(msg.getTo());        <span class="hljs-comment">// 如果双方都在线</span>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 通过接收方与服务器之间的channel发送信息</span>            channel.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 通过发送方与服务器之间的channel发送消息</span>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">"对方用户不存在或离线，发送失败"</span>));        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理单聊请求</span>ChatRequestMessageHandler chatRequestMessageHandler = <span class="hljs-keyword">new</span> ChatRequestMessageHandler();ch.pipeline().addLast(chatRequestMessageHandler);</code></pre><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><pre><code class="hljs autoit"><span class="hljs-built_in">send</span> Nyima hello</code></pre><p>接收方（Nyima）</p><pre><code class="hljs java"><span class="hljs-comment">// 收到zhangsan发来的消息</span><span class="hljs-number">20230</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from=<span class="hljs-string">'zhangsan'</span>, content=<span class="hljs-string">'hello'</span>&#125;</code></pre><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupCreateMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupCreateRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 获得要创建的群聊名</span>        String groupName = msg.getGroupName();        <span class="hljs-comment">// 获得要创建的群聊的成员组</span>        Set&lt;String&gt; members = msg.getMembers();        <span class="hljs-comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span>        Group group = GroupSessionFactory.getGroupSession().createGroup(groupName, members);        <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 发送创建成功消息</span>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, groupName + <span class="hljs-string">"创建成功"</span>);            ctx.writeAndFlush(groupCreateResponseMessage);            <span class="hljs-comment">// 获得在线群员的channel，给群员发送入群聊消息</span>            List&lt;Channel&gt; membersChannel = GroupSessionFactory.getGroupSession().getMembersChannel(groupName);            groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">"您已被拉入"</span>+groupName);            <span class="hljs-comment">// 给每个在线群员发送消息</span>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;                channel.writeAndFlush(groupCreateResponseMessage);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 发送失败消息</span>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">false</span>, groupName + <span class="hljs-string">"已存在"</span>);            ctx.writeAndFlush(groupCreateResponseMessage);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理创建群聊请求</span>GroupCreateMessageHandler groupCreateMessageHandler = <span class="hljs-keyword">new</span> GroupCreateMessageHandler();ch.pipeline().addLast(groupCreateMessageHandler);</code></pre><p><strong>运行结果</strong></p><p>创建者客户端</p><pre><code class="hljs java"><span class="hljs-comment">// 首次创建</span>gcreate Netty学习 zhangsan,lisi<span class="hljs-number">31649</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="hljs-keyword">true</span>, reason=<span class="hljs-string">'Netty学习创建成功'</span>&#125;<span class="hljs-number">15244</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="hljs-keyword">true</span>, reason=<span class="hljs-string">'您已被拉入Netty学习'</span>&#125;<span class="hljs-comment">// 再次创建</span>gcreate Netty学习 zhangsan,lisi<span class="hljs-number">40771</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="hljs-keyword">false</span>, reason=<span class="hljs-string">'Netty学习已存在'</span>&#125;</code></pre><p>群员客户端</p><pre><code class="hljs java"><span class="hljs-number">28788</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="hljs-keyword">true</span>, reason=<span class="hljs-string">'您已被拉入Netty学习'</span>&#125;</code></pre><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupChatRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String groupName = msg.getGroupName();        GroupSession groupSession = GroupSessionFactory.getGroupSession();        <span class="hljs-comment">// 判断群聊是否存在</span>        <span class="hljs-keyword">boolean</span> isCreated = groupSession.isCreated(groupName);        <span class="hljs-keyword">if</span> (isCreated) &#123;            <span class="hljs-comment">// 给群员发送信息</span>            List&lt;Channel&gt; membersChannel = groupSession.getMembersChannel(groupName);            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;                channel.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">"群聊不存在"</span>));        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理群聊聊天</span>GroupChatMessageHandler groupChatMessageHandler = <span class="hljs-keyword">new</span> GroupChatMessageHandler();ch.pipeline().addLast(groupChatMessageHandler);</code></pre><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><pre><code class="hljs stylus">gsend Netty学习 你们好<span class="hljs-number">45408</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - GroupChatResponseMessage&#123;from=<span class="hljs-string">'zhangsan'</span>, <span class="hljs-attribute">content</span>=<span class="hljs-string">'你们好'</span>&#125;</code></pre><p>接收方</p><pre><code class="hljs basic"><span class="hljs-symbol">48082 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=<span class="hljs-comment">'zhangsan', content='你们好'&#125;</span></code></pre><p>发送方（群聊不存在）</p><pre><code class="hljs routeros">gsend Spring学习 你们好25140 [nioEventLoopGroup-2-1] <span class="hljs-builtin-name">DEBUG</span> cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;<span class="hljs-attribute">success</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">reason</span>=<span class="hljs-string">'群聊不存在'</span>&#125;</code></pre><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupJoinMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupJoinRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        GroupSession groupSession = GroupSessionFactory.getGroupSession();        <span class="hljs-comment">// 判断该用户是否在群聊中</span>        Set&lt;String&gt; members = groupSession.getMembers(msg.getGroupName());        <span class="hljs-keyword">boolean</span> joinFlag = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span>        <span class="hljs-keyword">if</span> (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;            joinFlag = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (joinFlag) &#123;            <span class="hljs-comment">// 加入群聊</span>            groupSession.joinMember(msg.getGroupName(), msg.getUsername());            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>,<span class="hljs-string">"加入"</span>+msg.getGroupName()+<span class="hljs-string">"成功"</span>));        &#125; <span class="hljs-keyword">else</span> &#123;            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">"加入失败，群聊未存在或您已加入该群聊"</span>));        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理加入群聊</span>GroupJoinMessageHandler groupJoinMessageHandler = <span class="hljs-keyword">new</span> GroupJoinMessageHandler();ch.pipeline().addLast(groupJoinMessageHandler);</code></pre><p><strong>运行结果</strong></p><p>正常加入群聊</p><pre><code class="hljs basic"><span class="hljs-symbol">94921 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">'加入Netty学习成功'&#125;</span></code></pre><p>加入不能存在或已加入的群聊</p><pre><code class="hljs basic"><span class="hljs-symbol">44025 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-comment">'加入失败，群聊未存在或您已加入该群聊'&#125;</span></code></pre><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupQuitMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupQuitRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        GroupSession groupSession = GroupSessionFactory.getGroupSession();        String groupName = msg.getGroupName();        Set&lt;String&gt; members = groupSession.getMembers(groupName);        String username = msg.getUsername();        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在</span>        <span class="hljs-keyword">boolean</span> joinFlag = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;            <span class="hljs-comment">// 可以退出</span>            joinFlag = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (joinFlag) &#123;            <span class="hljs-comment">// 退出成功</span>            groupSession.removeMember(groupName, username);            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">"退出"</span>+groupName+<span class="hljs-string">"成功"</span>));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 退出失败</span>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">"群聊不存在或您未加入该群，退出"</span>+groupName+<span class="hljs-string">"失败"</span>));        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理退出群聊</span>GroupQuitMessageHandler groupQuitMessageHandler = <span class="hljs-keyword">new</span> GroupQuitMessageHandler();ch.pipeline().addLast(groupQuitMessageHandler);</code></pre><p><strong>运行结果</strong></p><p>正常退出</p><pre><code class="hljs basic"><span class="hljs-symbol">32282 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">'退出Netty学习成功'&#125;</span></code></pre><p>退出不存在或未加入的群聊</p><pre><code class="hljs basic"><span class="hljs-symbol">67404 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-comment">'群聊不存在或您未加入该群，退出Netty失败'&#125;</span></code></pre><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupMembersMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupMembersRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));    &#125;&#125;</code></pre><pre><code class="hljs JAVA"><span class="hljs-comment">// 该handler处理查看成员</span>GroupMembersMessageHandler groupMembersMessageHandler = <span class="hljs-keyword">new</span> GroupMembersMessageHandler();ch.pipeline().addLast(groupMembersMessageHandler);</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs basic"><span class="hljs-symbol">46557 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members=[zhangsan, Nyima]&#125;</code></pre><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 解绑</span>        SessionFactory.getSession().unbind(ctx.channel());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 异常退出，需要解绑</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 解绑</span>        SessionFactory.getSession().unbind(ctx.channel());    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理退出聊天室</span>ch.pipeline().addLast(quitHandler);GroupMembersMessageHandler groupMembersMessageHandler = <span class="hljs-keyword">new</span> GroupMembersMessageHandler();</code></pre><p><strong>退出时，客户端会关闭channel并返回</strong></p><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">"quit"</span>:<span class="hljs-comment">// 关闭channel并返回</span>    ctx.channel().close();    <span class="hljs-keyword">return</span>;</code></pre><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" srcset="/img/loading.gif" alt=""></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// 添加双向处理器，负责处理READER_IDLE事件</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 获得事件</span>        IdleStateEvent event = (IdleStateEvent) evt;        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;            <span class="hljs-comment">// 断开连接</span>            ctx.channel().close();        &#125;    &#125;&#125;);</code></pre><ul><li>使用<code>IdleStateHandler</code>进行空闲检测</li><li>使用双向处理器<code>ChannelDuplexHandler</code>对入站与出站事件进行处理<ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 发送心跳包，让服务器知道客户端在线</span><span class="hljs-comment">// 3s未发生WRITER_IDLE，就像服务器发送心跳包</span><span class="hljs-comment">// 该值为服务器端设置的READER_IDLE触发时间的一半左右</span>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>));ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        IdleStateEvent event = (IdleStateEvent) evt;        <span class="hljs-keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;            <span class="hljs-comment">// 发送心跳包</span>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> PingMessage());        &#125;    &#125;&#125;);</code></pre><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 序列化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object 被序列化的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 被序列化对象类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 序列化后的字节数组</span><span class="hljs-comment">     */</span>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 反序列化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 反序列化的目标类的Class对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 被反序列化的字节数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 反序列化目标类</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><span class="hljs-comment">     */</span>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;&#125;</code></pre><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SerializerAlgorithm implements Serializer &#123;    <span class="hljs-comment">// Java的序列化和反序列化</span>    Java &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;            <span class="hljs-comment">// 序列化后的字节数组</span>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> (ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();                 ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos)) &#123;                oos.writeObject(object);                bytes = bos.toByteArray();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">return</span> bytes;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;            T target = <span class="hljs-keyword">null</span>;            System.out.println(Arrays.toString(bytes));            <span class="hljs-keyword">try</span> (ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);                 ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis)) &#123;                target = (T) ois.readObject();            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 返回反序列化后的对象</span>            <span class="hljs-keyword">return</span> target;        &#125;    &#125;         <span class="hljs-comment">// Json的序列化和反序列化</span>    Json &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;            String s = <span class="hljs-keyword">new</span> Gson().toJson(object);            System.out.println(s);            <span class="hljs-comment">// 指定字符集，获得字节数组</span>            <span class="hljs-keyword">return</span> s.getBytes(StandardCharsets.UTF_8);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;            String s = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);            System.out.println(s);            <span class="hljs-comment">// 此处的clazz为具体类型的Class对象，而不是父类Message的</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Gson().fromJson(s, clazz);        &#125;    &#125;&#125;</code></pre><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 获得序列化后的msg</span><span class="hljs-comment">// 使用指定的序列化方式</span>SerializerAlgorithm[] values = SerializerAlgorithm.values();<span class="hljs-comment">// 获得序列化后的对象</span><span class="hljs-keyword">byte</span>[] bytes = values[out.getByte(<span class="hljs-number">5</span>)-<span class="hljs-number">1</span>].serialize(msg);</code></pre><p><strong>解码</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 获得反序列化方式</span>SerializerAlgorithm[] values = SerializerAlgorithm.values();<span class="hljs-comment">// 通过指定方式进行反序列化</span><span class="hljs-comment">// 需要通过Message的方法获得具体的消息类型</span>Message message = values[seqType-<span class="hljs-number">1</span>].deserialize(Message.getMessageClass(messageType), bytes);</code></pre><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParam</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span>        <span class="hljs-keyword">new</span> Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);                <span class="hljs-comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span>        <span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="hljs-number">5000</span>);        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span>        <span class="hljs-keyword">new</span> ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);    &#125;&#125;</code></pre><ul><li>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong> </li><li>服务器通过 <code>ServerBootstrap</code>来配置参数，但是对于不同的 Channel 需要选择不同的方法<ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;        ...            <span class="hljs-comment">// Schedule connect timeout.</span>    <span class="hljs-comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span>    <span class="hljs-keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();    <span class="hljs-comment">// 如果超时时间大于0</span>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span>        <span class="hljs-comment">// schedule(Runnable command, long delay, TimeUnit unit)</span>        connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span>                <span class="hljs-comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span>                <span class="hljs-comment">// 在主线程中抛出</span>                ChannelPromise connectPromise = AbstractNioChannel.<span class="hljs-keyword">this</span>.connectPromise;                ConnectTimeoutException cause = <span class="hljs-keyword">new</span> ConnectTimeoutException(<span class="hljs-string">"connection timed out: "</span> + remoteAddress);                <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;                    close(voidPromise());                &#125;            &#125;        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);    &#125;       ...        &#125;</code></pre><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png" srcset="/img/loading.gif" alt=""></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png" srcset="/img/loading.gif" alt=""></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png" srcset="/img/loading.gif" alt=""></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li><strong>全连接队列 - accept queue</strong><ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 设置全连接队列，大小为2</span><span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.SO_BACKLOG, <span class="hljs-number">2</span>);</code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; <span class="hljs-keyword">else</span> &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;</code></pre><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> backlog = NetUtil.SOMAXCONN;</code></pre><p>具体的赋值操作如下</p><pre><code class="hljs java">SOMAXCONN = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span>        <span class="hljs-comment">// The known defaults:</span>        <span class="hljs-comment">// - Windows NT Server 4.0+: 200</span>        <span class="hljs-comment">// - Linux and Mac OS X: 128</span>        <span class="hljs-keyword">int</span> somaxconn = PlatformDependent.isWindows() ? <span class="hljs-number">200</span> : <span class="hljs-number">128</span>;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/proc/sys/net/core/somaxconn"</span>);        BufferedReader in = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span>            <span class="hljs-comment">// try / catch block.</span>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/4936</span>            <span class="hljs-keyword">if</span> (file.exists()) &#123;                in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(file));                <span class="hljs-comment">// 将somaxconn设置为Linux配置文件中设置的值</span>                somaxconn = Integer.parseInt(in.readLine());                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;                    logger.debug(<span class="hljs-string">"&#123;&#125;: &#123;&#125;"</span>, file, somaxconn);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                ...            &#125;            ...        &#125;          <span class="hljs-comment">// 返回backlog的值</span>        <span class="hljs-keyword">return</span> somaxconn;    &#125;&#125;</code></pre><ul><li>backlog的值会根据操作系统的不同，来<strong>选择不同的默认值</strong><ul><li>Windows 200</li><li>Linux/Mac OS 128</li></ul></li><li><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre><code class="hljs java"><span class="hljs-comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span><span class="hljs-comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span><span class="hljs-keyword">new</span> ServerBootstrap().childOption(ChannelOption.ALLOCATOR, <span class="hljs-keyword">new</span> PooledByteBufAllocator());</code></pre><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><pre><code class="hljs java"><span class="hljs-comment">// true表示使用直接内存</span><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">true</span>);</code></pre></li><li><p>池化并使用堆内存</p><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">false</span>);</code></pre></li><li><p>非池化并使用直接内存</p><pre><code class="hljs java"><span class="hljs-comment">// ture表示使用直接内存</span><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">true</span>);</code></pre></li><li><p>非池化并使用堆内存</p><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">false</span>);</code></pre></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    ...    <span class="hljs-comment">// 添加RPC消息类型</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="hljs-number">101</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="hljs-number">102</span>;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 将消息类型放入消息类对象Map中</span>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><p><strong>RPC请求消息</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String interfaceName;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调用接口中的方法名</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String methodName;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法返回类型</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Class&lt;?&gt; returnType;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法参数类型数组</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Class[] parameterTypes;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法参数值数组</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Object[] parameterValue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RpcRequestMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;        <span class="hljs-keyword">super</span>.setSequenceId(sequenceId);        <span class="hljs-keyword">this</span>.interfaceName = interfaceName;        <span class="hljs-keyword">this</span>.methodName = methodName;        <span class="hljs-keyword">this</span>.returnType = returnType;        <span class="hljs-keyword">this</span>.parameterTypes = parameterTypes;        <span class="hljs-keyword">this</span>.parameterValue = parameterValue;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInterfaceName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> interfaceName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMethodName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> methodName;    &#125;    <span class="hljs-keyword">public</span> Class&lt;?&gt; getReturnType() &#123;        <span class="hljs-keyword">return</span> returnType;    &#125;    <span class="hljs-keyword">public</span> Class[] getParameterTypes() &#123;        <span class="hljs-keyword">return</span> parameterTypes;    &#125;    <span class="hljs-keyword">public</span> Object[] getParameterValue() &#123;        <span class="hljs-keyword">return</span> parameterValue;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"RpcRequestMessage&#123;"</span> +                <span class="hljs-string">"interfaceName='"</span> + interfaceName + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", methodName='"</span> + methodName + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", returnType="</span> + returnType +                <span class="hljs-string">", parameterTypes="</span> + Arrays.toString(parameterTypes) +                <span class="hljs-string">", parameterValue="</span> + Arrays.toString(parameterValue) +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Object returnValue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 异常值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Exception exceptionValue;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;    &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReturnValue</span><span class="hljs-params">(Object returnValue)</span> </span>&#123;        <span class="hljs-keyword">this</span>.returnValue = returnValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExceptionValue</span><span class="hljs-params">(Exception exceptionValue)</span> </span>&#123;        <span class="hljs-keyword">this</span>.exceptionValue = exceptionValue;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getReturnValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> returnValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Exception <span class="hljs-title">getExceptionValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> exceptionValue;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"RpcResponseMessage&#123;"</span> +                <span class="hljs-string">"returnValue="</span> + returnValue +                <span class="hljs-string">", exceptionValue="</span> + exceptionValue +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();        <span class="hljs-comment">// PRC 请求消息处理器</span>        RpcRequestMessageHandler rpcRequestMessageHandler = <span class="hljs-keyword">new</span> RpcRequestMessageHandler();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            serverBootstrap.group(boss, worker);            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                    ch.pipeline().addLast(rpcRequestMessageHandler);                &#125;            &#125;);            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();            channel.closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();        <span class="hljs-comment">// PRC 请求消息处理器</span>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();        <span class="hljs-keyword">try</span> &#123;            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            bootstrap.group(group);            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                    ch.pipeline().addLast(rpcResponseMessageHandler);                &#125;            &#125;);            Channel channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>)).sync().channel();            channel.closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>通过接口Class获取实例对象的<strong>Factory</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServicesFactory</span> </span>&#123;    <span class="hljs-keyword">static</span> HashMap&lt;Class&lt;?&gt;, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Class&lt;?&gt; interfaceClass)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;        <span class="hljs-comment">// 根据Class创建实例</span>        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"cn.nyimac.study.day8.server.service.HelloService"</span>);            Object instance = Class.forName(<span class="hljs-string">"cn.nyimac.study.day8.server.service.HelloServiceImpl"</span>).newInstance();                       <span class="hljs-comment">// 放入 InterfaceClass -&gt; InstanceObject 的映射</span>            map.put(clazz, instance);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;            e.printStackTrace();        &#125;          <span class="hljs-keyword">return</span> map.get(interfaceClass);    &#125;&#125;</code></pre><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcRequestMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage)</span> </span>&#123;        RpcResponseMessage rpcResponseMessage = <span class="hljs-keyword">new</span> RpcResponseMessage();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 设置返回值的属性</span>            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());            <span class="hljs-comment">// 返回一个实例</span>            HelloService service = (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));                        <span class="hljs-comment">// 通过反射调用方法，并获取返回值</span>            Method method = service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());            <span class="hljs-comment">// 获得返回值</span>            Object invoke = method.invoke(service, rpcMessage.getParameterValue());            <span class="hljs-comment">// 设置返回值</span>            rpcResponseMessage.setReturnValue(invoke);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-comment">// 设置异常</span>            rpcResponseMessage.setExceptionValue(e);        &#125;    &#125;    <span class="hljs-comment">// 向channel中写入Message</span>    ctx.writeAndFlush(rpcResponseMessage);&#125;</code></pre><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        log.debug(<span class="hljs-string">"&#123;&#125;"</span>, msg);        System.out.println((String)msg.getReturnValue());    &#125;&#125;</code></pre><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;...                   <span class="hljs-comment">// 创建请求并发送</span>RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(<span class="hljs-number">1</span>,               <span class="hljs-string">"cn.nyimac.study.day8.server.service.HelloService"</span>,               <span class="hljs-string">"sayHello"</span>,               String<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span>               new Class[]&#123;String.class&#125;,               <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">"Nyima"</span>&#125;);        channel.writeAndFlush(message);                       ...        &#125;&#125;</code></pre><p><strong>运行结果</strong></p><p>客户端</p><pre><code class="hljs java"><span class="hljs-number">1606</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue=你好，Nyima, exceptionValue=<span class="hljs-keyword">null</span>&#125;</code></pre><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClientManager</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 产生SequenceId</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger sequenceId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Channel channel = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建代理对象</span>        HelloService service = (HelloService) getProxy(HelloService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 通过代理对象执行方法</span>        System.out.println(service.sayHello(<span class="hljs-string">"Nyima"</span>));        System.out.println(service.sayHello(<span class="hljs-string">"Hulu"</span>));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 单例模式创建Channel</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (lock) &#123;                <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) &#123;                    init();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> channel;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用代理模式，帮助我们创建请求消息并发送</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;        Class&lt;?&gt;[] classes = <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;;        <span class="hljs-comment">// 使用JDK代理，创建代理对象</span>        Object o = Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, <span class="hljs-keyword">new</span> InvocationHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                <span class="hljs-comment">// 创建请求消息</span>                <span class="hljs-keyword">int</span> id = sequenceId.getAndIncrement();                RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(id, serviceClass.getName(),                        method.getName(), method.getReturnType(),                        method.getParameterTypes(),                        args);                <span class="hljs-comment">// 发送消息</span>                getChannel().writeAndFlush(message);                <span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span>                DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());                <span class="hljs-comment">// 将Promise放入Map中</span>                RpcResponseMessageHandler.promiseMap.put(id, promise);                <span class="hljs-comment">// 等待被放入Promise中结果</span>                promise.await();                <span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;                    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span>                    <span class="hljs-keyword">return</span> promise.getNow();                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 调用方法失败，抛出异常</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());                &#125;            &#125;        &#125;);        <span class="hljs-keyword">return</span> o;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();        <span class="hljs-comment">// PRC 请求消息处理器</span>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        bootstrap.group(group);        bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());                ch.pipeline().addLast(loggingHandler);                ch.pipeline().addLast(messageSharableCodec);                ch.pipeline().addLast(rpcResponseMessageHandler);            &#125;        &#125;);        <span class="hljs-keyword">try</span> &#123;            channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>)).sync().channel();            <span class="hljs-comment">// 异步关闭 group，避免Channel被阻塞</span>            channel.closeFuture().addListener(future -&gt; &#123;                group.shutdownGracefully();            &#125;);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>获得Channel</strong></p><ul><li><p>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></p></li><li><p>通过<strong>单例模式</strong>创建与获取Channel</p></li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><pre><code class="hljs java"><span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span>DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<span class="hljs-comment">// 将Promise放入Map中</span>RpcResponseMessageHandler.promiseMap.put(id, promise);<span class="hljs-comment">// 等待被放入Promise中结果</span>promise.await();<span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span>    <span class="hljs-keyword">return</span> promise.getNow();&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 调用方法失败，抛出异常</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());&#125;</code></pre></li><li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span>Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());Object returnValue = msg.getReturnValue();Exception exception = msg.getExceptionValue();<span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 返回结果中有异常信息</span>        promise.setFailure(exception);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 方法正常执行，没有异常</span>        promise.setSuccess(returnValue);    &#125;&#125;</code></pre></li></ul><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span>        Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());        Object returnValue = msg.getReturnValue();        Exception exception = msg.getExceptionValue();        <span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 返回结果中有异常信息</span>                promise.setFailure(exception);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 方法正常执行，没有异常</span>                promise.setSuccess(returnValue);            &#125;        &#125;        <span class="hljs-comment">// 拿到返回结果并打印</span>        log.debug(<span class="hljs-string">"&#123;&#125;"</span>, msg);    &#125;&#125;</code></pre><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><pre><code class="hljs java"><span class="hljs-comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span>Selector selector = Selector.open(); <span class="hljs-comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span>NioServerSocketChannel attachment = <span class="hljs-keyword">new</span> NioServerSocketChannel();<span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 启动 nio boss 线程执行接下来的操作</span><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span>SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><span class="hljs-comment">// 绑定端口</span>serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span>selectionKey.interestOps(SelectionKey.OP_ACCEPT);</code></pre><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;validate();<span class="hljs-keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">"localAddress"</span>));&#125;</code></pre><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;    <span class="hljs-comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span>    <span class="hljs-comment">// init由main线程完成，regisetr由NIO线程完成</span>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> regFuture;    &#125;    <span class="hljs-comment">// 因为register操作是异步的</span>    <span class="hljs-comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>        ChannelPromise promise = channel.newPromise();                <span class="hljs-comment">// 执行doBind0绑定操作</span>        doBind0(regFuture, channel, localAddress, promise);        <span class="hljs-keyword">return</span> promise;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it's not.</span>        <span class="hljs-comment">// 如果register操作还没执行完，就会到这个分支中来</span>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);                <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span>        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                Throwable cause = future.cause();                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>                    promise.setFailure(cause);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        <span class="hljs-keyword">return</span> promise;    &#125;&#125;</code></pre><ul><li><p>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></p></li><li><p><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</p></li><li><p><strong>doBind0</strong>则负责连接的创建工作</p></li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;    Channel channel = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        channel = channelFactory.newChannel();        init(channel);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span>            channel.unsafe().closeForcibly();            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);        &#125;        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);    &#125;    ChannelFuture regFuture = config().group().register(channel);    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;            channel.close();        &#125; <span class="hljs-keyword">else</span> &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;    <span class="hljs-comment">// If we are here and the promise is not failed, it's one of the following cases:</span>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span>    <span class="hljs-comment">//    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.</span>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span>    <span class="hljs-comment">//    added to the event loop's task queue for later execution.</span>    <span class="hljs-comment">//    i.e. It's safe to attempt bind() or connect() now:</span>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span>    <span class="hljs-keyword">return</span> regFuture;&#125;</code></pre><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code class="hljs java">Channel channel = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 通过反射初始化NioServerSocketChannel</span>    channel = channelFactory.newChannel();    init(channel);&#125;</code></pre><p>newChannel方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newChannel</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 通过反射调用NioServerSocketChannel的构造方法</span>        <span class="hljs-comment">// 创建NioServerSocketChannel对象</span>        <span class="hljs-keyword">return</span> constructor.newInstance();    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">"Unable to create Channel from class "</span> + constructor.getDeclaringClass(), t);    &#125;&#125;</code></pre><p>NioServerSocketChannel构造方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerSocketChannel</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 创建了ServerSocketChannel实例</span>    <span class="hljs-keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125;</code></pre><p>newSocket方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title">newSocket</span><span class="hljs-params">(SelectorProvider provider)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// ServerSocketChannel.open方法：</span>        <span class="hljs-comment">// SelectorProvider.provider().openServerSocketChannel()</span>    <span class="hljs-comment">// 所以此处相当于ServerSocketChannel.open()</span>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span>    <span class="hljs-keyword">return</span> provider.openServerSocketChannel();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">"Failed to open a server socket."</span>, e);&#125;&#125;</code></pre><p><strong>init方法</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;   ...    <span class="hljs-comment">// NioSocketChannl的Pipeline    </span>    ChannelPipeline p = channel.pipeline();    ...    <span class="hljs-comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">// register之后才调用该方法</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();                        <span class="hljs-comment">// 创建handler并加入到pipeline中</span>            ChannelHandler handler = config.handler();            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;                pipeline.addLast(handler);            &#125;            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-comment">// 添加新的handler，在发生Accept事件后建立连接</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));                &#125;            &#125;);        &#125;    &#125;);&#125;</code></pre><p><strong>init主要完成了以下三个操作</strong></p><ul><li>创建NioServerSocketChannel</li><li>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</li><li>由<code>initChannel</code>方法向NioServerSocketChannel中添加了两个handler，<strong>添加操作在register之后被执行</strong><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    ...    <span class="hljs-comment">// 获取EventLoop</span>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;   <span class="hljs-comment">// 此处完成了由 主线程 到 NIO线程 的切换</span>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 向NIO线程中添加任务</span>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-comment">// 该方法中会执行doRegister</span>                    <span class="hljs-comment">// 执行真正的注册操作</span>                    register0(promise);                &#125;            &#125;);        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;           ...        &#125;    &#125;&#125;</code></pre><p>register0方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;       ...                    <span class="hljs-comment">// 执行真正的注册操作</span>        doRegister();        neverRegistered = <span class="hljs-keyword">false</span>;        registered = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span>                <span class="hljs-comment">// 调用init中的initChannel方法</span>        pipeline.invokeHandlerAddedIfNeeded();        ...    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        ...    &#125;&#125;</code></pre><p><strong>doRegister方法</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span>            <span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;            ...                   &#125;    &#125;&#125;</code></pre><p>回调initChannel</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();    ChannelHandler handler = config.handler();    <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;        pipeline.addLast(handler);    &#125;    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));        &#125;    &#125;);&#125;</code></pre><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><pre><code class="hljs java"><span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);</code></pre><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li>initChannel方法主要创建了<strong>两个handler</strong><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><pre><code class="hljs java"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Throwable cause = future.cause();        <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>            promise.setFailure(cause);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>            promise.registered();            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span>            doBind0(regFuture, channel, localAddress, promise);        &#125;    &#125;&#125;);</code></pre><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><pre><code class="hljs java"><span class="hljs-meta">@SuppressJava</span>6Requirement(reason = <span class="hljs-string">"Usage guarded by java version check"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span>        javaChannel().bind(localAddress, config.getBacklog());    &#125; <span class="hljs-keyword">else</span> &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;</code></pre><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;    invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            pipeline.fireChannelActive();        &#125;    &#125;);&#125;</code></pre><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 则让其关注Accepet事件</span>        <span class="hljs-comment">// readInterestOp 取值是 16</span>        <span class="hljs-comment">// 在 NioServerSocketChannel 创建时初始化</span>        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;</code></pre><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();</code></pre></li><li><p>然后再设置其感兴趣的事件</p><pre><code class="hljs java">selectionKey.interestOps(interestOps | readInterestOp);</code></pre></li></ul><p><strong>各个事件对应的值</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png" srcset="/img/loading.gif" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleThreadEventLoop</span> </span>&#123;        ...            <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span>    <span class="hljs-keyword">private</span> Selector selector;    <span class="hljs-keyword">private</span> Selector unwrappedSelector;    <span class="hljs-keyword">private</span> SelectedSelectionKeySet selectedKeys;        ...&#125;</code></pre></li><li><p><strong>Thread与TaskQueue</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractScheduledEventExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderedEventExecutor</span> </span>&#123;    <span class="hljs-comment">// 任务队列</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;    <span class="hljs-comment">// 线程</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread thread;&#125;</code></pre></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;            ...                   <span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span>        <span class="hljs-keyword">final</span> SelectorTuple selectorTuple = openSelector();        <span class="hljs-keyword">this</span>.selector = selectorTuple.selector;        <span class="hljs-keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title">openSelector</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> Selector unwrappedSelector;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span>        unwrappedSelector = provider.openSelector();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">"failed to open a new selector"</span>, e);    &#125;&#125;</code></pre><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><pre><code class="hljs java">unwrappedSelector = provider.openSelector();</code></pre><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;    <span class="hljs-keyword">final</span> Selector unwrappedSelector;    <span class="hljs-keyword">final</span> Selector selector;    SelectorTuple(Selector unwrappedSelector) &#123;        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 一般调用的是这个构造方法</span><span class="hljs-comment">    */</span>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;        <span class="hljs-keyword">this</span>.selector = selector;    &#125;&#125;</code></pre><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title">openSelector</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> Selector unwrappedSelector;    <span class="hljs-keyword">try</span> &#123;        unwrappedSelector = provider.openSelector();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">"failed to open a new selector"</span>, e);    &#125;    ...        <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span>    <span class="hljs-keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();    Object maybeException = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span>                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">"selectedKeys"</span>);                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">"publicSelectedKeys"</span>);                ...                <span class="hljs-comment">// 暴力反射，修改私有属性</span>                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-keyword">true</span>);                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> cause;                &#125;                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-keyword">true</span>);                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> cause;                &#125;                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span>                selectedKeysField.set(unwrappedSelector, selectedKeySet);                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;                <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;                <span class="hljs-keyword">return</span> e;            &#125;        &#125;    &#125;);    selectedKeys = selectedKeySet;        <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,                             <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125;</code></pre><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><pre><code class="hljs java"><span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><span class="hljs-keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();SelectedSelectionKeySet() &#123;keys = <span class="hljs-keyword">new</span> SelectionKey[<span class="hljs-number">1024</span>];&#125;</code></pre></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)</code></pre></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><pre><code class="hljs java"><span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector, <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</code></pre></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNioEventLoop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        EventLoop eventLoop = <span class="hljs-keyword">new</span> NioEventLoopGroup().next();        <span class="hljs-comment">// 使用NioEventLoop执行任务</span>        eventLoop.execute(()-&gt;&#123;            System.out.println(<span class="hljs-string">"hello"</span>);        &#125;);    &#125;&#125;</code></pre><p>进入<code>execute</code>执行任务</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span>    ObjectUtil.checkNotNull(task, <span class="hljs-string">"task"</span>);    <span class="hljs-comment">// 执行任务</span>    <span class="hljs-comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span>    execute(task, !(task <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));&#125;</code></pre><p>进入上述代码的<code>execute</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;    <span class="hljs-comment">// 判断当前线程是否为NIO线程</span>    <span class="hljs-comment">// 判断方法为 return thread == this.thread;</span>    <span class="hljs-comment">// this.thread即为NIO线程，首次执行任务时，其为null</span>    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();        <span class="hljs-comment">// 向任务队列taskQueue中添加任务</span>    addTask(task);        <span class="hljs-comment">// 当前线程不是NIO线程，则进入if语句</span>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;        <span class="hljs-comment">// 启动NIO线程的核心方法</span>        startThread();                ...            &#125;    <span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;        wakeup(inEventLoop);    &#125;&#125;</code></pre><p>进入<code>startThread</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span>    <span class="hljs-comment">// 该if代码块只会执行一次</span>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;        <span class="hljs-comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 执行启动线程</span>                doStartThread();                success = <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">if</span> (!success) &#123;                    STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_STARTED, ST_NOT_STARTED);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">assert</span> thread == <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 创建NIO线程并执行任务</span>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// thread即为NIO线程</span>            thread = Thread.currentThread();            <span class="hljs-keyword">if</span> (interrupted) &#123;                thread.interrupt();            &#125;            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;            updateLastExecutionTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 执行内部run方法</span>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();                success = <span class="hljs-keyword">true</span>;            &#125;                         ...    &#125;);&#125;</code></pre><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span>    <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-comment">// 执行各种任务</span>   <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> strategy;            <span class="hljs-keyword">try</span> &#123;                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());                <span class="hljs-keyword">switch</span> (strategy) &#123;                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:                    <span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();                    <span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;                        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span>                    &#125;                    nextWakeupNanos.set(curDeadlineNanos);                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">if</span> (!hasTasks()) &#123;                            strategy = select(curDeadlineNanos);                        &#125;                    &#125; <span class="hljs-keyword">finally</span> &#123;                        <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span>                        <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span>                        nextWakeupNanos.lazySet(AWAKE);                    &#125;                    <span class="hljs-comment">// fall through</span>                <span class="hljs-keyword">default</span>:                &#125;       &#125;    &#125;&#125;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span>    <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-comment">// 执行各种任务</span>   ...    &#125;&#125;</code></pre><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:<span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span>    &#125;nextWakeupNanos.set(curDeadlineNanos);<span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">if</span> (!hasTasks()) &#123;            <span class="hljs-comment">// 执行select方法</span>            strategy = select(curDeadlineNanos);        &#125;    &#125;...</code></pre><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deadlineNanos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 如果没有指定阻塞事件，就调用select()</span>    <span class="hljs-keyword">if</span> (deadlineNanos == NONE) &#123;        <span class="hljs-keyword">return</span> selector.select();    &#125;    <span class="hljs-comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span>    <span class="hljs-comment">// Timeout will only be 0 if deadline is within 5 microsecs</span>    <span class="hljs-keyword">long</span> timeoutMillis = deadlineToDelayNanos(deadlineNanos + <span class="hljs-number">995000L</span>) / <span class="hljs-number">1000000L</span>;    <span class="hljs-keyword">return</span> timeoutMillis &lt;= <span class="hljs-number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);&#125;</code></pre><p>但需要注意的是，<strong><code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程</strong></p><p>唤醒是通过execute最后的if代码块来完成的</p><pre><code class="hljs java"><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;    wakeup(inEventLoop);&#125;</code></pre><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> inEventLoop)</span> </span>&#123;    <span class="hljs-comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span>    <span class="hljs-comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;        <span class="hljs-comment">// 唤醒被selector.select方法阻塞的NIO线程</span>        selector.wakeup();    &#125;&#125;</code></pre><p>唤醒时需要进行两个判断</p><ul><li>判断提交任务的<strong>是否为NIO线程</strong><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<span class="hljs-keyword">switch</span> (strategy) &#123;...&#125;</code></pre><p>strategy的值由<code>calculateStrategy</code>方法确定</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateStrategy</span><span class="hljs-params">(IntSupplier selectSupplier, <span class="hljs-keyword">boolean</span> hasTasks)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// selectSupplier.get() 底层是 selector.selectNow();</span>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;&#125;</code></pre><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IntSupplier selectNowSupplier = <span class="hljs-keyword">new</span> IntSupplier() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> NioEventLoop.<span class="hljs-keyword">this</span>.selectNow();    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selector.selectNow();&#125;</code></pre></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p> Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    ...    <span class="hljs-keyword">for</span>(;;)&#123;        ...        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span>        strategy = select(curDeadlineNanos);          ...              <span class="hljs-keyword">if</span>(...) &#123;...     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span>            <span class="hljs-comment">// 并将selectCnt重置为0</span>            selectCnt = <span class="hljs-number">0</span>;        &#125;&#125;&#125;</code></pre><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;    <span class="hljs-comment">// The selector returned prematurely many times in a row.</span>    <span class="hljs-comment">// Rebuild the selector to work around the problem.</span>    logger.warn(<span class="hljs-string">"Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;."</span>,selectCnt, selector);    <span class="hljs-comment">// 重建selector，将原selector的配置信息传给新selector</span>    <span class="hljs-comment">// 再用新selector覆盖旧selector</span>    rebuildSelector();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 处理IO事件时间比例，默认为50%</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<span class="hljs-comment">// 如果IO事件时间比例设置为100%</span><span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 如果需要去处理IO事件</span>        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 先处理IO事件</span>            processSelectedKeys();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Ensure we always run tasks.</span>        <span class="hljs-comment">// 剩下的时间都去处理普通任务和定时任务</span>        ranTasks = runAllTasks();    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果需要去处理IO事件</span>    <span class="hljs-comment">// 记录处理IO事件前的时间</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 去处理IO事件</span>        processSelectedKeys();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Ensure we always run tasks.</span>        <span class="hljs-comment">// ioTime为处理IO事件耗费的事件</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;        <span class="hljs-comment">// 计算出处理其他任务的事件</span>        <span class="hljs-comment">// 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行</span>        ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);    &#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有IO事件需要处理</span>    <span class="hljs-comment">// This will run the minimum number of tasks</span>    <span class="hljs-comment">// 直接处理普通和定时任务</span>    ranTasks = runAllTasks(<span class="hljs-number">0</span>); &#125;</code></pre><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 没有指定执行任务的时间</span>ranTasks = runAllTasks();</code></pre></li></ul></li><li><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 比如ioTime为10s，ioRatio为50</span><span class="hljs-comment">// 那么通过 10*(100-50)/50=10 计算出其他任务可用的时间为 10s</span><span class="hljs-comment">// 处理IO事件占用的事件总比例为50%</span>ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);</code></pre></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><pre><code class="hljs java"><span class="hljs-comment">// 运行最少数量的任务</span>ranTasks = runAllTasks(<span class="hljs-number">0</span>);</code></pre></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeys</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果selectedKeys是基于数组的</span>    <span class="hljs-comment">// 一般情况下都走这个分支</span>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 处理各种IO事件</span>        processSelectedKeysOptimized();    &#125; <span class="hljs-keyword">else</span> &#123;        processSelectedKeysPlain(selector.selectedKeys());    &#125;&#125;</code></pre><p>processSelectedKeysOptimized方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;        <span class="hljs-comment">// 拿到SelectionKeyec</span>        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];        <span class="hljs-comment">// null out entry in the array to allow to have it GC'ed once the Channel close</span>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span>        <span class="hljs-keyword">final</span> Object a = k.attachment();        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;            <span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span>            processSelectedKey(k, (AbstractNioChannel) a);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;            processSelectedKey(k, task);        &#125;        <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;            <span class="hljs-comment">// null out entries in the array to allow to have it GC'ed once the Channel close</span>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span>            selectedKeys.reset(i + <span class="hljs-number">1</span>);            selectAgain();            i = -<span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];</code></pre><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><pre><code class="hljs java"><span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><span class="hljs-keyword">final</span> Object a = k.attachment();</code></pre><p>如果附件继承自AbstractNioChannel，则会调用</p><pre><code class="hljs java"><span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span>processSelectedKey(k, (AbstractNioChannel) a);</code></pre><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;        <span class="hljs-keyword">final</span> EventLoop eventLoop;        <span class="hljs-keyword">try</span> &#123;            eventLoop = ch.eventLoop();        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span>            <span class="hljs-comment">// to close ch.</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span>        <span class="hljs-comment">// still healthy and should not be closed.</span>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">// close the channel if the key is not valid anymore</span>            unsafe.close(unsafe.voidPromise());        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">int</span> readyOps = k.readyOps();        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span>            <span class="hljs-keyword">int</span> ops = k.interestOps();            ops &amp;= ~SelectionKey.OP_CONNECT;            k.interestOps(ops);            unsafe.finishConnect();        &#125;        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span>            ch.unsafe().forceFlush();        &#125;        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span>        <span class="hljs-comment">// to a spin loop</span>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;            unsafe.read();        &#125;    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;        unsafe.close(unsafe.voidPromise());    &#125;&#125;</code></pre><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><pre><code class="hljs java"><span class="hljs-comment">// 阻塞直到事件发生</span>selector.select();Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<span class="hljs-keyword">while</span> (iter.hasNext()) &#123;        <span class="hljs-comment">// 拿到一个事件</span>    SelectionKey key = iter.next();        <span class="hljs-comment">// 如果是 accept 事件</span>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                <span class="hljs-comment">// 执行accept，获得SocketChannel</span>        SocketChannel channel = serverSocketChannel.accept();        channel.configureBlocking(<span class="hljs-keyword">false</span>);                <span class="hljs-comment">// 将SocketChannel注册到selector中，并关注read事件</span>        channel.register(selector, SelectionKey.OP_READ);    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;unsafe.read();&#125;</code></pre><p><code>NioMessageUnsafe.read</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    ...        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span>                <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span>                <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span>                <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span>                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);                                ...                <span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span>                allocHandle.incMessagesRead(localRead);            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            exception = t;        &#125;        <span class="hljs-keyword">int</span> size = readBuf.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;            readPending = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span>            <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span>            pipeline.fireChannelRead(readBuf.get(i));        &#125;                ...            &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;</code></pre><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span>    SocketChannel ch = SocketUtils.accept(javaChannel());    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span>            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;       ...    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p> <code>ServerBootstrapAcceptor.channelRead</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span>    <span class="hljs-keyword">final</span> Channel child = (Channel) msg;    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span>    child.pipeline().addLast(childHandler);    <span class="hljs-comment">// 设置选项</span>    setChannelOptions(child, childOptions, logger);    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;</code></pre><p>通过<code>AbstractUnsafe.register</code>  方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;        ...    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-comment">// 真正的注册操作</span>                    register0(promise);                &#125;            &#125;);        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            ...        &#125;    &#125;&#125;</code></pre><p><code>AbstractChannel.AbstractUnsafe.register0</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;                ...                    <span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span>        doRegister();                <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span>        pipeline.invokeHandlerAddedIfNeeded();        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span>        safeSetSuccess(promise);        pipeline.fireChannelRegistered();                <span class="hljs-keyword">if</span> (isActive()) &#123;            <span class="hljs-keyword">if</span> (firstRegistration) &#123;                <span class="hljs-comment">// 触发pipeline上active事件</span>                pipeline.fireChannelActive();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;                beginRead();            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        closeForcibly();        closeFuture.setClosed();        safeSetFailure(promise, t);    &#125;&#125;</code></pre><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 将Selector注册到Selector中</span>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;            ...        &#125;    &#125;&#125;</code></pre><p> <code>HeadContext.channelActive</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    ctx.fireChannelActive();<span class="hljs-comment">// 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)</span>    readIfIsAutoRead();&#125;</code></pre><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;<span class="hljs-comment">// 这时候 interestOps是0</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 关注read事件</span>        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;</code></pre><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;unsafe.read();&#125;</code></pre><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 获得Channel的配置</span>    <span class="hljs-keyword">final</span> ChannelConfig config = config();    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;        clearReadPending();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<span class="hljs-comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span><span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();    allocHandle.reset(config);    ByteBuf byteBuf = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// 创建ByteBuf</span>            byteBuf = allocHandle.allocate(allocator);            <span class="hljs-comment">// 读取内容，放入ByteBUf中</span>            allocHandle.lastBytesRead(doReadBytes(byteBuf));            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;                byteBuf.release();                byteBuf = <span class="hljs-keyword">null</span>;                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span> (close) &#123;                    readPending = <span class="hljs-keyword">false</span>;                &#125;                <span class="hljs-keyword">break</span>;            &#125;            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);            readPending = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 触发read 事件，让pipeline上的handler处理</span>            <span class="hljs-comment">// 这时是处理NioSocketChannel上的handler</span>            pipeline.fireChannelRead(byteBuf);            byteBuf = <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-comment">// 是否要继续循环</span>        <span class="hljs-keyword">while</span> (allocHandle.continueReading());        allocHandle.readComplete();        <span class="hljs-comment">// 触发 read complete事件</span>        pipeline.fireChannelReadComplete();        <span class="hljs-keyword">if</span> (close) &#123;            closeOnRead(pipeline);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        handleReadException(pipeline, byteBuf, t, close, allocHandle);    &#125; <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span>         <span class="hljs-comment">// This could be for two reasons:</span>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span>         <span class="hljs-comment">//</span>         <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;</code></pre><p><code>DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">continueReading</span><span class="hljs-params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;    <span class="hljs-keyword">return</span>            <span class="hljs-comment">// 一般为true</span>           config.isAutoRead() &amp;&amp;           <span class="hljs-comment">// respectMaybeMoreData默认为true</span>           <span class="hljs-comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span>           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;           <span class="hljs-comment">// 小于最大次数，maxMessagePerRead默认16</span>           totalMessages &lt; maxMessagePerRead &amp;&amp;           <span class="hljs-comment">// 实际读到了数据</span>           totalBytesRead &gt; <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习之NIO基础</title>
    <link href="/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty学习之NIO基础"><a href="#Netty学习之NIO基础" class="headerlink" title="Netty学习之NIO基础"></a>Netty学习之NIO基础</h1><p>本博客是根据<a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=2" target="_blank" rel="noopener"><strong>黑马程序员Netty实战</strong></a>学习时所做的笔记</p><p>可先参考博客<a href="https://nyimac.gitee.io/2020/11/30/Java%20NIO/"><strong>Java NIO</strong></a></p><h1 id="一、三大组件简介"><a href="#一、三大组件简介" class="headerlink" title="一、三大组件简介"></a>一、三大组件简介</h1><p>Channel与Buffer</p><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)</strong>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于<strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Buffer有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li><strong>ByteBuffer</strong><ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png" srcset="/img/loading.gif" alt=""></p><h2 id="1、Selector"><a href="#1、Selector" class="headerlink" title="1、Selector"></a>1、Selector</h2><p>在使用Selector之前，处理socket连接还有以下两种方法</p><p><strong>使用多线程技术</strong></p><p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png" srcset="/img/loading.gif" alt=""></p><p>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><p><strong>使用线程池技术</strong></p><p>使用线程池，让线程池中的线程去处理连接</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png" srcset="/img/loading.gif" alt=""></p><p>这种方法存在以下几个问题</p><ul><li>阻塞模式下，线程仅能处理一个连接<ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li></ul></li><li>仅适合<strong>短连接</strong>场景<ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><p><strong>使用选择器</strong></p><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png" srcset="/img/loading.gif" alt=""></p><p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="2、ByteBuffer"><a href="#2、ByteBuffer" class="headerlink" title="2、ByteBuffer"></a>2、ByteBuffer</h2><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>向 buffer 写入数据，例如调用 channel.read(buffer)</li><li>调用 flip() 切换至<strong>读模式</strong><ul><li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li></ul></li><li>从 buffer 读取数据，例如调用 buffer.get()</li><li>调用 clear() 或者compact()切换至<strong>写模式</strong><ul><li>调用clear()方法时<strong>position=0，limit变为capacity</strong></li><li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li></ul></li><li>重复以上步骤</li></ul><p><strong>使用ByteBuffer读取文件中的内容</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获得FileChannel</span>        <span class="hljs-keyword">try</span> (FileChannel channel = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"stu.txt"</span>).getChannel()) &#123;            <span class="hljs-comment">// 获得缓冲区</span>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);            <span class="hljs-keyword">int</span> hasNext = <span class="hljs-number">0</span>;            StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">while</span>((hasNext = channel.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 切换模式 limit=position, position=0</span>                buffer.flip();                <span class="hljs-comment">// 当buffer中还有数据时，获取其中的数据</span>                <span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;                    builder.append((<span class="hljs-keyword">char</span>)buffer.get());                &#125;                <span class="hljs-comment">// 切换模式 position=0, limit=capacity</span>                buffer.clear();            &#125;            System.out.println(builder.toString());        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        &#125;    &#125;&#125;</code></pre><p>打印结果</p><pre><code class="hljs angelscript"><span class="hljs-number">0123456789</span>abcdef</code></pre><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;</code></pre><ul><li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li><li><strong>注意：get(i)方法不会改变position的值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p><ul><li>compact会把未读完的数据向前压缩，然后切换到写模式</li><li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png" srcset="/img/loading.gif" alt=""></p><h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a>clear() VS compact()</h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p><p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p><h3 id="方法调用及演示"><a href="#方法调用及演示" class="headerlink" title="方法调用及演示"></a>方法调用及演示</h3><h4 id="ByteBuffer调试工具类"><a href="#ByteBuffer调试工具类" class="headerlink" title="ByteBuffer调试工具类"></a>ByteBuffer调试工具类</h4><p>需要先导入netty依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.51.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> io.netty.util.internal.MathUtil;<span class="hljs-keyword">import</span> io.netty.util.internal.StringUtil;<span class="hljs-keyword">import</span> io.netty.util.internal.MathUtil.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Panwen Chen</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/12 15:59</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> String[<span class="hljs-number">16</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> String[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> String[<span class="hljs-number">256</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> String[<span class="hljs-number">16</span>];    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] DIGITS = <span class="hljs-string">"0123456789abcdef"</span>.toCharArray();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];        &#125;        <span class="hljs-keyword">int</span> i;        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;            <span class="hljs-keyword">int</span> padding = HEXPADDING.length - i;            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(padding * <span class="hljs-number">3</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;                buf.append(<span class="hljs-string">"   "</span>);            &#125;            HEXPADDING[i] = buf.toString();        &#125;        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">12</span>);            buf.append(StringUtil.NEWLINE);            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">'|'</span>);            buf.append(<span class="hljs-string">'|'</span>);            HEXDUMP_ROWPREFIXES[i] = buf.toString();        &#125;        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;            BYTE2HEX[i] = <span class="hljs-string">' '</span> + StringUtil.byteToHexStringPadded(i);        &#125;        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;            <span class="hljs-keyword">int</span> padding = BYTEPADDING.length - i;            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(padding);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;                buf.append(<span class="hljs-string">' '</span>);            &#125;            BYTEPADDING[i] = buf.toString();        &#125;        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;                BYTE2CHAR[i] = <span class="hljs-string">'.'</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                BYTE2CHAR[i] = (<span class="hljs-keyword">char</span>) i;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 打印所有内容</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAll</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;        <span class="hljs-keyword">int</span> oldlimit = buffer.limit();        buffer.limit(buffer.capacity());        StringBuilder origin = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());        System.out.println(<span class="hljs-string">"+--------+-------------------- all ------------------------+----------------+"</span>);        System.out.printf(<span class="hljs-string">"position: [%d], limit: [%d]\n"</span>, buffer.position(), oldlimit);        System.out.println(origin);        buffer.limit(oldlimit);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 打印可读取内容</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugRead</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());        System.out.println(<span class="hljs-string">"+--------+-------------------- read -----------------------+----------------+"</span>);        System.out.printf(<span class="hljs-string">"position: [%d], limit: [%d]\n"</span>, buffer.position(), buffer.limit());        System.out.println(builder);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendPrettyHexDump</span><span class="hljs-params">(StringBuilder dump, ByteBuffer buf, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;        <span class="hljs-keyword">if</span> (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(                    <span class="hljs-string">"expected: "</span> + <span class="hljs-string">"0 &lt;= offset("</span> + offset + <span class="hljs-string">") &lt;= offset + length("</span> + length                            + <span class="hljs-string">") &lt;= "</span> + <span class="hljs-string">"buf.capacity("</span> + buf.capacity() + <span class="hljs-string">')'</span>);        &#125;        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        dump.append(                <span class="hljs-string">"         +-------------------------------------------------+"</span> +                        StringUtil.NEWLINE + <span class="hljs-string">"         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |"</span> +                        StringUtil.NEWLINE + <span class="hljs-string">"+--------+-------------------------------------------------+----------------+"</span>);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startIndex = offset;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="hljs-number">4</span>;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> remainder = length &amp; <span class="hljs-number">0xF</span>;        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;            <span class="hljs-keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;            <span class="hljs-comment">// Per-row prefix.</span>            appendHexDumpRowPrefix(dump, row, rowStartIndex);            <span class="hljs-comment">// Hex dump</span>            <span class="hljs-keyword">int</span> rowEndIndex = rowStartIndex + <span class="hljs-number">16</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(<span class="hljs-string">" |"</span>);            <span class="hljs-comment">// ASCII dump</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(<span class="hljs-string">'|'</span>);        &#125;        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);            <span class="hljs-comment">// Hex dump</span>            <span class="hljs-keyword">int</span> rowEndIndex = rowStartIndex + remainder;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(HEXPADDING[remainder]);            dump.append(<span class="hljs-string">" |"</span>);            <span class="hljs-comment">// Ascii dump</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(BYTEPADDING[remainder]);            dump.append(<span class="hljs-string">'|'</span>);        &#125;        dump.append(StringUtil.NEWLINE +                <span class="hljs-string">"+--------+-------------------------------------------------+----------------+"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendHexDumpRowPrefix</span><span class="hljs-params">(StringBuilder dump, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> rowStartIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;            dump.append(HEXDUMP_ROWPREFIXES[row]);        &#125; <span class="hljs-keyword">else</span> &#123;            dump.append(StringUtil.NEWLINE);            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">'|'</span>);            dump.append(<span class="hljs-string">'|'</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">short</span> <span class="hljs-title">getUnsignedByte</span><span class="hljs-params">(ByteBuffer buffer, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0xFF</span>);    &#125;&#125;</code></pre><h4 id="调用ByteBuffer的方法"><a href="#调用ByteBuffer的方法" class="headerlink" title="调用ByteBuffer的方法"></a>调用ByteBuffer的方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);        <span class="hljs-comment">// 向buffer中写入1个字节的数据</span>        buffer.put((<span class="hljs-keyword">byte</span>)<span class="hljs-number">97</span>);        <span class="hljs-comment">// 使用工具类，查看buffer状态</span>        ByteBufferUtil.debugAll(buffer);        <span class="hljs-comment">// 向buffer中写入4个字节的数据</span>        buffer.put(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>&#125;);        ByteBufferUtil.debugAll(buffer);        <span class="hljs-comment">// 获取数据</span>        buffer.flip();        ByteBufferUtil.debugAll(buffer);        System.out.println(buffer.get());        System.out.println(buffer.get());        ByteBufferUtil.debugAll(buffer);        <span class="hljs-comment">// 使用compact切换模式</span>        buffer.compact();        ByteBufferUtil.debugAll(buffer);        <span class="hljs-comment">// 再次写入</span>        buffer.put((<span class="hljs-keyword">byte</span>)<span class="hljs-number">102</span>);        buffer.put((<span class="hljs-keyword">byte</span>)<span class="hljs-number">103</span>);        ByteBufferUtil.debugAll(buffer);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java"><span class="hljs-comment">// 向缓冲区写入了一个字节的数据，此时postition为1</span>+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">1</span>], limit: [<span class="hljs-number">10</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                   |a.........      |+--------+-------------------------------------------------+----------------+<span class="hljs-comment">// 向缓冲区写入四个字节的数据，此时position为5</span>+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">5</span>], limit: [<span class="hljs-number">10</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                   |abcde.....      |+--------+-------------------------------------------------+----------------+<span class="hljs-comment">// 调用flip切换模式，此时position为0，表示从第0个数据开始读取</span>+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">0</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                   |abcde.....      |+--------+-------------------------------------------------+----------------+<span class="hljs-comment">// 读取两个字节的数据             </span><span class="hljs-number">97</span><span class="hljs-number">98</span>            <span class="hljs-comment">// position变为2             </span>+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">2</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                   |abcde.....      |+--------+-------------------------------------------------+----------------+             <span class="hljs-comment">// 调用compact切换模式，此时position及其后面的数据被压缩到ByteBuffer前面去了</span><span class="hljs-comment">// 此时position为3，会覆盖之前的数据             </span>+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">3</span>], limit: [<span class="hljs-number">10</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                   |cdede.....      |+--------+-------------------------------------------------+----------------+             <span class="hljs-comment">// 再次写入两个字节的数据，之前的 0x64 0x65 被覆盖         </span>+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">5</span>], limit: [<span class="hljs-number">10</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">66</span> <span class="hljs-number">67</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                   |cdefg.....      |+--------+-------------------------------------------------+----------------+</code></pre><h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p><p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Translate</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备两个字符串</span>        String str1 = <span class="hljs-string">"hello"</span>;        String str2 = <span class="hljs-string">""</span>;        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="hljs-number">16</span>);        <span class="hljs-comment">// 通过字符串的getByte方法获得字节数组，放入缓冲区中</span>        buffer1.put(str1.getBytes());        ByteBufferUtil.debugAll(buffer1);        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span>        <span class="hljs-comment">// 切换模式</span>        buffer1.flip();                <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span>        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java">+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">5</span>], limit: [<span class="hljs-number">16</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |hello...........|+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">5</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |hello...........|+--------+-------------------------------------------------+----------------+</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Translate</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备两个字符串</span>        String str1 = <span class="hljs-string">"hello"</span>;        String str2 = <span class="hljs-string">""</span>;        <span class="hljs-comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span>        <span class="hljs-comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span>        ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(str1);        ByteBufferUtil.debugAll(buffer1);        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span>        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java">+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">0</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span>                                  |hello           |+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">5</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span>                                  |hello           |+--------+-------------------------------------------------+----------------+</code></pre><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><strong>方法三</strong></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Translate</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备两个字符串</span>        String str1 = <span class="hljs-string">"hello"</span>;        String str2 = <span class="hljs-string">""</span>;        <span class="hljs-comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span>        <span class="hljs-comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span>        ByteBuffer buffer1 = ByteBuffer.wrap(str1.getBytes());        ByteBufferUtil.debugAll(buffer1);        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span>        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java">+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">0</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span>                                  |hello           |+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">5</span>], limit: [<span class="hljs-number">5</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span>                                  |hello           |+--------+-------------------------------------------------+----------------+</code></pre><h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p><strong>粘包</strong></p><p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p><strong>半包</strong></p><p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。<strong>注意</strong>：get(index)不会改变position的值<ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">32</span>);        <span class="hljs-comment">// 模拟粘包+半包</span>        buffer.put(<span class="hljs-string">"Hello,world\nI'm Nyima\nHo"</span>.getBytes());        <span class="hljs-comment">// 调用split函数处理</span>        split(buffer);        buffer.put(<span class="hljs-string">"w are you?\n"</span>.getBytes());        split(buffer);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;        <span class="hljs-comment">// 切换为读模式</span>        buffer.flip();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.limit(); i++) &#123;            <span class="hljs-comment">// 遍历寻找分隔符</span>            <span class="hljs-comment">// get(i)不会移动position</span>            <span class="hljs-keyword">if</span> (buffer.get(i) == <span class="hljs-string">'\n'</span>) &#123;                <span class="hljs-comment">// 缓冲区长度</span>                <span class="hljs-keyword">int</span> length = i+<span class="hljs-number">1</span>-buffer.position();                ByteBuffer target = ByteBuffer.allocate(length);                <span class="hljs-comment">// 将前面的内容写入target缓冲区</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;                    <span class="hljs-comment">// 将buffer中的数据写入target中</span>                    target.put(buffer.get());                &#125;                <span class="hljs-comment">// 打印查看结果</span>                ByteBufferUtil.debugAll(target);            &#125;        &#125;        <span class="hljs-comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span>        buffer.compact();    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java">+--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">12</span>], limit: [<span class="hljs-number">12</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">2</span>c <span class="hljs-number">77</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">0</span>a             |Hello,world.    |+--------+-------------------------------------------------+----------------++--------+-------------------- all ------------------------+----------------+position: [<span class="hljs-number">10</span>], limit: [<span class="hljs-number">10</span>]         +-------------------------------------------------+         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|<span class="hljs-number">00000000</span>| <span class="hljs-number">49</span> <span class="hljs-number">27</span> <span class="hljs-number">6</span>d <span class="hljs-number">20</span> <span class="hljs-number">4</span>e <span class="hljs-number">79</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">0</span>a                   |I<span class="hljs-string">'m Nyima.      |</span><span class="hljs-string">+--------+-------------------------------------------------+----------------+</span><span class="hljs-string">+--------+-------------------- all ------------------------+----------------+</span><span class="hljs-string">position: [13], limit: [13]</span><span class="hljs-string">         +-------------------------------------------------+</span><span class="hljs-string">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><span class="hljs-string">+--------+-------------------------------------------------+----------------+</span><span class="hljs-string">|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |</span><span class="hljs-string">+--------+-------------------------------------------------+----------------+</span></code></pre><h1 id="二、文件编程"><a href="#二、文件编程" class="headerlink" title="二、文件编程"></a>二、文件编程</h1><h2 id="1、FileChannel"><a href="#1、FileChannel" class="headerlink" title="1、FileChannel"></a>1、FileChannel</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p><p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> readBytes = channel.read(buffer);</code></pre><p><strong>可根据返回值判断是否读取完毕</strong></p><pre><code class="hljs java"><span class="hljs-keyword">while</span>(channel.read(buffer) &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 进行对应操作</span>    ...&#125;</code></pre><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中</span><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;channel.write(buffer);&#125;</code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"stu.txt"</span>);             FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"student.txt"</span>);             FileChannel inputChannel = fis.getChannel();             FileChannel outputChannel = fos.getChannel()) &#123;                        <span class="hljs-comment">// 执行对应操作</span>            ...                        &#125;    &#125;&#125;</code></pre><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><strong>position</strong></p><p>channel也拥有一个保存读取数据位置的属性，即position</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> pos = channel.position();</code></pre><p>可以通过position(int pos)设置channel中position的值</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> newPos = ...;channel.position(newPos);</code></pre><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1 </li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong>  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="2、两个Channel传输数据"><a href="#2、两个Channel传输数据" class="headerlink" title="2、两个Channel传输数据"></a>2、两个Channel传输数据</h2><h3 id="transferTo方法"><a href="#transferTo方法" class="headerlink" title="transferTo方法"></a>transferTo方法</h3><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><p>transferTo底层使用了零拷贝技术</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"stu.txt"</span>);             FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"student.txt"</span>);             FileChannel inputChannel = fis.getChannel();             FileChannel outputChannel = fos.getChannel()) &#123;            <span class="hljs-comment">// 参数：inputChannel的起始位置，传输数据的大小，目的channel</span>            <span class="hljs-comment">// 返回值为传输的数据的字节数</span>            <span class="hljs-comment">// transferTo一次只能传输2G的数据</span>            inputChannel.transferTo(<span class="hljs-number">0</span>, inputChannel.size(), outputChannel);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"stu.txt"</span>);             FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"student.txt"</span>);             FileChannel inputChannel = fis.getChannel();             FileChannel outputChannel = fos.getChannel()) &#123;            <span class="hljs-keyword">long</span> size = inputChannel.size();            <span class="hljs-keyword">long</span> capacity = inputChannel.size();            <span class="hljs-comment">// 分多次传输</span>            <span class="hljs-keyword">while</span> (capacity &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// transferTo返回值为传输了的字节数</span>                capacity -= inputChannel.transferTo(size-capacity, capacity, outputChannel);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="3、Path与Paths"><a href="#3、Path与Paths" class="headerlink" title="3、Path与Paths"></a>3、Path与Paths</h2><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><pre><code class="hljs java">Path source = Paths.get(<span class="hljs-string">"1.txt"</span>); <span class="hljs-comment">// 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txt</span>Path source = Paths.get(<span class="hljs-string">"d:\\1.txt"</span>); <span class="hljs-comment">// 绝对路径 代表了  d:\1.txt 反斜杠需要转义</span>Path source = Paths.get(<span class="hljs-string">"d:/1.txt"</span>); <span class="hljs-comment">// 绝对路径 同样代表了  d:\1.txt</span>Path projects = Paths.get(<span class="hljs-string">"d:\\data"</span>, <span class="hljs-string">"projects"</span>); <span class="hljs-comment">// 代表了  d:\data\projects</span></code></pre><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><pre><code class="hljs 1c">d:<span class="hljs-string">|- data</span><span class="hljs-string">|- projects</span><span class="hljs-string">|- a</span><span class="hljs-string">|- b</span></code></pre><p>代码</p><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">"d:\\data\\projects\\a\\..\\b"</span>);System.out.println(path);System.out.println(path.normalize()); <span class="hljs-comment">// 正常化路径 会去除 . 以及 ..</span></code></pre><p>输出结果为</p><pre><code class="hljs taggerscript">d:<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\p</span>rojects<span class="hljs-symbol">\a</span><span class="hljs-symbol">\.</span>.<span class="hljs-symbol">\b</span>d:<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\p</span>rojects<span class="hljs-symbol">\b</span></code></pre><h2 id="4、Files"><a href="#4、Files" class="headerlink" title="4、Files"></a>4、Files</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>检查文件是否存在</p><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">"helloword/data.txt"</span>);System.out.println(Files.exists(path));</code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建<strong>一级目录</strong></p><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">"helloword/d1"</span>);Files.createDirectory(path);</code></pre><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建<strong>多级目录用</strong></p><pre><code class="hljs java">Path path = Paths.get(<span class="hljs-string">"helloword/d1/d2"</span>);Files.createDirectories(path);</code></pre><h3 id="拷贝及移动"><a href="#拷贝及移动" class="headerlink" title="拷贝及移动"></a>拷贝及移动</h3><p><strong>拷贝文件</strong></p><pre><code class="hljs java">Path source = Paths.get(<span class="hljs-string">"helloword/data.txt"</span>);Path target = Paths.get(<span class="hljs-string">"helloword/target.txt"</span>);Files.copy(source, target);</code></pre><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 StandardCopyOption 来控制</p><pre><code class="hljs java">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre><p>移动文件</p><pre><code class="hljs java">Path source = Paths.get(<span class="hljs-string">"helloword/data.txt"</span>);Path target = Paths.get(<span class="hljs-string">"helloword/data.txt"</span>);Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</code></pre><ul><li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除文件</p><pre><code class="hljs java">Path target = Paths.get(<span class="hljs-string">"helloword/target.txt"</span>);Files.delete(target);</code></pre><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><pre><code class="hljs java">Path target = Paths.get(<span class="hljs-string">"helloword/d1"</span>);Files.delete(target);</code></pre><ul><li>如果<strong>目录还有内容</strong>，会抛异常 DirectoryNotEmptyException</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p><ul><li>Path：文件起始路径</li><li>FileVisitor：文件访问器，<strong>使用访问者模式</strong><ul><li>接口的实现类<strong>SimpleFileVisitor</strong>有四个方法<ul><li>preVisitDirectory：访问目录前的操作</li><li>visitFile：访问文件的操作</li><li>visitFileFailed：访问文件失败时的操作</li><li>postVisitDirectory：访问目录后的操作</li></ul></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWalkFileTree</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Path path = Paths.get(<span class="hljs-string">"F:\\JDK 8"</span>);        <span class="hljs-comment">// 文件目录数目</span>        AtomicInteger dirCount = <span class="hljs-keyword">new</span> AtomicInteger();        <span class="hljs-comment">// 文件数目</span>        AtomicInteger fileCount = <span class="hljs-keyword">new</span> AtomicInteger();        Files.walkFileTree(path, <span class="hljs-keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                System.out.println(<span class="hljs-string">"===&gt;"</span>+dir);                <span class="hljs-comment">// 增加文件目录数</span>                dirCount.incrementAndGet();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.preVisitDirectory(dir, attrs);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                System.out.println(file);                <span class="hljs-comment">// 增加文件数</span>                fileCount.incrementAndGet();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitFile(file, attrs);            &#125;        &#125;);        <span class="hljs-comment">// 打印数目</span>        System.out.println(<span class="hljs-string">"文件目录数:"</span>+dirCount.get());        System.out.println(<span class="hljs-string">"文件数:"</span>+fileCount.get());    &#125;&#125;</code></pre><p>运行结果如下</p><pre><code class="hljs crystal">...===&gt;<span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">security</span>\<span class="hljs-title">policy</span>\<span class="hljs-title">unlimited</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">security</span>\<span class="hljs-title">policy</span>\<span class="hljs-title">unlimited</span>\<span class="hljs-title">local_policy</span>.<span class="hljs-title">jar</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">security</span>\<span class="hljs-title">policy</span>\<span class="hljs-title">unlimited</span>\<span class="hljs-title">US_export_policy</span>.<span class="hljs-title">jar</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">security</span>\<span class="hljs-title">trusted</span>.<span class="hljs-title">libraries</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">sound</span>.<span class="hljs-title">properties</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">tzdb</span>.<span class="hljs-title">dat</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">tzmappings</span></span><span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\LICENSE<span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\README.txt<span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\release<span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\THIRDPARTYLICENSEREADME-JAVAFX.txt<span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\THIRDPARTYLICENSEREADME.txt<span class="hljs-symbol">F:</span>\JDK <span class="hljs-number">8</span>\Welcome.html文件目录数:<span class="hljs-number">23</span>文件数:<span class="hljs-number">279</span></code></pre><h1 id="三、网络编程"><a href="#三、网络编程" class="headerlink" title="三、网络编程"></a>三、网络编程</h1><h2 id="1、阻塞"><a href="#1、阻塞" class="headerlink" title="1、阻塞"></a>1、阻塞</h2><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p><strong>服务端代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建缓冲区</span>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);        <span class="hljs-comment">// 获得服务器通道</span>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;            <span class="hljs-comment">// 为服务器通道绑定端口</span>            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            <span class="hljs-comment">// 用户存放连接的集合</span>            ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">// 循环接收连接</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                System.out.println(<span class="hljs-string">"before connecting..."</span>);                <span class="hljs-comment">// 没有连接时，会阻塞线程</span>                SocketChannel socketChannel = server.accept();                System.out.println(<span class="hljs-string">"after connecting..."</span>);                channels.add(socketChannel);                <span class="hljs-comment">// 循环遍历集合中的连接</span>                <span class="hljs-keyword">for</span>(SocketChannel channel : channels) &#123;                    System.out.println(<span class="hljs-string">"before reading"</span>);                    <span class="hljs-comment">// 处理通道中的数据</span>                    <span class="hljs-comment">// 当通道中没有数据可读时，会阻塞线程</span>                    channel.read(buffer);                    buffer.flip();                    ByteBufferUtil.debugRead(buffer);                    buffer.clear();                    System.out.println(<span class="hljs-string">"after reading"</span>);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>客户端代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> (SocketChannel socketChannel = SocketChannel.open()) &#123;            <span class="hljs-comment">// 建立连接</span>            socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>));            System.out.println(<span class="hljs-string">"waiting..."</span>);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>运行结果</p><ul><li>客户端-服务器建立连接前：服务器端因accept阻塞</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png" srcset="/img/loading.gif" alt=""></p><ul><li>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png" srcset="/img/loading.gif" alt=""></p><ul><li>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png" srcset="/img/loading.gif" alt=""></p><ul><li>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、非阻塞"><a href="#2、非阻塞" class="headerlink" title="2、非阻塞"></a>2、非阻塞</h2><ul><li><p>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</p></li><li><p>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</p></li></ul><p>服务器代码如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建缓冲区</span>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);        <span class="hljs-comment">// 获得服务器通道</span>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;            <span class="hljs-comment">// 为服务器通道绑定端口</span>            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            <span class="hljs-comment">// 用户存放连接的集合</span>            ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">// 循环接收连接</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-comment">// 设置为非阻塞模式，没有连接时返回null，不会阻塞线程</span>                server.configureBlocking(<span class="hljs-keyword">false</span>);                SocketChannel socketChannel = server.accept();                <span class="hljs-comment">// 通道不为空时才将连接放入到集合中</span>                <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-keyword">null</span>) &#123;                    System.out.println(<span class="hljs-string">"after connecting..."</span>);                    channels.add(socketChannel);                &#125;                <span class="hljs-comment">// 循环遍历集合中的连接</span>                <span class="hljs-keyword">for</span>(SocketChannel channel : channels) &#123;                    <span class="hljs-comment">// 处理通道中的数据</span>                    <span class="hljs-comment">// 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程</span>                    channel.configureBlocking(<span class="hljs-keyword">false</span>);                    <span class="hljs-keyword">int</span> read = channel.read(buffer);                    <span class="hljs-keyword">if</span>(read &gt; <span class="hljs-number">0</span>) &#123;                        buffer.flip();                        ByteBufferUtil.debugRead(buffer);                        buffer.clear();                        System.out.println(<span class="hljs-string">"after reading"</span>);                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p><h2 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><h2 id="4、使用及Accpet事件"><a href="#4、使用及Accpet事件" class="headerlink" title="4、使用及Accpet事件"></a>4、使用及Accpet事件</h2><p>要使用Selector实现多路复用，服务端代码如下改进</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);        <span class="hljs-comment">// 获得服务器通道</span>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            <span class="hljs-comment">// 创建选择器</span>            Selector selector = Selector.open();                        <span class="hljs-comment">// 通道必须设置为非阻塞模式</span>            server.configureBlocking(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的事件</span>            server.register(selector, SelectionKey.OP_ACCEPT);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span>                <span class="hljs-comment">// 返回值为就绪的事件个数</span>                <span class="hljs-keyword">int</span> ready = selector.select();                System.out.println(<span class="hljs-string">"selector ready counts : "</span> + ready);                                <span class="hljs-comment">// 获取所有事件</span>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                                <span class="hljs-comment">// 使用迭代器遍历事件</span>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                                        <span class="hljs-comment">// 判断key的类型</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;                        <span class="hljs-comment">// 获得key对应的channel</span>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();                        System.out.println(<span class="hljs-string">"before accepting..."</span>);                                <span class="hljs-comment">// 获取连接并处理，而且是必须处理，否则需要取消</span>                        SocketChannel socketChannel = channel.accept();                        System.out.println(<span class="hljs-string">"after accepting..."</span>);                                                <span class="hljs-comment">// 处理完毕后移除</span>                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>步骤解析</strong></p><ul><li>获得选择器Selector</li></ul><pre><code class="hljs java">Selector selector = Selector.open();</code></pre><ul><li>将<strong>通道设置为非阻塞模式</strong>，并注册到选择器中，并设置感兴趣的事件<ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的<strong>事件类型</strong>可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul></li></ul><pre><code class="hljs axapta"><span class="hljs-comment">// 通道必须设置为非阻塞模式</span><span class="hljs-keyword">server</span>.configureBlocking(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的实践</span><span class="hljs-keyword">server</span>.register(selector, SelectionKey.OP_ACCEPT);</code></pre><ul><li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p><ul><li><p>阻塞直到绑定事件发生</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = selector.select();</code></pre></li><li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = selector.select(<span class="hljs-keyword">long</span> timeout);</code></pre></li><li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = selector.selectNow();</code></pre></li></ul></li><li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">// 获取所有事件</span>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                <span class="hljs-comment">// 使用迭代器遍历事件</span>Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;SelectionKey key = iterator.next();                    <span class="hljs-comment">// 判断key的类型，此处为Accept类型</span><span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;        <span class="hljs-comment">// 获得key对应的channel</span>        ServerSocketChannel channel = (ServerSocketChannel) key.channel();        <span class="hljs-comment">// 获取连接并处理，而且是必须处理，否则需要取消</span>        SocketChannel socketChannel = channel.accept();        <span class="hljs-comment">// 处理完毕后移除</span>        iterator.remove();&#125;&#125;</code></pre><p> <strong>事件发生后能否不处理</strong></p><p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p><h2 id="5、Read事件"><a href="#5、Read事件" class="headerlink" title="5、Read事件"></a>5、Read事件</h2><ul><li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li><li>添加Read事件，触发后进行读取操作</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);        <span class="hljs-comment">// 获得服务器通道</span>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            <span class="hljs-comment">// 创建选择器</span>            Selector selector = Selector.open();            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span>            server.configureBlocking(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的实践</span>            server.register(selector, SelectionKey.OP_ACCEPT);            <span class="hljs-comment">// 为serverKey设置感兴趣的事件</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span>                <span class="hljs-comment">// 返回值为就绪的事件个数</span>                <span class="hljs-keyword">int</span> ready = selector.select();                System.out.println(<span class="hljs-string">"selector ready counts : "</span> + ready);                <span class="hljs-comment">// 获取所有事件</span>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                <span class="hljs-comment">// 使用迭代器遍历事件</span>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    <span class="hljs-comment">// 判断key的类型</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;                        <span class="hljs-comment">// 获得key对应的channel</span>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();                        System.out.println(<span class="hljs-string">"before accepting..."</span>);                        <span class="hljs-comment">// 获取连接</span>                        SocketChannel socketChannel = channel.accept();                        System.out.println(<span class="hljs-string">"after accepting..."</span>);                        <span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中</span>                        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);                        socketChannel.register(selector, SelectionKey.OP_READ);                        <span class="hljs-comment">// 处理完毕后移除</span>                        iterator.remove();                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                        SocketChannel channel = (SocketChannel) key.channel();                        System.out.println(<span class="hljs-string">"before reading..."</span>);                        channel.read(buffer);                        System.out.println(<span class="hljs-string">"after reading..."</span>);                        buffer.flip();                        ByteBufferUtil.debugRead(buffer);                        buffer.clear();                        <span class="hljs-comment">// 处理完毕后移除</span>                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>删除事件</strong></p><p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p><p>以我们上面的 <strong>Read事件</strong> 的代码为例</p><ul><li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p><pre><code class="hljs java"><span class="hljs-comment">// WindowsSelectorImpl 中的 SelectionKeyImpl数组</span><span class="hljs-keyword">private</span> SelectionKeyImpl[] channelArray = <span class="hljs-keyword">new</span> SelectionKeyImpl[<span class="hljs-number">8</span>];</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionKeyImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSelectionKey</span> </span>&#123;    <span class="hljs-comment">// Key对应的通道</span>    <span class="hljs-keyword">final</span> SelChImpl channel;    ...&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png" srcset="/img/loading.gif" alt=""></p></li><li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="断开处理"><a href="#断开处理" class="headerlink" title="断开处理"></a>断开处理</h3><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>，对异常断开和正常断开需要加以不同的方式进行处理</p><ul><li><p><strong>正常断开</strong></p><ul><li><p>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong></p><pre><code class="hljs java"><span class="hljs-keyword">int</span> read = channel.read(buffer);<span class="hljs-comment">// 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1</span><span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 取消该事件的处理</span>key.cancel();    channel.close();&#125; <span class="hljs-keyword">else</span> &#123;    ...&#125;<span class="hljs-comment">// 取消或者处理，都需要移除key</span>iterator.remove();</code></pre></li></ul></li><li><p>异常断开</p><ul><li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li></ul></li></ul><h3 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h3><p><strong>不处理消息边界存在的问题</strong></p><p>将缓冲区的大小设置为4个字节，发送2个汉字（你好），通过decode解码并打印时，会出现乱码</p><pre><code class="hljs java">ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">4</span>);<span class="hljs-comment">// 解码并打印</span>System.out.println(StandardCharsets.UTF_8.decode(buffer));</code></pre><pre><code class="hljs plain">你���</code></pre><p>这是因为UTF-8字符集下，1个汉字占用3个字节，此时缓冲区大小为4个字节，<strong>一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件</strong>。这就导致 <code>你好</code> 的 <code>好</code> 字被拆分为了前半部分和后半部分发送，解码时就会出现问题</p><p><strong>处理消息边界</strong></p><p>传输的文本可能有以下三种情况</p><ul><li>文本大于缓冲区大小<ul><li>此时需要将缓冲区进行扩容</li></ul></li><li>发生半包现象</li><li>发生粘包现象</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png" srcset="/img/loading.gif" alt=""></p><p>解决思路大致有以下三种</p><ul><li><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</li><li>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</li><li><strong>TLV 格式，即 Type 类型、Length 长度、Value 数据</strong>（也就是在消息开头<strong>用一些空间存放后面数据的长度</strong>），如HTTP请求头中的Content-Type与<strong>Content-Length</strong>。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png" srcset="/img/loading.gif" alt=""></li></ul></li></ul><p>下文的消息边界处理方式为<strong>第二种：按分隔符拆分</strong></p><p><strong>附件与扩容</strong></p><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SelectionKey <span class="hljs-title">register</span><span class="hljs-params">(Selector sel, <span class="hljs-keyword">int</span> ops, Object att)</span></span></code></pre><p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p><pre><code class="hljs java">ByteBuffer buffer = (ByteBuffer) key.attachment();</code></pre><p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p><pre><code class="hljs java"><span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span>socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);<span class="hljs-comment">// 添加通道对应的Buffer附件</span>socketChannel.register(selector, SelectionKey.OP_READ, buffer);</code></pre><p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 如果缓冲区太小，就进行扩容</span><span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;    ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity()*<span class="hljs-number">2</span>);    <span class="hljs-comment">// 将旧buffer中的内容放入新的buffer中</span>    ewBuffer.put(buffer);    <span class="hljs-comment">// 将新buffer作为附件放到key中</span>    key.attach(newBuffer);&#125;</code></pre><p><strong>改造后的服务器代码如下</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获得服务器通道</span>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            <span class="hljs-comment">// 创建选择器</span>            Selector selector = Selector.open();            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span>            server.configureBlocking(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的事件</span>            server.register(selector, SelectionKey.OP_ACCEPT);            <span class="hljs-comment">// 为serverKey设置感兴趣的事件</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span>                <span class="hljs-comment">// 返回值为就绪的事件个数</span>                <span class="hljs-keyword">int</span> ready = selector.select();                System.out.println(<span class="hljs-string">"selector ready counts : "</span> + ready);                <span class="hljs-comment">// 获取所有事件</span>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                <span class="hljs-comment">// 使用迭代器遍历事件</span>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    <span class="hljs-comment">// 判断key的类型</span>                    <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;                        <span class="hljs-comment">// 获得key对应的channel</span>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();                        System.out.println(<span class="hljs-string">"before accepting..."</span>);                        <span class="hljs-comment">// 获取连接</span>                        SocketChannel socketChannel = channel.accept();                        System.out.println(<span class="hljs-string">"after accepting..."</span>);                        <span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span>                        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);                        socketChannel.register(selector, SelectionKey.OP_READ, buffer);                        <span class="hljs-comment">// 处理完毕后移除</span>                        iterator.remove();                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                        SocketChannel channel = (SocketChannel) key.channel();                        System.out.println(<span class="hljs-string">"before reading..."</span>);                        <span class="hljs-comment">// 通过key获得附件（buffer）</span>                        ByteBuffer buffer = (ByteBuffer) key.attachment();                        <span class="hljs-keyword">int</span> read = channel.read(buffer);                        <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;                            key.cancel();                            channel.close();                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-comment">// 通过分隔符来分隔buffer中的数据</span>                            split(buffer);                            <span class="hljs-comment">// 如果缓冲区太小，就进行扩容</span>                            <span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;                                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity()*<span class="hljs-number">2</span>);                                <span class="hljs-comment">// 将旧buffer中的内容放入新的buffer中</span>                                buffer.flip();                                newBuffer.put(buffer);                                <span class="hljs-comment">// 将新buffer放到key中作为附件</span>                                key.attach(newBuffer);                            &#125;                        &#125;                        System.out.println(<span class="hljs-string">"after reading..."</span>);                        <span class="hljs-comment">// 处理完毕后移除</span>                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;        buffer.flip();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.limit(); i++) &#123;            <span class="hljs-comment">// 遍历寻找分隔符</span>            <span class="hljs-comment">// get(i)不会移动position</span>            <span class="hljs-keyword">if</span> (buffer.get(i) == <span class="hljs-string">'\n'</span>) &#123;                <span class="hljs-comment">// 缓冲区长度</span>                <span class="hljs-keyword">int</span> length = i+<span class="hljs-number">1</span>-buffer.position();                ByteBuffer target = ByteBuffer.allocate(length);                <span class="hljs-comment">// 将前面的内容写入target缓冲区</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;                    <span class="hljs-comment">// 将buffer中的数据写入target中</span>                    target.put(buffer.get());                &#125;                <span class="hljs-comment">// 打印结果</span>                ByteBufferUtil.debugAll(target);            &#125;        &#125;        <span class="hljs-comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span>        buffer.compact();    &#125;&#125;</code></pre><h3 id="ByteBuffer的大小分配"><a href="#ByteBuffer的大小分配" class="headerlink" title="ByteBuffer的大小分配"></a>ByteBuffer的大小分配</h3><ul><li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li><li>分配思路可以参考<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul><li>参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li></ul></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h2 id="6、Write事件"><a href="#6、Write事件" class="headerlink" title="6、Write事件"></a>6、Write事件</h2><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入</strong>，具体步骤如下</p><ul><li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p></li><li><p>若Buffer中还有数据，则<strong>需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></p><pre><code class="hljs java"> <span class="hljs-keyword">int</span> write = socket.write(buffer);<span class="hljs-comment">// 通道中可能无法放入缓冲区中的所有数据</span><span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;    <span class="hljs-comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span>    socket.configureBlocking(<span class="hljs-keyword">false</span>);    socket.register(selector, SelectionKey.OP_WRITE, buffer);&#125;</code></pre></li><li><p>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作</p><ul><li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li></ul><pre><code class="hljs java">SocketChannel socket = (SocketChannel) key.channel();<span class="hljs-comment">// 获得buffer</span>ByteBuffer buffer = (ByteBuffer) key.attachment();<span class="hljs-comment">// 执行写操作</span><span class="hljs-keyword">int</span> write = socket.write(buffer);System.out.println(write);<span class="hljs-comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span><span class="hljs-keyword">if</span> (!buffer.hasRemaining()) &#123;    key.attach(<span class="hljs-keyword">null</span>);    key.interestOps(<span class="hljs-number">0</span>);&#125;</code></pre></li></ul><p><strong>整体代码如下</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            server.configureBlocking(<span class="hljs-keyword">false</span>);            Selector selector = Selector.open();            server.register(selector, SelectionKey.OP_ACCEPT);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                selector.select();                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    <span class="hljs-comment">// 处理后就移除事件</span>                    iterator.remove();                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                        <span class="hljs-comment">// 获得客户端的通道</span>                        SocketChannel socket = server.accept();                        <span class="hljs-comment">// 写入数据</span>                        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500000000</span>; i++) &#123;                            builder.append(<span class="hljs-string">"a"</span>);                        &#125;                        ByteBuffer buffer = StandardCharsets.UTF_8.encode(builder.toString());                        <span class="hljs-comment">// 先执行一次Buffer-&gt;Channel的写入，如果未写完，就添加一个可写事件</span>                        <span class="hljs-keyword">int</span> write = socket.write(buffer);                        System.out.println(write);                        <span class="hljs-comment">// 通道中可能无法放入缓冲区中的所有数据</span>                        <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;                            <span class="hljs-comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span>                            socket.configureBlocking(<span class="hljs-keyword">false</span>);                            socket.register(selector, SelectionKey.OP_WRITE, buffer);                        &#125;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;                        SocketChannel socket = (SocketChannel) key.channel();                        <span class="hljs-comment">// 获得buffer</span>                        ByteBuffer buffer = (ByteBuffer) key.attachment();                        <span class="hljs-comment">// 执行写操作</span>                        <span class="hljs-keyword">int</span> write = socket.write(buffer);                        System.out.println(write);                        <span class="hljs-comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span>                        <span class="hljs-keyword">if</span> (!buffer.hasRemaining()) &#123;                            key.attach(<span class="hljs-keyword">null</span>);                            key.interestOps(<span class="hljs-number">0</span>);                        &#125;                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="7、优化"><a href="#7、优化" class="headerlink" title="7、优化"></a>7、优化</h2><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>充分利用多核CPU，分两组选择器</p><ul><li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li><li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p></li><li><p><strong>Boss线程</strong>执行的操作</p><ul><li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 创建固定数量的Worker</span>Worker[] workers = <span class="hljs-keyword">new</span> Worker[<span class="hljs-number">4</span>];<span class="hljs-comment">// 用于负载均衡的原子整数</span>AtomicInteger robin = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<span class="hljs-comment">// 负载均衡，轮询分配Worker</span>workers[robin.getAndIncrement()% workers.length].register(socket);</code></pre></li><li><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketChannel socket)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 只启动一次</span>    <span class="hljs-keyword">if</span> (!started) &#123;       <span class="hljs-comment">// 初始化操作</span>    &#125;    <span class="hljs-comment">// 向同步队列中添加SocketChannel的注册事件</span>    <span class="hljs-comment">// 在Worker线程中执行注册事件</span>    queue.add(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                socket.register(selector, SelectionKey.OP_READ);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    <span class="hljs-comment">// 唤醒被阻塞的Selector</span>    <span class="hljs-comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span>    selector.wakeup();&#125;</code></pre></li></ul></li></ul><ul><li><p><strong>Worker线程执行</strong>的操作</p><ul><li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li></ul></li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadsServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> (ServerSocketChannel server = ServerSocketChannel.open()) &#123;            <span class="hljs-comment">// 当前线程为Boss线程</span>            Thread.currentThread().setName(<span class="hljs-string">"Boss"</span>);            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));            <span class="hljs-comment">// 负责轮询Accept事件的Selector</span>            Selector boss = Selector.open();            server.configureBlocking(<span class="hljs-keyword">false</span>);            server.register(boss, SelectionKey.OP_ACCEPT);            <span class="hljs-comment">// 创建固定数量的Worker</span>            Worker[] workers = <span class="hljs-keyword">new</span> Worker[<span class="hljs-number">4</span>];            <span class="hljs-comment">// 用于负载均衡的原子整数</span>            AtomicInteger robin = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; workers.length; i++) &#123;                workers[i] = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"worker-"</span>+i);            &#125;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                boss.select();                Set&lt;SelectionKey&gt; selectionKeys = boss.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    iterator.remove();                    <span class="hljs-comment">// BossSelector负责Accept事件</span>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                        <span class="hljs-comment">// 建立连接</span>                        SocketChannel socket = server.accept();                        System.out.println(<span class="hljs-string">"connected..."</span>);                        socket.configureBlocking(<span class="hljs-keyword">false</span>);                        <span class="hljs-comment">// socket注册到Worker的Selector中</span>                        System.out.println(<span class="hljs-string">"before read..."</span>);                        <span class="hljs-comment">// 负载均衡，轮询分配Worker</span>                        workers[robin.getAndIncrement()% workers.length].register(socket);                        System.out.println(<span class="hljs-string">"after read..."</span>);                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> Thread thread;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Selector selector;        <span class="hljs-keyword">private</span> String name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 同步队列，用于Boss线程与Worker线程之间的通信</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketChannel socket)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-comment">// 只启动一次</span>            <span class="hljs-keyword">if</span> (!started) &#123;                thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>, name);                selector = Selector.open();                queue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();                thread.start();                started = <span class="hljs-keyword">true</span>;            &#125;                        <span class="hljs-comment">// 向同步队列中添加SocketChannel的注册事件</span>            <span class="hljs-comment">// 在Worker线程中执行注册事件</span>            queue.add(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        socket.register(selector, SelectionKey.OP_READ);                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);            <span class="hljs-comment">// 唤醒被阻塞的Selector</span>            <span class="hljs-comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span>            selector.wakeup();        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    selector.select();                    <span class="hljs-comment">// 通过同步队列获得任务并运行</span>                    Runnable task = queue.poll();                    <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// 获得任务，执行注册操作</span>                        task.run();                    &#125;                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                    <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;                        SelectionKey key = iterator.next();                        iterator.remove();                        <span class="hljs-comment">// Worker只负责Read事件</span>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                            <span class="hljs-comment">// 简化处理，省略细节</span>                            SocketChannel socket = (SocketChannel) key.channel();                            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">16</span>);                            socket.read(buffer);                            buffer.flip();                            ByteBufferUtil.debugAll(buffer);                        &#125;                    &#125;                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="四、NIO与BIO"><a href="#四、NIO与BIO" class="headerlink" title="四、NIO与BIO"></a>四、NIO与BIO</h1><h2 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a>1、Stream与Channel</h2><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></li><li>二者<strong>均为全双工</strong>，即读写可以同时进行<ul><li>虽然Stream是单向流动的，但是它也是全双工的</li></ul></li></ul><h2 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h2><ul><li><strong>同步</strong>：线程自己去获取结果（一个线程）<ul><li>例如：线程调用一个方法后，需要等待方法返回结果</li></ul></li><li><strong>异步</strong>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）<ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li><p>等待数据阶段</p></li><li><p>复制数据阶段</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png" srcset="/img/loading.gif" alt=""></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png" srcset="/img/loading.gif" alt=""></p><ul><li>用户线程<strong>在一个循环中一直调用read方法</strong>，若内核空间中还没有数据可读，立即返回<ul><li><strong>只是在等待阶段非阻塞</strong></li></ul></li><li>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</li></ul><h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png" srcset="/img/loading.gif" alt=""></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件是，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png" srcset="/img/loading.gif" alt=""></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h2 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h3><p>传统的 IO 将一个文件通过 socket 写出</p><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"helloword/data.txt"</span>);RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">"r"</span>);<span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)f.length()];file.read(buf);Socket socket = ...;socket.getOutputStream().write(buf);</code></pre><p><strong>内部工作流如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p></li><li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h3><p>通过 <strong>DirectByteBuf</strong> </p><ul><li>ByteBuffer.allocate(10)  <ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li>ByteBuffer.<strong>allocateDirect</strong>(10)  <ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png" srcset="/img/loading.gif" alt=""></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存 </li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a>进一步优化1</h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo/transferFrom</strong> 方法拷贝数据</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</p></li><li><p>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</p></li><li><p>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</p></li><li><p>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</p></li><li><p>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h2 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a>4、AIO</h2><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到浏览器显示页面的流程</title>
    <link href="/2020/12/10/URL%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/12/10/URL%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="从输入URL到浏览器显示页面的流程"><a href="#从输入URL到浏览器显示页面的流程" class="headerlink" title="从输入URL到浏览器显示页面的流程"></a>从输入URL到浏览器显示页面的流程</h1><p>当在浏览器中输入域名，敲下回车后，不一会儿浏览器就会显示我们想要的界面。本文将简单介绍这其中经历了什么过程。</p><p>注意：以下分析基于<strong>HTTP</strong>请求，并且Web容器使用<strong>Tomcat</strong>，后端框架使用<strong>SSM</strong></p><h2 id="一、URL解析"><a href="#一、URL解析" class="headerlink" title="一、URL解析"></a>一、URL解析</h2><h3 id="1、地址解析"><a href="#1、地址解析" class="headerlink" title="1、地址解析"></a><strong>1、地址解析</strong></h3><p>浏览器会根据你的输入来判断该输入是一条合法的URL，还是需要被搜索的关键词。并且根据你输入的内容进行自动完成、字符编码等操作。</p><h3 id="2、其他操作"><a href="#2、其他操作" class="headerlink" title="2、其他操作"></a>2、其他操作</h3><p>目前大部分浏览器都会<strong>强制客户端使用HTTPS协议</strong>以保证信息传输的安全性。同时还会进行一些额外的操作，比如安全检查、访问限制等。</p><h3 id="3、缓存检查"><a href="#3、缓存检查" class="headerlink" title="3、缓存检查"></a>3、缓存检查</h3><p>有时候博客在gitee上进行了更新，但是通过谷歌浏览器查看博客时，仍是更新前的博客，这是因为浏览器中缓存了之前的博客界面。</p><p>浏览器会先检测是否缓存了目标URL的页面，如果有且缓存未过期，则直接展示缓存页面，无需再向服务器进行请求。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208150315.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、DNS解析"><a href="#二、DNS解析" class="headerlink" title="二、DNS解析"></a>二、DNS解析</h2><p><strong>DNS解析是寻找所需要的资源的IP地址的过程</strong>。因为互联网中每一台连网的机器都有<strong>唯一IP作为标识</strong>，但是它是一串数字，记忆太过困难。所以就需要将网址和IP地址进行转换，也就是DNS解析。其具体步骤如下。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209141644.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、查询缓存"><a href="#1、查询缓存" class="headerlink" title="1、查询缓存"></a>1、查询缓存</h3><p>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为<strong>DNS高速缓存</strong>。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询。</p><h3 id="2、递归解析"><a href="#2、递归解析" class="headerlink" title="2、递归解析"></a>2、递归解析</h3><p>输入<code>www.baidu.com</code>网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去<code>com</code>顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。</p><p>大致过程就是<code>.</code>-&gt; <code>.com</code> -&gt;<code>baidu.com.</code> -&gt; <code>www.baidu.com.</code></p><p>其中<code>.</code>代表根域名服务器。</p><h3 id="3、DNS负载均衡"><a href="#3、DNS负载均衡" class="headerlink" title="3、DNS负载均衡"></a>3、DNS负载均衡</h3><p>访问<code>baidu.com</code>的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以<strong>根据每台机器的负载量，该机器离用户地理位置的距离</strong>等等，这种过程就是DNS负载均衡。</p><h2 id="三、建立TCP连接"><a href="#三、建立TCP连接" class="headerlink" title="三、建立TCP连接"></a>三、建立TCP连接</h2><p>TCP/IP 分为四层，在发送数据时，<strong>每层都要对数据进行封装</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209141851.png" srcset="/img/loading.gif" alt=""></p><p>TCP提供一种<strong>面向连接的，可靠的字节流</strong>服务，是一种可靠传输。接下来将会讲解TCP的<strong>首部、三次握手与四次挥手</strong>。</p><h3 id="1、TCP的首部"><a href="#1、TCP的首部" class="headerlink" title="1、TCP的首部"></a>1、TCP的首部</h3><p>TCP首部的格式如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208164319.png" srcset="/img/loading.gif" alt=""></p><ul><li><p><strong>源端口</strong>：源端口和IP地址的作用是标识<strong>报文的发送地址和返回地址</strong></p></li><li><p><strong>目的端口</strong>：端口指明<strong>接收方</strong>计算机上的应用程序接口</p><ul><li>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP<strong>唯一确定</strong>一条TCP连接</li></ul></li><li><p><strong>序号</strong>：是TCP可靠传输的<strong>关键部分</strong></p><ul><li>序号是该报文段发送的数据组的<strong>第一个字节的序号</strong>。在TCP传送的流中，每<strong>一个字节都有一个序号</strong><ul><li>比如一个报文段的序号为300，报文段数据部分共有100字节，则<strong>下一个报文段</strong>的序号为400。所以序号确保了TCP传输的有序性</li></ul></li></ul></li><li><p><strong>确认号：ack，用于指明下一个期待收到的字节序号</strong>，表明该序号之前的所有数据已经正确无误的收到</p><ul><li><strong>确认号只有当ACK标志为1时才有效</strong>。比如建立连接时，SYN报文的ACK标志位为0</li></ul></li><li><p><strong>首部长度/数据偏移</strong>：占4位，它指出<strong>TCP报文的数据距离TCP报文段的起始处有多远</strong></p></li><li><p><strong>保留</strong>：占6位，保留今后使用，但<strong>目前应都位0</strong></p></li><li><p><strong>控制位：URG ACK PSH RST SYN FIN</strong>，共6个，每一个标志位表示一个控制功能</p><ul><li>URG：紧急。当URG=1时，表明紧急指针字段有效。告诉系统<strong>此报文段中有紧急数据</strong></li><li>ACK：确认。<strong>当ACK=1时，确认号字段才有效</strong>。TCP规定，在连接建立后所有报文的传输都必须把ACK置1</li><li>PSH：推送。当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1</li><li>RST：复位。当RST=1，表明TCP连接中出现严重差错，<strong>必须释放连接，然后再重新建立连接</strong></li><li>SYN：同步，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1</li><li>FIN：终止，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放</li></ul></li><li><p><strong>窗口</strong>：<strong>滑动窗口</strong>大小，用来告知发送端<strong>接受端的缓存大小</strong>，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bits字段，因而窗口大小最大为65535</p></li><li><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证</p></li><li><p><strong>紧急指针</strong>：只有当 <strong>URG 标志置 1 时紧急指针才有效</strong>。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</p></li><li><p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍</p></li><li><p><strong>数据部分</strong>： TCP 报文段中的数据部分是可选的。<strong>在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部</strong>。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p></li></ul><h3 id="2、三次握手"><a href="#2、三次握手" class="headerlink" title="2、三次握手"></a>2、三次握手</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210127161838.png" srcset="/img/loading.gif" alt=""></p><p><strong>握手过程中传送的包里不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>为什么是三次握手？两次不行吗？四次不行吗？</strong></p><h4 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="headerlink" title="为什么不是两次握手"></a>为什么不是两次握手</h4><p>这是为了<strong>避免服务器建立无用连接</strong>（客户端服务器建立连接后，却不传输数据）</p><p>如果只进行两次握手，如果客户端向服务器第一次发送的建立连接的请求因为某原因，<strong>兜兜转转绕了一大圈才到达服务器</strong>。这期间客户端因为未收到服务器的响应，就会再次发送连接请求，这时服务器收到了，向客户端发送连接请求后，连接便建立了。然后数据传输完毕后，释放连接。<strong>这时刚刚兜兜转转一大圈的建立连接的请求到了服务器</strong>，服务器收到后再次向客户端发送请求，发送后又建立了连接，但是建立连接后客户端没有再理会服务器，客户端与服务器之间没有传输数据，此时服务器的资源就会被浪费</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208172930.png" srcset="/img/loading.gif" alt=""></p><h4 id="为什么不是四次握手"><a href="#为什么不是四次握手" class="headerlink" title="为什么不是四次握手"></a>为什么不是四次握手</h4><p><strong>因为通信不可能100%可靠</strong>（红军蓝军约定）， 而上面的三次握手已经做好了通信的准备工作， <strong>再增加握手， 并不能显著提高可靠性</strong>，所以只需要三次握手就足够了</p><p>这里简单介绍一下<strong>红军蓝军约定</strong></p><blockquote><p>红军和蓝军都想消灭一波敌人，但是单凭他们一个军队的力量都不足以消灭这波敌人，因此他们想到了一起合作，于是红军向蓝军发了一封电报，内容是约定好早上8点一起向敌军进攻，由于他们不确定蓝军是否一定能收到电报, 所以只有收到蓝军的回复之后才会进行进攻，而蓝军也是同样的想法，因为他们不确定红军一定能收到自己的回复而在约定好的时间发动进攻，所以他们只有收到红军的回复后才发动进攻….</p><p>问怎样才能保证这次战役一定胜利呢？答案是不可能的，因为<strong>双方都对于自己发出的消息对方是否一定接收得到存在质疑</strong>，所以，这样的通信将一直进行下去，结果将是使胜利的几率一直接近100%，但是却永远达不到100%。</p></blockquote><h3 id="3、四次挥手"><a href="#3、四次挥手" class="headerlink" title="3、四次挥手"></a>3、四次挥手</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209144349.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>第一次挥手</strong><ul><li>客户端发送一个<strong>FIN=1</strong>，用来关闭客户端到服务器的数据传送，此后客户端不会再向服务器发送数据(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。 FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<strong>客户端进入FIN-WAIT-1</strong>（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</li></ul></li><li><strong>第二次挥手</strong><ul><li>服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，<strong>服务端就进入了CLOSE-WAIT</strong>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，<strong>但是服务器若发送数据，客户端依然要接受</strong>。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间</li><li>此时，<strong>客户端就进入FIN-WAIT-2</strong>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</li></ul></li><li><strong>第三次挥手</strong><ul><li>服务器发送一个FIN=1，用来关闭服务器到客户端的数据传送，也就是通知客户端，可以真正地释放连接了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，<strong>服务器就进入了LAST-ACK</strong>（最后确认）状态，等待客户端的确认</li></ul></li><li><strong>第四次挥手</strong><ul><li>客户端收到FIN后，发送一个ACK=1给服务器，确认序号为收到序号+1，此时，<strong>客户端就进入了TIME-WAIT</strong>（时间等待）状态。注意此时TCP连接还没有释放，<strong>必须经过2MSL（最长报文段寿命）的时间后</strong>，当客户端撤销相应的TCB后，才进入CLOSED状态</li><li><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些</li></ul></li></ul><h4 id="为什么客户端最后还要等待2MSL"><a href="#为什么客户端最后还要等待2MSL" class="headerlink" title="为什么客户端最后还要等待2MSL"></a>为什么客户端最后还要等待2MSL</h4><p><strong>确保第四次挥手服务器能够收到，同时使失效的连接请求从网络中消失</strong></p><p><strong>MSL</strong>是Maximum Segment Lifetime英文的缩写，中文可以译为<strong>报文最大生存时间</strong>，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><ul><li><p><strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，<strong>于是服务器又会重新发送一次</strong>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会<strong>重启2MSL计时器</strong></p></li><li><p>防止类似与三次握手中提到了的<strong>已经失效的连接请求报文段</strong>出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以<strong>使本连接持续的时间内所产生的所有报文段都从网络中消失</strong>（最长生存MSL）。<strong>这样新的连接中不会出现旧连接的请求报文</strong></p></li></ul><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手"></a>为什么建立连接是三次握手，关闭连接确是四次挥手</h4><ul><li><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，<strong>把ACK和SYN放在一个报文里发送给客户端</strong></p></li><li><p>关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，<strong>己方ACK和FIN一般都会分开发送，从而导致多了一次</strong></p></li></ul><h2 id="四、发送HTTPS请求"><a href="#四、发送HTTPS请求" class="headerlink" title="四、发送HTTPS请求"></a>四、发送HTTPS请求</h2><h3 id="1、HTTP简介"><a href="#1、HTTP简介" class="headerlink" title="1、HTTP简介"></a>1、HTTP简介</h3><p>参考<a href="https://mp.weixin.qq.com/s/AK1Pb9rx0q5Hf8dq6HNOhw" target="_blank" rel="noopener"><strong>你每天都在使用的HTTP协议，到底是什么鬼？</strong></a></p><h3 id="2、HTTPS简介"><a href="#2、HTTPS简介" class="headerlink" title="2、HTTPS简介"></a>2、HTTPS简介</h3><p>在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。</p><p>HTTPS详细介绍可以参考<a href="https://zhuanlan.zhihu.com/p/158593966" target="_blank" rel="noopener"><strong>一文带你了解HTTPS</strong></a></p><h4 id="HTTPS如何保证可靠性"><a href="#HTTPS如何保证可靠性" class="headerlink" title="HTTPS如何保证可靠性"></a>HTTPS如何保证可靠性</h4><ul><li>对称加密以及非对称加密<ul><li>通过非对称加密生成密钥，后面通过这个密钥进行对称加密进行传输</li></ul></li><li>数字签名<ul><li>保证非对称加密时发送的公钥是被认证过的，是安全可靠的</li></ul></li><li>单向Hash算法</li></ul><p><strong>大致过程如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209163352.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、HTTPS传输过程"><a href="#3、HTTPS传输过程" class="headerlink" title="3、HTTPS传输过程"></a>3、HTTPS传输过程</h3><ul><li><p><strong>建立TCP连接</strong>（HTTP）</p></li><li><p><strong>将HTTP请求转换为HTTPS请求，转到HTTPS网站</strong></p><ul><li>因为一般人输入网址时，都是输入如<code>www.baidu.com</code>，而不会输入<code>https://www.baidu.com</code>。这时默认使用的是HTTP协议，<strong>浏览器会帮我们自动转换为HTTPS协议</strong></li></ul></li><li><p><strong>建立新的TCP连接</strong>(HTTPS)</p><ul><li>因为HTTP与HTTPS的端口不同。HTTP使用80端口，HTTPS使用443端口</li></ul></li><li><p><strong>完成一系列的协商工作</strong></p><ul><li>完成加密套件的协商和证书的身份确认，这次交互客户端和服务端会协商出相同的密钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等等。浏览器获取到证书之后，也要验证证书的有效性，是否过期是否撤销</li></ul></li><li><p><strong>浏览器获取CA域名</strong></p><ul><li>如果没有CA域名的缓存，还需要进行<strong>DNS解析</strong></li></ul></li><li><p><strong>再次建立新的TCP连接</strong>（CA域名）</p></li><li><p><strong>发送OCSP请求</strong></p><ul><li>OCSP全称是Online Certificate Status Protocol，在线证书状态协议，顾名思义用来获取证书状态的请求，这里的状态包括有效、过期、未知。并且可以宽限一段客户端访问证书的时间</li></ul></li><li><p><strong>进行密钥协商</strong></p></li></ul><p>经过以上过程后，便可以进行数据的对称加密传输了。</p><h2 id="五、查询MAC地址"><a href="#五、查询MAC地址" class="headerlink" title="五、查询MAC地址"></a>五、查询MAC地址</h2><p>这一步主要负责为打包好的<code>数据+TCP首部+IP首部</code>寻找传输路线，<strong>找到IP对应的物理机</strong>，这里会用到ARP协议。</p><h3 id="1、ARP协议"><a href="#1、ARP协议" class="headerlink" title="1、ARP协议"></a>1、ARP协议</h3><p>ARP（Address Resolution Protocol）即地址解析协议， 用于<strong>实现从 IP 地址到 MAC 地址的映射</strong>，即询问目标IP对应的MAC地址。</p><h3 id="2、ARP如何交互"><a href="#2、ARP如何交互" class="headerlink" title="2、ARP如何交互"></a>2、ARP如何交互</h3><p>ARP协议通过<strong>一问一答</strong>实现交互，但是问和答都有讲究，<strong>问是通过广播形式实现，答是通过单播形式。</strong></p><hr><p><strong>以上都是计算机网络的部分，接下来将介绍服务器如何接收与处理请求</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209203752.png" srcset="/img/loading.gif" alt=""></p><h2 id="六、请求在Tomcat中的处理流程"><a href="#六、请求在Tomcat中的处理流程" class="headerlink" title="六、请求在Tomcat中的处理流程"></a>六、请求在Tomcat中的处理流程</h2><p>Web 容器以<strong>进程</strong>的方式在计算机上运行，<strong>它主要负责接收请求，并将其投送至特定的应用</strong>，但Web容器并不属于计算机网络的组成部分。接下来将以Tomcat为例介绍Web容器的核心组件。</p><h3 id="1、Tomcat的核心组件"><a href="#1、Tomcat的核心组件" class="headerlink" title="1、Tomcat的核心组件"></a>1、Tomcat的核心组件</h3><p>Tomcat的核心组件主要有：<strong>Server、Service、Connector、Engine、Host和Context</strong>。</p><p><strong>一个Server可以包含多个Service，一个Service可以包含多个Connector，但只能包含一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context</strong>。</p><p><strong>它们之间的关系如下图所示</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209200950.png" srcset="/img/loading.gif" alt=""></p><p><strong>配置文件的结构如下</strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Server</span>&gt;</span>                                  <span class="hljs-tag">&lt;<span class="hljs-name">Service</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Engine</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Host</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Host</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Context</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>Server 是整个配置文件的<strong>唯一根元素</strong>，代表整个 Tomcat 容器。Server 内部可以包含多个 Service，其主要职责就是管理多个 Service，对外提供给客户端访问，同时维护所有 Service 的生命周期，包括初始化服务、结束服务、定位客户端要访问的 Service 等等。</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 的主要职责就是将 Engine 与 Connector 装配在一起对外提供服务。一个 Service 可以包含多个 Connector，但只能包含一个 Engine，<strong>其中 Connector 负责从客户端接收请求，Engine 负责处理 Connector 接收进来的请求。</strong></p><h4 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h4><p><strong>Connector是主要负责接收请求的组件</strong>。</p><p><strong>Tomcat有以下两种工作模式</strong></p><ul><li><p>作为Web服务器，直接接收客户端的请求</p></li><li><p>作为Java Web服务器，接收前置Web服务器的请求</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209213925.png" srcset="/img/loading.gif" alt=""></p><p>每个 Service 可以有一个或多个 Connector，不同工作模式下，Tomcat 需要为各种类型的请求分别定义相应的 Connector，这样才能正确接收客户端对应协议的请求。定义 Connector 可以使用多种属性，某些属性只适用于某种特定的 Connector 类型。</p><p>一般说来，常见的 Connector 有 4 种类型</p><ul><li><strong>HTTP</strong></li><li><strong>HTTPS</strong></li><li><strong>AJP</strong></li><li><strong>Proxy</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210125922.png" srcset="/img/loading.gif" alt=""></p><p>Connector作为通信接口，<strong>它为其所属特定的 Service 接收外部客户端请求，以及回送应答至外部客户端</strong>。具体职责包括创建 Request、Response 对象用于跟外部客户端交换数据，并<strong>将 Request 交给配套的 Engine 来处理</strong>。</p><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>Engine 是 Service 组件中<strong>负责请求处理的组件</strong>，其内部可以包含多个 Host。Engine 从一个或多个 Connector 中接收请求并处理，并将处理结果封装成应答交给 Connector，最终回传给外部客户端。</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p><strong>Host 代表一个虚拟主机，它对应计算机网络上的一个实体</strong>。即某个在 DNS 服务器上注册过的域名或者 IP 地址，例如：<code>www.baidu.com</code>或 201.187.10.21。Host 内部可以包含多个 Context，<strong>每个 Context 表示一个 Web 应用</strong>。Host 负责安装、展开、启动和结束每个 Web 应用。</p><p>客户端在填写目标地址时会通过主机名来标识它希望访问的服务器，Tomcat 将从 HTTP 请求头的 Host 字段提取主机名，然后再匹配对应的虚拟主机。如果没有找到匹配的，HTTP 请求将被发送至默认主机 defaultHost。</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context 代表在特定虚拟主机上运行的一个 Web 应用，<strong>负责处理某个特定 Web 应用的所有请求</strong>。</p><h3 id="2、Tomcat处理HTTP请求"><a href="#2、Tomcat处理HTTP请求" class="headerlink" title="2、Tomcat处理HTTP请求"></a>2、Tomcat处理HTTP请求</h3><p>当以 HTTP 请求到达Tomcat服务器（Server）以后，Tomcat会进行以下几个步骤，将请求交给对应的Web应用进行处理</p><ul><li><strong>根据协议类型和端口号选定 Service 和 Engine</strong><ul><li>Connector 主要负责接收请求。当 Connector 接收到特定协议和特定端口的请求后，<strong>其所属的 Service 和 Service 下的 Engine 也就确定了</strong></li></ul></li><li><strong>根据域名或 IP 地址选定 Host</strong><ul><li>Engine一旦确定了，就会根据 IP 来选择对应的虚拟主机Host来处理请求。如果匹配失败了，则会使用默认虚拟主机来处理请求</li></ul></li><li><strong>根据 URI 选定 Context</strong><ul><li>URI 中的 context-path 指定了 HTTPS 请求将要访问的 Web 应用</li><li>当请求抵达时，Tomcat 将根据 Context 的属性 path 取值与 URI 中的 context-path 的匹配程度来选择 Web 应用处理相应请求</li></ul></li></ul><h2 id="七、请求在Web应用中的处理流程"><a href="#七、请求在Web应用中的处理流程" class="headerlink" title="七、请求在Web应用中的处理流程"></a>七、请求在Web应用中的处理流程</h2><p>请求被 Web 容器中的 Connector 捕获，选取对应的 Server 中的 Engine ，Engine 再根据IP选择对应的虚拟主机，虚拟主机根据URI将请求交给对应的Web应用进行处理。接下来将介绍请求在Web请求中的处理过程。</p><p>介绍处理过程前，先对Web应用的基本组件进行简单介绍。</p><h3 id="1、Web应用核心组件"><a href="#1、Web应用核心组件" class="headerlink" title="1、Web应用核心组件"></a>1、Web应用核心组件</h3><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>监听器 Listener 主要用于监听 Application、Session、Request 等对象的变化，每当这些对象发生变化就会回调用对应的监听方法。</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>过滤器 Filter 负责对请求做<strong>预处理</strong>，接着将请求交给 Servlet 进行处理并生成响应，最后 Filter 再对响应进行后处理。</p><p>从请求的处理过程来看，Filter 主要参与以下几个环节</p><ul><li><p>在 HttpServletRequest <strong>到达 Servlet 之前，拦截客户的 HttpServletRequest</strong></p></li><li><p>根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 报文头和数据</p></li><li><p>在 Servlet 生成的 HttpServletResponse <strong>抵达客户端之前，拦截 HttpServletResponse</strong></p></li><li><p>根据需要检查 HttpServletResponse，也可以修改 HttpServletResponse 报文头和数据</p></li></ul><p><strong>简单来说就是在真正处理请求以及返回响应之前，通过过滤器对内容再进行一些修改</strong></p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p><strong>Servlet 负责处理客户端访问动态资源的 HTTP 请求</strong>，接口 javax.servlet.Servlet 定义了所有 Servlet 必须要实现的方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Servlet</span> </span>&#123;    <span class="hljs-comment">// 由 Servlet 容器调用，完成 Servlet 初始化，启动对外服务</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig var1)</span> <span class="hljs-keyword">throws</span> ServletException</span>;    <span class="hljs-comment">// 获取 Servlet 初始化和启动时参数的配置信息对象 ServletConfig</span>    <span class="hljs-function">ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 由 Servlet 容器调用，让 Servlet 处理某个 HTTP 请求</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span>;    <span class="hljs-comment">// 获取 Servlet 的说明信息，包括：作者、版本和版权等等</span>    <span class="hljs-function">String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 由 Servlet 容器调用，用于关闭停止 Servlet 提供的服务</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>从 HTTP 请求的处理过程来看，Servlet 主要参与以下几个环节</p><ul><li><strong>接收请求</strong><ul><li>客户端请求会被封装成 HttpServletRequest 对象，包含报文头参数和报文体等信息</li></ul></li><li><strong>处理请求</strong><ul><li>通常调用 Servlet 的方法 service、doPost 或 doGet 等方法处理请求，并<strong>进一步调用业务层相应逻辑对其进行处理等</strong></li></ul></li><li><strong>反回响应</strong><ul><li>处理完请求后，可以转发（forward）、重定向（redirect）到某个视图页面或者直接返回结果数据</li></ul></li></ul><h3 id="2、Web应用处理HTTP请求流程"><a href="#2、Web应用处理HTTP请求流程" class="headerlink" title="2、Web应用处理HTTP请求流程"></a>2、Web应用处理HTTP请求流程</h3><p>Web 应用处理 HTTP 请求的流程主要是<strong>穿越 Listener 和多个 Filters，最终抵达 Servlet 的过程</strong>，Servlet再进行下一步的处理。</p><p><strong>具体流程如下图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209213603.png" srcset="/img/loading.gif" alt=""></p><h2 id="八、请求在Spring-Web应用中的处理流程"><a href="#八、请求在Spring-Web应用中的处理流程" class="headerlink" title="八、请求在Spring Web应用中的处理流程"></a>八、请求在Spring Web应用中的处理流程</h2><p>因为使用 SSM 框架，所以 Spring MVC 中的 DispatcherServlet 充当了 Web 应用中的 Serlvet，负责将任务分配给对应的Controller，并将最终视图返回给 Web 容器。</p><h3 id="1、Spring-MVC的核心组件"><a href="#1、Spring-MVC的核心组件" class="headerlink" title="1、Spring MVC的核心组件"></a>1、Spring MVC的核心组件</h3><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>DispatcherServlet 是整个流程<strong>控制的中心</strong>，由它来<strong>接收请求并调用其它组件处理用户的请求</strong>，同时还负责响应结果。DispatcherServlet的存在降低了组件之间的耦合性。</p><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>HandlerMapping 负责<strong>根据用户请求映射获得对应的 Handler和 HandlerInterceptor</strong>。处理方法为从 URL 获得 URI，在通过 URI 从 HandlerMapping 中找到对应的 Handler 和 HandlerInterceptor，即处理器和拦截器。</p><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>HandlerAdapter 负责按照特定规则去执行 Handler。</p><p>如果 Handler 有对应的 HandlerAdapater，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong>。</p><h4 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h4><p>HandlerInterceptor 主要负责在执行 Handler 前对其进行拦截。HandlerInterceptor 中的 preHandler() 方法将会提取 HTTP 请求中的数据填充到处理器 Handler 的中。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>Handler <strong>即Controller ，是处理业务代码的核心器件</strong>。这部分由程序员自行编写，一般的SSM框架中，其下层还有Service和Dao。</p><h3 id="2、Spring-MVC处理请求流程"><a href="#2、Spring-MVC处理请求流程" class="headerlink" title="2、Spring MVC处理请求流程"></a>2、Spring MVC处理请求流程</h3><p>当 Web 容器中的 Host 会选择对应的 Web应用来处理请求，这里将请求交给了 Spring MVC 中的 DispatcherServlet 来进一步处理请求。</p><ul><li><p>DispatcherServlet 通过解析 HTTP 请求的 URL 获得 URI，再根据该 URI <strong>从 HandlerMapping 当中获得该请求对应的 Handler 和 HandlerInterceptor</strong></p></li><li><p>DispatcherServlet 根据获得的 Handler 选择合适的 HandlerAdapter。如果成功获得 HandlerAdapter，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong></p></li><li><p>Handler 即 Controller 会进行请求的处理，并向下调用 Service 和 Dao 来处理请求</p></li><li><p>Hander 处理完成请求后会返回模型数据，模型数据由 DispatcherServlet 封装后返回给Web 容器</p></li></ul><p><strong>处理的流程图如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210105723.png" srcset="/img/loading.gif" alt=""></p><h2 id="九、返回过程"><a href="#九、返回过程" class="headerlink" title="九、返回过程"></a>九、返回过程</h2><p>Web 应用处理完请求并将结果返回给 Web 容器后，容器会将响应结果返回给客户端，这是上面流程的逆过程。浏览器收到响应结果后，会对结果进行解析和渲染。这样我们就能看到浏览器给我们显示的网页了。</p><h2 id="十、整体流程图"><a href="#十、整体流程图" class="headerlink" title="十、整体流程图"></a>十、整体流程图</h2><p>下面给出了输入URL到浏览器显示界面的流程图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210113745.png" srcset="/img/loading.gif" alt=""></p><p><strong>以上便是从输入URL到浏览器显示页面的整个流程</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p><a href="https://mp.weixin.qq.com/s/AK1Pb9rx0q5Hf8dq6HNOhw" target="_blank" rel="noopener">你每天都在使用的HTTP协议，到底是什么鬼？</a></p><p><a href="https://segmentfault.com/a/1190000021137583" target="_blank" rel="noopener">图解 Spring：HTTP 请求的处理流程与机制</a></p><p><a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p><p><a href="https://juejin.cn/post/6844903832435032072" target="_blank" rel="noopener">史上最详细的经典面试题 从输入URL到看到页面发生了什么？</a></p>]]></content>
    
    
    <categories>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO</title>
    <link href="/2020/11/30/Java%20NIO/"/>
    <url>/2020/11/30/Java%20NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p><h2 id="二、IO与NIO的区别"><a href="#二、IO与NIO的区别" class="headerlink" title="二、IO与NIO的区别"></a>二、IO与NIO的区别</h2><table><thead><tr><th align="center">IO</th><th align="center">NIO</th></tr></thead><tbody><tr><td align="center">面向流(Stream Oriented)</td><td align="center">面向缓冲区(Buffer Oriented)</td></tr><tr><td align="center">阻塞IO(Blocking IO)</td><td align="center">非阻塞IO(NonBlocking IO)</td></tr><tr><td align="center"></td><td align="center">选择器(Selectors)</td></tr></tbody></table><h3 id="1、面向流和缓冲区"><a href="#1、面向流和缓冲区" class="headerlink" title="1、面向流和缓冲区"></a>1、面向流和缓冲区</h3><p><strong>IO</strong></p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png" srcset="/img/loading.gif" alt=""></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109085054.png" srcset="/img/loading.gif" alt=""></p><h2 id="三、通道与缓冲区"><a href="#三、通道与缓冲区" class="headerlink" title="三、通道与缓冲区"></a>三、通道与缓冲区</h2><p>Java NIO系统的核心在于：<strong>通道(Channel)和缓冲区(Buffer)</strong>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><h2 id="四、缓冲区-Buffer"><a href="#四、缓冲区-Buffer" class="headerlink" title="四、缓冲区(Buffer)"></a>四、缓冲区(Buffer)</h2><h3 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h3><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffers</span></code></pre><p>IntBuffer</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffers</span></code></pre><p><strong>他们的继承关系如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109091555.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h3><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><pre><code class="hljs java"><span class="hljs-comment">// 获取一个容量大小为1024字节的字节缓冲区</span>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);</code></pre><h3 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h3><p>缓冲区的父类Buffer中有几个核心属性，如下</p><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;</code></pre><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li><p>put()方法可以将一个数据放入到缓冲区中。</p></li><li><p>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" srcset="/img/loading.gif" alt=""></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" srcset="/img/loading.gif" alt=""></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" srcset="/img/loading.gif" alt=""></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li><p>该方法<strong>只能在读模式下使用</strong></p></li><li><p>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" srcset="/img/loading.gif" alt=""></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" srcset="/img/loading.gif" alt=""></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li><p>mark()方法会将postion的值保存到mark属性中</p></li><li><p>reset()方法会将position的值改为mark中保存的值</p></li></ul><h4 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);System.out.println(<span class="hljs-string">"放入前参数"</span>);System.out.println(<span class="hljs-string">"position "</span> + byteBuffer.position());System.out.println(<span class="hljs-string">"limit "</span> + byteBuffer.limit());System.out.println(<span class="hljs-string">"capacity "</span> + byteBuffer.capacity());System.out.println();System.out.println(<span class="hljs-string">"------put()------"</span>);System.out.println(<span class="hljs-string">"放入3个数据"</span>);<span class="hljs-keyword">byte</span> bt = <span class="hljs-number">1</span>;byteBuffer.put(bt);byteBuffer.put(bt);byteBuffer.put(bt);System.out.println(<span class="hljs-string">"放入后参数"</span>);System.out.println(<span class="hljs-string">"position "</span> + byteBuffer.position());System.out.println(<span class="hljs-string">"limit "</span> + byteBuffer.limit());System.out.println(<span class="hljs-string">"capacity "</span> + byteBuffer.capacity());System.out.println();System.out.println(<span class="hljs-string">"------flip()-get()------"</span>);System.out.println(<span class="hljs-string">"读取一个数据"</span>);<span class="hljs-comment">// 切换模式</span>byteBuffer.flip();byteBuffer.get();System.out.println(<span class="hljs-string">"读取后参数"</span>);System.out.println(<span class="hljs-string">"position "</span> + byteBuffer.position());System.out.println(<span class="hljs-string">"limit "</span> + byteBuffer.limit());System.out.println(<span class="hljs-string">"capacity "</span> + byteBuffer.capacity());System.out.println();System.out.println(<span class="hljs-string">"------rewind()------"</span>);byteBuffer.rewind();System.out.println(<span class="hljs-string">"恢复后参数"</span>);System.out.println(<span class="hljs-string">"position "</span> + byteBuffer.position());System.out.println(<span class="hljs-string">"limit "</span> + byteBuffer.limit());System.out.println(<span class="hljs-string">"capacity "</span> + byteBuffer.capacity());System.out.println();System.out.println(<span class="hljs-string">"------clear()------"</span>);<span class="hljs-comment">// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在</span><span class="hljs-comment">// 但是下次写入的时候会覆盖缓冲区中之前的数据</span>byteBuffer.clear();System.out.println(<span class="hljs-string">"清空后参数"</span>);System.out.println(<span class="hljs-string">"position "</span> + byteBuffer.position());System.out.println(<span class="hljs-string">"limit "</span> + byteBuffer.limit());System.out.println(<span class="hljs-string">"capacity "</span> + byteBuffer.capacity());System.out.println();System.out.println(<span class="hljs-string">"清空后获得数据"</span>);System.out.println(byteBuffer.get());&#125;&#125;</code></pre><p>打印结果</p><pre><code class="hljs angelscript">放入前参数position <span class="hljs-number">0</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>------put()------放入<span class="hljs-number">3</span>个数据放入后参数position <span class="hljs-number">3</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>------flip()-<span class="hljs-keyword">get</span>()------读取一个数据读取后参数position <span class="hljs-number">1</span>limit <span class="hljs-number">3</span>capacity <span class="hljs-number">1024</span>------rewind()------恢复后参数position <span class="hljs-number">0</span>limit <span class="hljs-number">3</span>capacity <span class="hljs-number">1024</span>------clear()------清空后参数position <span class="hljs-number">0</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>清空后获得数据<span class="hljs-number">1</span></code></pre><h3 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h3><h4 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h4><p>通过<strong>allocate()</strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM<strong>堆内存</strong>之中的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-comment">// 在堆内存中开辟空间</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapByteBuffer(capacity, capacity);&#125;HeapByteBuffer(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> lim) &#123;        <span class="hljs-comment">// package-private</span>    <span class="hljs-comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, lim, cap, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[cap], <span class="hljs-number">0</span>);    <span class="hljs-comment">/*</span><span class="hljs-comment">    hb = new byte[cap];</span><span class="hljs-comment">    offset = 0;</span><span class="hljs-comment">    */</span>&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151057.png" srcset="/img/loading.gif" alt=""></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低</p><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;                   <span class="hljs-comment">// package-private</span>...    <span class="hljs-comment">// 申请物理内存</span><span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();...&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151520.png" srcset="/img/loading.gif" alt=""></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h2 id="五、通道-Channel"><a href="#五、通道-Channel" class="headerlink" title="五、通道(Channel)"></a>五、通道(Channel)</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong></p><h3 id="2、图解"><a href="#2、图解" class="headerlink" title="2、图解"></a>2、图解</h3><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153039.png" srcset="/img/loading.gif" alt=""></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153439.png" srcset="/img/loading.gif" alt=""></p><p>于是便有了<strong>Channel(通道)</strong>，Channel相当于一个<strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154113.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、Java-Channel"><a href="#3、Java-Channel" class="headerlink" title="3、Java Channel"></a>3、Java Channel</h3><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154803.png" srcset="/img/loading.gif" alt=""></p><ul><li>本地文件IO<ul><li>FileChannel</li></ul></li><li>网络IO<ul><li>SocketChanel、ServerSocketChannel：用于TCP传输</li><li>DatagramChannel：用于UDP传输</li></ul></li></ul><h4 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h4><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 本地通道</span>      FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">""</span>);      FileChannel channel1 = fileInputStream.getChannel();      FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">""</span>);      FileChannel channel2 = fileOutputStream.getChannel();         <span class="hljs-comment">// 网络通道</span>      Socket socket = <span class="hljs-keyword">new</span> Socket();      SocketChannel channel3 = socket.getChannel();            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();      ServerSocketChannel channel4 = serverSocket.getChannel();      DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket();      DatagramChannel channel5 = datagramSocket.getChannel();             <span class="hljs-comment">// 最后要关闭通道</span>          &#125;&#125;</code></pre><p><strong>也可以通过通道的静态方法open()来获取</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   FileChannel open = FileChannel.open(Paths.get(<span class="hljs-string">""</span>));      SocketChannel open1 = SocketChannel.open();      ...&#125;</code></pre><h4 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h4><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      FileInputStream is = <span class="hljs-keyword">null</span>;      FileOutputStream os = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 获得通道</span>      FileChannel inChannel = <span class="hljs-keyword">null</span>;      FileChannel outChannel = <span class="hljs-keyword">null</span>;             <span class="hljs-comment">// 利用 try-catch-finally 保证关闭</span>      <span class="hljs-keyword">try</span> &#123;         is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg"</span>);         os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg"</span>);         <span class="hljs-comment">// 获得通道</span>         inChannel = is.getChannel();         outChannel = os.getChannel();         <span class="hljs-comment">// 获得缓冲区，用于在通道中传输数据</span>         ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);         <span class="hljs-comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span>         <span class="hljs-keyword">while</span> (inChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 切换模式</span>            byteBuffer.flip();            outChannel.write(byteBuffer);            byteBuffer.clear();         &#125;      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;         e.printStackTrace();      &#125; <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-keyword">if</span> (inChannel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               inChannel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (outChannel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               outChannel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               is.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (os != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               os.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;      &#125;   &#125;&#125;</code></pre><p><strong>图片读取后，被写入到了指定位置</strong><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109211055.png" srcset="/img/loading.gif" alt=""></p><h4 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h4><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 通过open()方法来获得通道</span>      FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg"</span>), StandardOpenOption.READ);      <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span>      <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span>      <span class="hljs-comment">// CREATE是因为要创建新的文件</span>      FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg"</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);      <span class="hljs-comment">// 获得直接缓冲区</span>      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());      <span class="hljs-comment">// 字节数组</span>      <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inMapBuf.limit()];      <span class="hljs-comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span>      inMapBuf.get(bytes);      outMapBuf.put(bytes);      <span class="hljs-comment">// 关闭缓冲区，这里没有用try-catch-finally</span>      inChannel.close();      outChannel.close();   &#125;&#125;</code></pre><p><strong>运行结果，图片被创建</strong><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109214801.png" srcset="/img/loading.gif" alt=""></p><h4 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelToChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">long</span> start = System.currentTimeMillis();   <span class="hljs-comment">// 通过open()方法来获得通道</span>   FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4"</span>), StandardOpenOption.READ);   <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span>   <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span>   <span class="hljs-comment">// CREATE是因为要创建新的文件</span>   FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4"</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);   <span class="hljs-comment">// 通道间直接传输</span>   inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);   <span class="hljs-comment">// 对应的还有transferFrom</span>   <span class="hljs-comment">// outChannel.transferFrom(inChannel, 0, inChannel.size());</span>   inChannel.close();   outChannel.close();&#125;</code></pre><h4 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h4><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><pre><code class="hljs java"><span class="hljs-comment">// getChannel() + 非直接缓冲区耗时</span><span class="hljs-number">708</span><span class="hljs-comment">// open() + 直接缓冲区耗时</span><span class="hljs-number">115</span><span class="hljs-comment">// channel transferTo channel耗时</span><span class="hljs-number">47</span></code></pre><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h3 id="4、分散和聚集"><a href="#4、分散和聚集" class="headerlink" title="4、分散和聚集"></a>4、分散和聚集</h3><h4 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h4><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082427.png" srcset="/img/loading.gif" alt=""></p><h4 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h4><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt"</span>);      FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt"</span>);      FileChannel inChannel = is.getChannel();      FileChannel outChannel = os.getChannel();      <span class="hljs-comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span>      ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="hljs-number">50</span>);      ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;      <span class="hljs-comment">// 分散读取</span>      inChannel.read(byteBuffers);            byteBuffer1.flip();      byteBuffer2.flip();            <span class="hljs-comment">// 聚集写入</span>      outChannel.write(byteBuffers);   &#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083219.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083230.png" srcset="/img/loading.gif" alt=""></p><h2 id="六、非阻塞式网络通信"><a href="#六、非阻塞式网络通信" class="headerlink" title="六、非阻塞式网络通信"></a>六、非阻塞式网络通信</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>双11买的快递到了，快递小哥给你打电话说马上到小区门口，麻烦在门口等一下，方便签收快递</p><ul><li><p>若为<strong>阻塞式</strong>的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了</p></li><li><p>若为<strong>非阻塞式</strong>的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿</p></li></ul><h4 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h4><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111090126.png" srcset="/img/loading.gif" alt=""></p><h4 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h4><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112165417.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="阻塞式网络通信演示"><a href="#阻塞式网络通信演示" class="headerlink" title="阻塞式网络通信演示"></a>阻塞式网络通信演示</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-keyword">try</span> &#123;            server();         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-keyword">try</span> &#123;            client();         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      thread1.start();      thread2.start();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 创建客户端通道</span>      SocketChannel socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">2022</span>));      <span class="hljs-comment">// 读取信息</span>      FileChannel fileChannel = FileChannel.open(Paths.get(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\nio\\day3\\1.jpg"</span>), StandardOpenOption.READ);      <span class="hljs-comment">// 创建缓冲区</span>      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      <span class="hljs-comment">// 写入数据</span>      <span class="hljs-keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;         byteBuffer.flip();         socketChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      fileChannel.close();      socketChannel.close();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 创建服务端通道</span>      ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();      FileChannel fileChannel = FileChannel.open(Paths.get(<span class="hljs-string">"F:\\JDKLearning\\src\\main\\nio\\day3\\2.jpg"</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);      <span class="hljs-comment">// 绑定链接</span>      serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">2022</span>));      <span class="hljs-comment">// 获取客户端的通道</span>      SocketChannel socketChannel = serverSocketChannel.accept();      <span class="hljs-comment">// 创建缓冲区</span>      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      <span class="hljs-keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;         byteBuffer.flip();         fileChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      socketChannel.close();      fileChannel.close();      serverSocketChannel.close();   &#125;&#125;</code></pre><h4 id="非阻塞式网络通信演示"><a href="#非阻塞式网络通信演示" class="headerlink" title="非阻塞式网络通信演示"></a>非阻塞式网络通信演示</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoNIO</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">try</span> &#123;server();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;&#125;);Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">try</span> &#123;client();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;&#125;);thread1.start();thread2.start();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;SocketChannel socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">2020</span>));<span class="hljs-comment">// 设置为非阻塞模式</span>socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;String str = scanner.next();byteBuffer.put(str.getBytes());byteBuffer.flip();socketChannel.write(byteBuffer);byteBuffer.clear();&#125;byteBuffer.clear();socketChannel.close();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">2020</span>));<span class="hljs-comment">// 获得选择器</span>Selector selector = Selector.open();<span class="hljs-comment">// 将通道注册到选择器中，设定为接收操作</span>serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="hljs-comment">// 轮训接受</span><span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<span class="hljs-comment">// 获得事件的key</span><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;SelectionKey key = iterator.next();<span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;SocketChannel socketChannel = serverSocketChannel.accept();socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);socketChannel.register(selector, SelectionKey.OP_READ);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<span class="hljs-comment">// 从选择器中获取通道</span>SocketChannel socketChannel = (SocketChannel) key.channel();ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);<span class="hljs-keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> len = byteBuffer.limit();byteBuffer.flip();System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array(), <span class="hljs-number">0</span>, len));byteBuffer.clear();&#125;socketChannel.close();&#125;iterator.remove();&#125;&#125;serverSocketChannel.close();&#125;&#125;</code></pre><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112163633.png" srcset="/img/loading.gif" alt=""></p><p><strong>选择器的创建</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 创建一个选择器</span>Selector selector = Selector.open();</code></pre><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112164022.png" srcset="/img/loading.gif" alt=""></p></li></ul><pre><code class="hljs java"><span class="hljs-comment">// 让选择器监听一种状态</span>myChannel.register(selector, SelectionKey.OP_READ);<span class="hljs-comment">// 让选择器监听多种状态</span>myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);</code></pre><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作g</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis设计与实现</title>
    <link href="/2020/11/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/11/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis设计与实现"><a href="#Redis设计与实现" class="headerlink" title="Redis设计与实现"></a>Redis设计与实现</h1><h1 id="Redis中的数据结构"><a href="#Redis中的数据结构" class="headerlink" title="Redis中的数据结构"></a>Redis中的数据结构</h1><h2 id="一、简单动态字符串"><a href="#一、简单动态字符串" class="headerlink" title="一、简单动态字符串"></a>一、简单动态字符串</h2><h3 id="1、SDS的定义"><a href="#1、SDS的定义" class="headerlink" title="1、SDS的定义"></a>1、SDS的定义</h3><p>SDS又称为简单动态字符串（Simple Dynamic String），SDS的定义如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201026211558.png" srcset="/img/loading.gif" alt=""></p><p>如果将一个值为“Redis”的字符串放入SDS中，它的状态如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201026211647.png" srcset="/img/loading.gif" alt=""></p><ul><li>buf相当于C中的字符串，<strong>一般被称为字节数组</strong>，为一个char类型的数组</li><li>len记录了buf的长度（未记录最后一个’\0’字符）<ul><li>该值使得<strong>获取字符串的长度的时间复杂度降为了O(1)</strong></li></ul></li><li>free中保存了额外申请的空间<ul><li>在进行字符串拼接时<ul><li>如果空间充足，会直接使用之前额外申请的空间</li><li>如果空间不足（free &lt; 拼接字符串的长度）会申请额外的空间。若所需的空间<strong>小于1M</strong>，会额外申请和len值相同的空间（如申请13个字符，则free也为13）。若所需空间<strong>大于等于1M</strong>，则额外申请1M的空间</li></ul></li><li>在进行字符串裁剪时<ul><li>多出来的空间会被记录在free中，方便再次使用</li></ul></li></ul></li></ul><h3 id="2、与C语言字符串的差别"><a href="#2、与C语言字符串的差别" class="headerlink" title="2、与C语言字符串的差别"></a>2、与C语言字符串的差别</h3><table><thead><tr><th align="center">C语言字符串</th><th align="center">SDS</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">获取长度的时间复杂度为O(n)</td><td align="center">获取长度的时间复杂度为O(1)</td><td align="center">SDS中len属性保存了字符串的长度</td></tr><tr><td align="center">修改字符串n次<strong>必定</strong>执行n次内存分配</td><td align="center">修改字符串<strong>最多</strong>执行n次内存分配</td><td align="center">SDS会分配额外的空间，额外空间大小由free记录</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本数据或者二进制数据</td><td align="center">SDS使用buf来保存一系列二进制数据</td></tr><tr><td align="center">可以使用&lt;string.h&gt;库中所有的函数</td><td align="center">可以使用&lt;string.h&gt;中部分函数</td><td align="center">SDS中的buf相当于字符串</td></tr></tbody></table><h2 id="二、链表（Redis-3-2以后已经不再使用）"><a href="#二、链表（Redis-3-2以后已经不再使用）" class="headerlink" title="二、链表（Redis 3.2以后已经不再使用）"></a>二、<del>链表（Redis 3.2以后已经不再使用）</del></h2><h3 id="1、Redis中的链表"><a href="#1、Redis中的链表" class="headerlink" title="1、Redis中的链表"></a>1、Redis中的链表</h3><p>Redis中的<strong>链表节点</strong>定义如下</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span>    <span class="hljs-comment">// 保存前驱节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span>    <span class="hljs-comment">// 保存后继节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">// 保存值</span>    <span class="hljs-keyword">void</span> *value;&#125; listNode;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201027131316.png" srcset="/img/loading.gif" alt=""></p><p>Redis中将节点放在了list中</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span>    <span class="hljs-comment">// 头结点</span>    listNode *head;    <span class="hljs-comment">// 尾节点</span>    listNode *tail;    <span class="hljs-comment">// 复制函数</span>    <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr);    <span class="hljs-comment">// 释放函数</span>    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">void</span> *ptr);    <span class="hljs-comment">// 匹配函数</span>    <span class="hljs-keyword">int</span> (*match)(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *key);    <span class="hljs-comment">// 链表长度</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;&#125; <span class="hljs-built_in">list</span>;</code></pre><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len</p><p>dup、free和match成员则是用于实现多态链表所需的类型特定函数</p><ul><li>dup函数用于复制链表节点所保存的</li><li>free函数用于释放链表节点所保存的值</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201027131612.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、Redis中链表的特性"><a href="#2、Redis中链表的特性" class="headerlink" title="2、Redis中链表的特性"></a>2、Redis中链表的特性</h3><ul><li><strong>双向链表</strong>，能够很方便地获取一个节点的前驱节点或后继节点</li><li><strong>带头尾指针</strong>，list中的head与tail分别保存了链表的头结点和尾节点</li><li><strong>获取长度方便</strong>，list中的len属性使得获取链表长度的时间复杂度变为了O(1)</li><li><strong>多态</strong>，链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li></ul><h2 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h2><h3 id="1、Redis中字典的实现"><a href="#1、Redis中字典的实现" class="headerlink" title="1、Redis中字典的实现"></a>1、Redis中字典的实现</h3><p>Redis的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个</strong>哈希表节点，而每个哈希表节点就保存了字典中的<strong>一个</strong>键值对</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis中的哈希表实现如下</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span>    <span class="hljs-comment">// 哈希表数组</span>    <span class="hljs-comment">// 类似于Java中HashMap的</span>    <span class="hljs-comment">//transient Node&lt;K,V&gt;[] table;</span>    dictEntry **table;        <span class="hljs-comment">// 哈希表大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">size</span>;        <span class="hljs-comment">// 哈希表掩码，大小为size-1</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;        <span class="hljs-comment">// 哈希表中已有的节点数</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;&#125; dictht;</code></pre><ul><li>table为一个dictEntry类型的数组<ul><li>每个dictEntry中保存了一个键值对</li></ul></li><li>size记录了哈希表的大小</li><li>sizemask为size-1，用于哈希计算，决定一个键应该被放到哪个桶中</li><li>used记录了哈希表目前已有节点（<strong>键值对</strong>）的数量</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201027133500.png" srcset="/img/loading.gif" alt=""></p><h4 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h4><p>Redis中哈希节点的实现如下</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span>    <span class="hljs-comment">// 键</span>    <span class="hljs-keyword">void</span> *key;    <span class="hljs-comment">// 值</span>    <span class="hljs-keyword">union</span> &#123;        <span class="hljs-keyword">void</span> *val;        <span class="hljs-keyword">uint64_t</span> u64;        <span class="hljs-keyword">int64_t</span> s64;        <span class="hljs-keyword">double</span> d;    &#125; v;    <span class="hljs-comment">// 指向下一个哈希节点，形成链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span>&#125; dictEntry;</code></pre><p>类似于Java中HashMap的Node</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;    <span class="hljs-comment">// 方法省去</span>    ...&#125;</code></pre><ul><li>key保存了键值对中键的值</li><li>value保存了键值对中值的值，其中值可以为指针类型，uint64_t、int64_t和double</li><li>next用于解决哈希冲突，使用拉链法</li></ul><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典实现如下</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span>    dictType *type;    <span class="hljs-keyword">void</span> *privdata;    dictht ht[<span class="hljs-number">2</span>];    <span class="hljs-keyword">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span>&#125; dict;</code></pre><ul><li><p>type属性是一个指向<strong>dictType</strong>结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</p></li><li><p>而privdata属性则保存了需要传给那些类型特定函数的可选参数</p></li></ul><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span>    <span class="hljs-comment">// 计算哈希值的函数</span>    <span class="hljs-keyword">uint64_t</span> (*hashFunction)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);        <span class="hljs-comment">// 复制键的函数</span>    <span class="hljs-keyword">void</span> *(*keyDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);        <span class="hljs-comment">// 复制值的函数</span>    <span class="hljs-keyword">void</span> *(*valDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj);        <span class="hljs-comment">// 对比键的函数</span>    <span class="hljs-keyword">int</span> (*keyCompare)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key2);        <span class="hljs-comment">// 销毁键的函数</span>    <span class="hljs-keyword">void</span> (*keyDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *key);       <span class="hljs-comment">// 销毁值的函数</span>    <span class="hljs-keyword">void</span> (*valDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *obj);&#125; dictType;</code></pre><ul><li><p>ht属性为包含了两个ditht元素的数组</p><ul><li>一般情况下，只是用ht[0]作为哈希表，ht[1]只会在对ht[0]进行rehash时才会使用</li></ul></li><li><p>rehashidx是除了ht[1]以外，另一个与rehash有关的属性，它<strong>记录了rehash目前的进度</strong>，如果没有rehash，那么它的值为-1</p></li></ul><p><strong>一个普通状态下（未进行rehash）的字典如下图所示</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201027202040.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、字典中的算法"><a href="#2、字典中的算法" class="headerlink" title="2、字典中的算法"></a>2、字典中的算法</h3><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p><strong>Redis计算哈希值和索引值的方法如下</strong>：</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107133850.png" srcset="/img/loading.gif" alt=""></p><ul><li>将key通过hashFunction方法计算出对应的hash值</li><li>再结合sizemask(值为size-1，和Java中的HashMap求索引的方法类似)，获得该key对应的索引值</li></ul><p><strong>例</strong>：如果我们要将一个键值对k0和v0添加到容量为4字典里面，那么程序会先使用语句：</p><pre><code class="hljs c">hash = dict-&gt;type-&gt;hashFunction(key0);</code></pre><p>计算出对应的hash值</p><p>假设计算的hash值为8，则再通过sizemask（值为3）来计算出索引</p><pre><code class="hljs c">index = hash &amp; dict-&gt;ht[x].sizemask; <span class="hljs-comment">// 8 &amp; 3 = 0</span></code></pre><p>计算出key0的索引值为0，放入对应的位置上</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107134331.png" srcset="/img/loading.gif" alt=""></p><p>Redis底层使用MurmurHash2算法来计算键的哈希值</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">MurmurHash2</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * key, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">uint32_t</span> seed )</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// 'm' and 'r' are mixing constants generated offline.</span>  <span class="hljs-comment">// They're not really 'magic', they just happen to work well.</span>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> m = <span class="hljs-number">0x5bd1e995</span>;  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> r = <span class="hljs-number">24</span>;   <span class="hljs-comment">// Initialize the hash to a 'random' value</span>   <span class="hljs-keyword">uint32_t</span> h = seed ^ len;   <span class="hljs-comment">// Mix 4 bytes at a time into the hash</span>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * data = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)key;   <span class="hljs-keyword">while</span>(len &gt;= <span class="hljs-number">4</span>)  &#123;    <span class="hljs-keyword">uint32_t</span> k = *(<span class="hljs-keyword">uint32_t</span>*)data;     k *= m;    k ^= k &gt;&gt; r;    k *= m;     h *= m;    h ^= k;     data += <span class="hljs-number">4</span>;    len -= <span class="hljs-number">4</span>;  &#125;   <span class="hljs-comment">// Handle the last few bytes of the input array</span>   <span class="hljs-keyword">switch</span>(len)  &#123;  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: h ^= data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>;  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: h ^= data[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>;  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: h ^= data[<span class="hljs-number">0</span>];      h *= m;  &#125;;   <span class="hljs-comment">// Do a few final mixes of the hash to ensure the last few</span>  <span class="hljs-comment">// bytes are well-incorporated.</span>   h ^= h &gt;&gt; <span class="hljs-number">13</span>;  h *= m;  h ^= h &gt;&gt; <span class="hljs-number">15</span>;   <span class="hljs-keyword">return</span> h;&#125;</code></pre><h4 id="哈希冲突的解决方法"><a href="#哈希冲突的解决方法" class="headerlink" title="哈希冲突的解决方法"></a>哈希冲突的解决方法</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。</p><p>Redis的哈希表使用<strong>链地址法</strong>（separate chaining）来解决键冲突（和Java 7 中的HashMap类似），每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p><strong>冲突前</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107134917.png" srcset="/img/loading.gif" alt=""></p><p><strong>冲突后</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107134951.png" srcset="/img/loading.gif" alt=""></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load_factor）维持在一个合理的范围之内（可以减少出现哈希冲突的几率），当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的<strong>扩展或者收缩</strong>。</p><p>扩展和收缩哈希表的工作可以通过执行<strong>rehash（重新散列）</strong>操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><ul><li><p>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（dictht.used的大小）</p><ul><li>如果执行的是<strong>扩展操作</strong>，那么ht[1]的大小为<strong>第一个</strong>大于ht[0].used*2 的 2<sup>n</sup> （和Java 中的 HashMap一样，这样可以保证sizemask的值必定为11…11）</li><li>如果执行的是<strong>收缩操作</strong>，那么ht[1]的大小为第一个小于ht[0].used的 2<sup>n</sup> <ul><li>注：Redis中的字典是有<strong>缩容</strong>操作的，而Java中的HashMap没有缩容操作</li></ul></li></ul></li><li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面</p><ul><li>rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上</li></ul></li><li><p>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</p><ul><li>上面有两步有点像垃圾回收算法中的<strong>标记-复制算法</strong>（FROM-TO，然后交换FROM 和 TO）</li></ul></li></ul><p><strong>例</strong></p><p>假设程序要对下图所示字典的ht[0]进行<strong>扩展操作</strong>，那么程序将执行以下步骤：</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107140647.png" srcset="/img/loading.gif" alt=""></p><ul><li>ht[0].used当前的值为4，4*2=8，所以程序会将ht[1]哈希表的大小设置为8。下图展示了ht[1]在分配空间之后，字典的样子</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107140815.png" srcset="/img/loading.gif" alt=""></p><ul><li>将ht[0]包含的四个键值对都<strong>rehash</strong>到ht[1]</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107140838.png" srcset="/img/loading.gif" alt=""></p><ul><li>释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表，如下图所示。至此，对哈希表的扩展操作执行完毕，程序成功将哈希表的大小从原来的4改为了现在的8</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107141210.png" srcset="/img/loading.gif" alt=""></p><p><strong>哈希表的扩展与收缩</strong></p><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作</p><ul><li><p>服务器目前<strong>没有在执行</strong>BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</p></li><li><p>服务器目前<strong>正在执行</strong>BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5</p><ul><li>负载因子的计算方法如下</li></ul><pre><code class="hljs c"><span class="hljs-comment">// 负载因子的计算</span>load_factory = ht[<span class="hljs-number">0</span>].used/ht[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span></code></pre></li></ul><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而<strong>尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存</strong>。</p><p>另一方面，<strong>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</strong>。</p><h4 id="渐进rehash"><a href="#渐进rehash" class="headerlink" title="渐进rehash"></a>渐进rehash</h4><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，<strong>这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</strong>这样做主要因为在数据量较大时，如果一次性，集中式地完成，庞大的计算量可能会导致服务器在一段时间内停止服务。</p><p><strong>详细步骤</strong></p><ul><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始<ul><li>索引计数器rehashidx类似程序计数器PC，用于保存进行rehash的进度（rehash到哪个索引了）</li></ul></li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一（指向下一个索引）</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成</li></ul><p><strong>图解步骤</strong></p><ul><li>准备开始rehash</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107151610.png" srcset="/img/loading.gif" alt=""></p><ul><li>开始rehash，rehash索引为0的键值对</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107151709.png" srcset="/img/loading.gif" alt=""></p><ul><li>rehash索引为1的键值对</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107151744.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>… 依次rehash</p></li><li><p>rehash完成，rehashidx再次变为-1</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107151834.png" srcset="/img/loading.gif" alt=""></p><p>因为在进行渐进式rehash的过程中，<strong>字典会同时使用ht[0]和ht[1]两个哈希表</strong>，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会<strong>在两个哈希表上进行</strong></p><p>​    例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类</p><p>另外，在渐进式rehash执行期间，<strong>新添加到字典的键值对一律会被保存到ht[1]里面</strong>，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表</p><h2 id="四、跳跃表"><a href="#四、跳跃表" class="headerlink" title="四、跳跃表"></a>四、跳跃表</h2><h3 id="1、什么是跳跃表"><a href="#1、什么是跳跃表" class="headerlink" title="1、什么是跳跃表"></a>1、什么是跳跃表</h3><p>跳跃链表是一种随机化数据结构，<strong>基于并联的链表</strong>，其效率可比拟于二叉排序树(对于大多数操作需要O(log n)平均时间)，并且对并发算法友好。</p><p>基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化（抛硬币）的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。</p><h3 id="2、跳跃表原理"><a href="#2、跳跃表原理" class="headerlink" title="2、跳跃表原理"></a>2、跳跃表原理</h3><h4 id="查询链表的时间复杂度"><a href="#查询链表的时间复杂度" class="headerlink" title="查询链表的时间复杂度"></a>查询链表的时间复杂度</h4><p><strong>搜索链表中的元素时，无论链表中的元素是否有序，时间复杂度都为O(n)</strong>，如下图，搜索103需要查询9次才能找到该节点</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107211857.png" srcset="/img/loading.gif" alt=""></p><p>但是能够提高搜索的其他数据结构，如：二叉排序树、红黑树、B树、B+树等等的实现又过于复杂。有没有一种相对简单，同时又能提搜索效率的数据结构呢，跳跃表就是这样一种数据结构。</p><p>Redis中使用跳跃表好像就是因为一是B+树的实现过于复杂，二是Redis只涉及内存读写，所以最后选择了跳跃表。</p><h4 id="跳跃表实现——搜索"><a href="#跳跃表实现——搜索" class="headerlink" title="跳跃表实现——搜索"></a>跳跃表实现——搜索</h4><p>为了能够更快的查找元素，我们可以在该链表之上，再添加一个新链表，新链表中保存了部分旧链表中的节点，以加快搜索的速度。如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107212138.png" srcset="/img/loading.gif" alt=""></p><p>我们搜索元素时，从最上层的链表开始搜索。当找到某个节点大于目标值或其后继节点为空时，从该节点向下层链表搜寻，然后顺着该节点到下一层继续搜索。</p><p>比如我们要找103这个元素，则会经历：2-&gt;23-&gt;54-&gt;87-&gt;103 </p><p>这样还是查找了5次，当我们再将链表的层数增高以后，查找的次数会明显降低，如下图所示。3次便找到了目标元素103</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107212157.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码中实现的跳表结构如下图所示</strong></p><p>一个节点拥有多个指针，指向不同的节点</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108152446.png" srcset="/img/loading.gif" alt=""></p><h4 id="跳跃表实现——插入"><a href="#跳跃表实现——插入" class="headerlink" title="跳跃表实现——插入"></a>跳跃表实现——插入</h4><p>跳跃表的插入策略如下</p><ul><li>先找到合适的位置以便插入元素</li><li>找到后，将该元素插入到最底层的链表中，并且<strong>抛掷硬币（1/2的概率）</strong><ul><li>若硬币为正面，则将该元素晋升到上一层链表中，<strong>并再抛一次</strong></li><li>若硬币为反面，则插入过程结束</li></ul></li><li>为了避免以下情况，需要在每个链表的头部设置一个 <strong>负无穷</strong> 的元素</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108100544.png" srcset="/img/loading.gif" alt=""></p><p>设置负无穷后，若要查找元素2，过程如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108100641.png" srcset="/img/loading.gif" alt=""></p><p><strong>插入图解</strong></p><ul><li><p>若我们要将45插入到跳跃表中<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107214001.png" srcset="/img/loading.gif" alt=""></p></li><li><p>先找到插入位置，将45插入到合适的位置<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107214125.png" srcset="/img/loading.gif" alt=""></p></li><li><p>抛掷硬币：<strong>为正</strong>，晋升<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107214603.png" srcset="/img/loading.gif" alt=""></p></li><li><p>假设硬币一直为正，插入元素一路晋升，当晋升的次数超过跳跃表的层数时，<strong>需要再创建新的链表以放入晋升的插入元素。新创建的链表的头结点为负无穷</strong><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201107214928.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><strong>以上便是跳跃表的插入过程</strong></p><h3 id="3、Redis中的跳跃表"><a href="#3、Redis中的跳跃表" class="headerlink" title="3、Redis中的跳跃表"></a>3、Redis中的跳跃表</h3><h4 id="为什么Redis要使用跳跃表而不是用B-树"><a href="#为什么Redis要使用跳跃表而不是用B-树" class="headerlink" title="为什么Redis要使用跳跃表而不是用B+树"></a>为什么Redis要使用跳跃表而不是用B+树</h4><p>引用Redis作者 antirez 的原话</p><pre><code class="hljs sql"> There are a few reasons:1) They are not very memory intensive. It's up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.2) A sorted <span class="hljs-keyword">set</span> <span class="hljs-keyword">is</span> often target <span class="hljs-keyword">of</span> many ZRANGE <span class="hljs-keyword">or</span> ZREVRANGE <span class="hljs-keyword">operations</span>, that <span class="hljs-keyword">is</span>, traversing the <span class="hljs-keyword">skip</span> <span class="hljs-keyword">list</span> <span class="hljs-keyword">as</span> a linked list. <span class="hljs-keyword">With</span> this operation the <span class="hljs-keyword">cache</span> locality <span class="hljs-keyword">of</span> <span class="hljs-keyword">skip</span> lists <span class="hljs-keyword">is</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">least</span> <span class="hljs-keyword">as</span> good <span class="hljs-keyword">as</span> <span class="hljs-keyword">with</span> other kind <span class="hljs-keyword">of</span> balanced trees.<span class="hljs-number">3</span>) They <span class="hljs-keyword">are</span> simpler <span class="hljs-keyword">to</span> implement, debug, <span class="hljs-keyword">and</span> so forth. <span class="hljs-keyword">For</span> <span class="hljs-keyword">instance</span> thanks <span class="hljs-keyword">to</span> the <span class="hljs-keyword">skip</span> <span class="hljs-keyword">list</span> simplicity I received a <span class="hljs-keyword">patch</span> (already <span class="hljs-keyword">in</span> Redis <span class="hljs-keyword">master</span>) <span class="hljs-keyword">with</span> augmented <span class="hljs-keyword">skip</span> lists implementing ZRANK <span class="hljs-keyword">in</span> O(<span class="hljs-keyword">log</span>(N)). It <span class="hljs-keyword">required</span> <span class="hljs-keyword">little</span> changes <span class="hljs-keyword">to</span> the code.翻译一下<span class="hljs-number">1</span>) 它们不需要太多的内存。这基本上取决于你。改变一个节点具有给定级别数的概率的参数，会比btree占用更少的内存。<span class="hljs-number">2</span>) 排序集通常是许多ZRANGE或ZREVRANGE操作的目标，即作为链表遍历跳跃表。使用这种操作，跳跃表的缓存局部性至少与其他类型的平衡树一样好。<span class="hljs-number">3</span>)它们更容易实现、调试等等。例如，感谢跳跃表的简单性，我收到了一个补丁(已经在Redis <span class="hljs-keyword">master</span>)，增强跳跃表实现ZRANK在O(<span class="hljs-keyword">log</span>(N))。它只需要对代码做一点小小的修改。</code></pre><p>MySQL使用B+树的是因为：<strong>叶子节点存储数据，非叶子节点存储索引</strong>，B+树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，<strong>充分利用了磁盘预读的功能</strong>。每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一</p><p>而Redis是<strong>内存中读取数据，不涉及IO，因此使用了跳跃表</strong></p><p>既然提到了Redis是对<strong>内存操作</strong>的，那么再讨论一个问题：<strong>为什么Redis是单线程的还这么快呢</strong></p><h4 id="Redis使用单线程效率还很高的原因"><a href="#Redis使用单线程效率还很高的原因" class="headerlink" title="Redis使用单线程效率还很高的原因"></a><strong>Redis使用单线程效率还很高的原因</strong></h4><p>假设有两个任务A和B，分别有两种方法来执行他们</p><ul><li>两个线程并发执行：先执行A一段时间，然后切换到B再执行一段时间，然后又切换回A执行… 直到A和B都执行完毕</li><li>两个线程串行执行：先执行A，A执行完了在执行B</li></ul><p>对于单核CPU来说，第二种方法的执行时间更短，效率更高。因为单核CPU下的并发操作，会导致上下文的切换，需要保存切换线程的信息，这段时间CPU无法去执行任何任务中的指令，时间白白浪费了</p><p><strong>对于I/O操作，并发执行效率更高</strong></p><p>因为I/O操作主要有以下两个过程</p><ul><li>等待I/O准备就绪</li><li>真正操作I/O资源</li></ul><p><strong>等待I/O准备就绪</strong>这个阶段，CPU是空闲的，这时便可以去执行其他任务，这样也就提高了CPU的利用率</p><p><strong>而Redis是基于内存的操作，没有I/O操作，所以单线程执行效率更高</strong></p><h3 id="4、Redis中跳表的实现"><a href="#4、Redis中跳表的实现" class="headerlink" title="4、Redis中跳表的实现"></a>4、Redis中跳表的实现</h3><p>Redis中的sort_set主要由跳表实现，sort_set的添加语句如下</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">zadd</span></span> key score1 member1 score2 member2 ...</code></pre><p>Redis中的跳表结构如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108155128.png" srcset="/img/loading.gif" alt=""></p><p>Redis中的跳表主要由节点<strong>zskiplistNode</strong>和跳表<strong>zskiplist</strong>来实现，他们的源码如下</p><h4 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h4><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span>    <span class="hljs-comment">// 存储的元素 就是语句中的member</span>    sds ele;        <span class="hljs-comment">// 分值,就是语句中的score</span>    <span class="hljs-keyword">double</span> score;        <span class="hljs-comment">// 指向前驱节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span>        <span class="hljs-comment">// 层，每个节点有1~32个层，除头结点外（32层），其他节点的层数是随机的</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span>        <span class="hljs-comment">// 每个层都保存了该节点的后继节点</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>                <span class="hljs-comment">// 跨度，用于记录该节点与forward指向的节点之间，隔了多少各节点。主要用于计算Rank</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> span;    &#125; level[];&#125; zskiplistNode;</code></pre><p><strong>各个属性的详细解释</strong></p><ul><li><p>ele：sds变量，保存member。</p></li><li><p>score：double变量，用于保存score</p><ul><li><strong>注意</strong>：<strong>score和ele共同来决定一个元素在跳表中的顺序</strong>。score不同则根据score进行排序，score相同则根据ele来进行排序</li><li><strong>跳表中score是可以相同的，而ele是肯定不同的</strong></li></ul></li><li><p>backward：前驱指针，用于保存节点的前驱节点，<strong>每个节点只有一个backward</strong></p><ul><li>例：如果要从第四层的节点访问第三层的节点，则可以通过backward直接访问<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108160050.png" srcset="/img/loading.gif" alt=""></li></ul></li><li><p>level[]：节点的层，每个节点拥有1~32个层，除头结点外（32层），其他节点的层数是随机的。<strong>注意</strong>：Redis中没有使用抛硬币的晋升策略，而是直接随机一个层数值。下图展示了层数不同的几个节点<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108160122.png" srcset="/img/loading.gif" alt=""></p><ul><li>level：保存了该节点指向的下一个节点，但是不一定是紧挨着的节点。还保存了两个节点之间的跨度<ul><li>forward：后继节点，该节点指向的下一个节点，但是不一定是紧挨着的节点</li><li>span：跨度，用于记录从该节点到forward指向的节点之间，要走多少步。主要用于计算Rank<ul><li>rank：排位，头节点开始到目标节点的跨度，由沿途的span相加获得</li></ul></li></ul></li></ul></li></ul><h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a><strong>zskiplist</strong></h4><p>zskiplist的源码如下</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span>    <span class="hljs-comment">// 头尾指针，用于保存头结点和尾节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span>        <span class="hljs-comment">// 跳跃表的长度，即除头结点以外的节点数</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;        <span class="hljs-comment">// 最大层数，保存了节点中拥有的最大层数（不包括头结点）</span>    <span class="hljs-keyword">int</span> level;&#125; zskiplist;</code></pre><h4 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h4><p>遍历需要访问跳表中的每个节点，直接走底层的节点即可依次访问</p><h4 id="搜索过程"><a href="#搜索过程" class="headerlink" title="搜索过程"></a>搜索过程</h4><p>如我们要访问该跳表中score = 2.0的节点</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201108162654.png" srcset="/img/loading.gif" alt=""></p><p>从高层依次向下层遍历</p><ul><li>头结点的L6~L32的 forward 都为空，从L5开始访问</li><li>头结点L5的 forward 的指向的node3的score为3.0，小于2.0，返回头结点</li><li>从头结点L4 的 forward 指向的node1开始访问，节点的score = 1.0，继续向下执行</li><li>从node1的 L4 开始访问，为node3，返回node1</li><li>从node1的L3开始访问，为node3，返回node1</li><li>从node1的L2开始访问，为node2，score = 2.0，即为所要的节点</li></ul><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><p>插入节点时，需要找到节点的插入位置。并给节点的各个属性赋值。插入后判断是否需要拓展上层</p><h2 id="五、整数集合"><a href="#五、整数集合" class="headerlink" title="五、整数集合"></a>五、整数集合</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>整数集合（intset）是集合键的底层实现之一，<strong>当一个集合只包含整数值元素，并且这个集合的元素数量不多时</strong>，Redis就会使用整数集合作为集合键的底层实现，例如</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113112602.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、整数集合的实现"><a href="#2、整数集合的实现" class="headerlink" title="2、整数集合的实现"></a>2、整数集合的实现</h3><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且<strong>保证集合中不会出现重复元素且按照从小到大的顺序排列</strong></p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span>    <span class="hljs-comment">// 编码方式</span>    <span class="hljs-keyword">uint32_t</span> encoding;    <span class="hljs-comment">// contents数组的长度</span>    <span class="hljs-keyword">uint32_t</span> length;    <span class="hljs-comment">// 保存元素的数组，也就是set集合</span>    <span class="hljs-keyword">int8_t</span> contents[];&#125; intset;</code></pre><ul><li><p>length：记录了contents数组中元素的个数</p></li><li><p>contents：为intset的底层实现，用于存放不重复的元素，且<strong>元素按照从小到大的顺序排列。数组类型由encoding决定，与int8_t无关</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113113802.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值</li><li>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值</li><li>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值</li></ul></li></ul><p><strong>图解</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113113502.png" srcset="/img/loading.gif" alt=""></p><ul><li>该整数解中有5个元素，contents的类型为int16_t</li></ul><h3 id="3、升级"><a href="#3、升级" class="headerlink" title="3、升级"></a>3、升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且<strong>新元素的类型比整数集合现有所有元素的类型都要长时</strong>，整数集合需要先进行<strong>升级</strong>（upgrade），然后才能将新元素添加到整数集合里面</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul><li>根据新元素的类型，<strong>扩展</strong>整数集合底层数组的空间大小，并为新元素<strong>分配空间</strong></li><li>将底层数组(contents[])现有的所有元素都<strong>转换</strong>成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的<strong>有序性质不变</strong></li><li>将新元素添加到底层数组里面<ul><li>因为新元素的长度大于数组中所有其他元素的长度，所以<strong>该元素要么是最小的，要么是最大的</strong><ul><li>若为最小值，放在数组开头</li><li>若为最大值，放在数组末尾</li></ul></li></ul></li></ul><p><strong>图解</strong></p><ul><li><p>假设现在有一个INTSET_ENC_INT16编码的整数集合，<strong>集合中包含三个int16_t类型的元素</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113114715.png" srcset="/img/loading.gif" alt=""></p><ul><li>因为contents中的元素都是16位的，3个数组共占用空间48位，如下</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113114838.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li><p>这时，需要将65535添加到整数集合里面，因为int16_t能够表示的范围为(-32768~32767)，无法容纳该数字，所以<strong>需要升级</strong>。升级过程如下</p><ul><li>扩展content的分配的内存空间，由3x16 扩展为 3x32</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113115436.png" srcset="/img/loading.gif" alt=""></p><ul><li>将数组中的元素<strong>类型改为int32_t</strong>，并放入扩展后的contents中。最后添加新插入的元素。<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113115536.png" srcset="/img/loading.gif" alt="">)<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113115550.png" srcset="/img/loading.gif" alt="">)<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113115604.png" srcset="/img/loading.gif" alt="">)<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113115811.png" srcset="/img/loading.gif" alt=""></li><li>改变intset中，encoding和length的值<ul><li>encoding由INTSET_ENC_INT16改为INTSET_ENC_INT32</li><li>lentg由3改为4</li></ul></li></ul></li></ul><ul><li>插入完成后，intset的结构如下</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113115909.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、升级的好处"><a href="#4、升级的好处" class="headerlink" title="4、升级的好处"></a>4、升级的好处</h3><ul><li><p><strong>自适应</strong>：会根据contents中的元素位数选择最合适的类型，来进行内存的分配</p></li><li><p><strong>节约内存</strong>：基于自适应，不会为一个位数较少的整数分配较大的空间</p></li></ul><h2 id="六、压缩列表"><a href="#六、压缩列表" class="headerlink" title="六、压缩列表"></a>六、压缩列表</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><p>压缩列表（ziplist）是列表键(list)和哈希键(hash)的底层实现之一</p><ul><li><p>当<strong>一个列表键（list）只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串</strong>，那么Redis就会使用压缩列表来做列表键的底层实现</p><ul><li>注意：这一点没有验证出来。根据书上的例子，底层使用的是quicklist</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113162812.png" srcset="/img/loading.gif" alt=""></p></li><li><p>当<strong>一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串</strong>，那么Redis就会使用压缩列表来做哈希键的底层实现</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113162843.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、压缩列表的组成"><a href="#2、压缩列表的组成" class="headerlink" title="2、压缩列表的组成"></a>2、压缩列表的组成</h3><p>压缩列表是Redis为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存<strong>一个字节数组</strong>或者<strong>一个整数值</strong>。具体组成如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113163516.png" srcset="/img/loading.gif" alt=""></p><h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><ul><li>zlbytes：表示压缩列表占用的内存（单位：字节）</li><li>zltail：压缩列表其实指针到尾节点的偏移量<ul><li>如果我们有一个指向压缩列表起始地址的指针p，通过p+zltail就能直接访问压缩列表的最后一个节点</li></ul></li><li>zllen：压缩列表中的<strong>节点数</strong></li><li>entry：压缩列表中的节点</li></ul><h3 id="3、压缩列表中的节点"><a href="#3、压缩列表中的节点" class="headerlink" title="3、压缩列表中的节点"></a>3、压缩列表中的节点</h3><p>每个压缩列表节点都由<strong>previous_entry_length、encoding、content</strong>三个部分组成，如下图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201113164801.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span> &#123;</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> prevrawlensize;     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> prevrawlen;         <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lensize;            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len;               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> headersize;         <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> encoding;          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *p;          &#125; zlentry;</code></pre><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的previous_entry_length属性以<strong>字节为单位，记录了压缩列表中前一个节点的长度</strong>，其值长度为1个字节<strong>或者</strong>5个字节</p><ul><li>如果前一节点的长度<strong>小于254字节</strong>，那么previous_entry_length属性的<strong>长度为1字节</strong><ul><li>前一节点的长度就保存在这一个字节里面</li></ul></li><li>如果前一节点的长度<strong>大于等于254字节</strong>，那么previous_entry_length属性的<strong>长度为5字节</strong><ul><li>其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度</li></ul></li></ul><p>若前一个节点的长度为5个字节，那么压缩列表的previous_entry_length属性为0x05（1个字节保存长度）</p><p>若前一个节点的长度为10086(0x2766)，那么压缩列表中previous_entry_length属性为0xFE00002766（后4个字节保存长度）</p><p>通过previous_entry_length属性，可以方便地访问当前节点的前一个节点</p><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的encoding属性记录了<strong>节点的content属性所保存数据的类型以及长度</strong></p><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>节点的content属性负责保存节点的值，<strong>节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定</strong></p><h2 id="七、快表"><a href="#七、快表" class="headerlink" title="七、快表"></a>七、快表</h2><h3 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h3><p>quicklist是Redis 3.2中新引入的数据结构，<strong>能够在时间效率和空间效率间实现较好的折中</strong>。Redis中对quciklist的注释为A doubly linked list of ziplists。顾名思义，quicklist是一个双向链表，链表中的每个节点是一个ziplist结构。quicklist可以看成是用双向链表将若干小型的ziplist连接到一起组成的一种数据结构。当ziplist节点个数过多，quicklist退化为双向链表，一个极端的情况就是每个ziplist节点只包含一个entry，即只有一个元素。当ziplist元素个数过少时，quicklist可退化为ziplist，一种极端的情况就是quicklist中只有一个ziplist节点</p><h3 id="2、快表的结构"><a href="#2、快表的结构" class="headerlink" title="2、快表的结构"></a>2、快表的结构</h3><p>quicklist是由quicklist node组成的双向链表，quicklist node中又由ziplist充当节点。quicklist的存储结构如图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116193058.png" srcset="/img/loading.gif" alt=""></p><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a><strong>quicklist</strong></h4><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span>    quicklistNode *head;    quicklistNode *tail;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> count;        <span class="hljs-comment">/* total count of all entries in all ziplists */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;          <span class="hljs-comment">/* number of quicklistNodes */</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">fill</span> : QL_FILL_BITS;              <span class="hljs-comment">/* fill factor for individual nodes */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> compress : QL_COMP_BITS; <span class="hljs-comment">/* depth of end nodes not to compress;0=off */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bookmark_count: QL_BM_BITS;    quicklistBookmark bookmarks[];&#125; quicklist;</code></pre><p><strong>head和tail</strong></p><ul><li>head和tail分别指向快表的首位节点</li></ul><p><strong>count</strong></p><ul><li>count为quicklist中元素总数</li></ul><p><strong>len</strong></p><ul><li>len为quicklist Node（节点）个数</li></ul><p><strong>fill</strong></p><p>fill用来指明每个quicklistNode中ziplist长度</p><h4 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a><strong>quicklistNode</strong></h4><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *zl;   <span class="hljs-comment">/* 指向压缩列表的指针 */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sz;             <span class="hljs-comment">/* ziplist size in bytes */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count : <span class="hljs-number">16</span>;     <span class="hljs-comment">/* count of items in ziplist */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> encoding : <span class="hljs-number">2</span>;   <span class="hljs-comment">/* RAW==1 or LZF==2 */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> container : <span class="hljs-number">2</span>;  <span class="hljs-comment">/* NONE==1 or ZIPLIST==2 */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* was this node previous compressed? */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> attempted_compress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* node can't compress; too small */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">/* more bits to steal for future usage */</span>&#125; quicklistNode;</code></pre><p><strong>prev和next</strong></p><ul><li>因为quicklist为双向链表，所以有prev和next指针，分别指向前驱节点和后继节点</li></ul><p><strong>zl</strong></p><ul><li>zl指向该节点对应的<strong>ziplist结构</strong></li></ul><p><strong>encoding</strong></p><ul><li>encoding代表采用的编码方式<ul><li>1代表是原生的ziplist（未进行再次压缩）</li><li>2代表使用LZF进行压缩</li></ul></li></ul><p><strong>container</strong></p><ul><li>container为quicklistNode节点zl指向的容器类型<ul><li>1代表none</li><li>2代表使用ziplist存储数据</li></ul></li></ul><p><strong>recompress</strong></p><ul><li>recompress代表这个节点之前是否是压缩节点，若是，则在使用压缩节点前先进行解压缩，使用后需要重新压缩，此外为1，代表是压缩节点</li></ul><p><strong>attempted_compress</strong></p><ul><li>attempted_compress测试时使用</li></ul><p><strong>extra</strong></p><ul><li>extra为预留</li></ul><h4 id="quickLZF"><a href="#quickLZF" class="headerlink" title="quickLZF"></a>quickLZF</h4><p><strong>quicklist允许ziplist进行再次压缩</strong>。当我们对ziplist利用LZF算法进行压缩时，quicklistNode节点指向的结构为<strong>quicklistLZF</strong>。其中sz表示compressed所占字节大小，quicklistLZF结构如下所示</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistLZF</span> &#123;</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sz; <span class="hljs-comment">/* LZF size in bytes*/</span>    <span class="hljs-keyword">char</span> compressed[];&#125; quicklistLZF;</code></pre><h4 id="quicklistEntry"><a href="#quicklistEntry" class="headerlink" title="quicklistEntry"></a><strong>quicklistEntry</strong></h4><p>当我们使用quicklistNode中<strong>ziplist中的一个节点</strong>时，Redis提供了quicklistEntry结构以便于使用，该结构如下</p><p>可以理解为其为<strong>ziplist中的一个节点</strong>，只不过记录了更详细的信息</p><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistEntry</span> &#123;</span>    <span class="hljs-comment">// 指向当前元素所在的quicklist</span>    <span class="hljs-keyword">const</span> quicklist *quicklist;        <span class="hljs-comment">// 指向当前元素所在的quicklistNode结构</span>    quicklistNode *node;        <span class="hljs-comment">// 指向当前元素所在的ziplist</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *zi;        <span class="hljs-comment">// 指向该节点的字符串内容</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *value;        <span class="hljs-comment">// 该节点的整型值</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> longval;        <span class="hljs-comment">// 该节点的大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sz;        <span class="hljs-comment">// 该节点相对于整个ziplist的偏移量，即该节点是ziplist第多少个entry</span>    <span class="hljs-keyword">int</span> offset;&#125; quicklistEntry;</code></pre><h3 id="3、基本操作"><a href="#3、基本操作" class="headerlink" title="3、基本操作"></a>3、基本操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化是构建quicklist结构的第一步，由quicklistCreate函数完成，该函数的主要功能就是初始化quicklist结构。初始化后的quicklist如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117210043.png" srcset="/img/loading.gif" alt=""></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入操作有</p><ul><li>插入quicklist node</li><li>插入ziplist中的节点</li></ul><p>插入时可以选择头插和尾插，对应list的lpush和rpush，底层调用的是quicklistPushHead与quicklistPushTail方法</p><ul><li>quicklistPushHead的<strong>基本思路</strong>是：查看quicklist原有的head节点是否可以插入，如果可以就直接利用ziplist的接口进行插入，否则新建quicklistNode节点进行插入。函数的入参为待插入的quicklist，需要插入的数据value及其大小sz；函数返回值代表是否新建了head节点，0代表没有新建，1代表新建了head</li></ul><p>当quicklist中只有一个节点时，其结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117210218.png" srcset="/img/loading.gif" alt=""></p><p>具体的插入（zlentry）情况如下</p><ul><li>当前插入位置所在的quicklistNode仍然<strong>可以继续插入</strong>，此时可以直接插入</li><li>当前插入位置所在的quicklistNode<strong>不能继续插入</strong>，此时可以分为如下几种情况<ul><li>需要向当前quicklistNode第一个元素（entry1）前面插入元素，当前ziplist所在的quicklistNode的<strong>前一个</strong>quicklistNode可以插入，则将数据插入到前一个quicklistNode。如果<strong>前一个quicklistNode不能插入</strong>（不包含前一个节点为空的情况），则<strong>新建</strong>一个quicklistNode插入到当前quicklistNode<strong>前面</strong></li><li>需要向当前quicklistNode的最后一个元素（entryN）后面插入元素，当前ziplist所在的quicklistNode的<strong>后一个</strong>quicklistNode可以插入，则直接将数据插入到后一个quicklistNode。如果<strong>后一个quicklistNode不能插入</strong>（不包含为后一个节点为空的情况），则<strong>新建</strong>一个quicklistNode插入到当前quicklistNode的<strong>后面</strong></li><li><strong>不满足前面2个条件的所有其他种情况</strong>，将当前所在的quicklistNode以当前待插入位置为基准，拆分成左右两个quicklistNode，之后将需要插入的数据插入到其中一个拆分出来的quicklistNode中</li></ul></li></ul><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>quicklist查找元素主要是针对index，即通过元素在链表中的下标查找对应元素。基本思路是，<strong>首先找到index对应的数据所在的quicklistNode节点，之后调用ziplist的接口函数ziplistGet得到index对应的数据</strong>。简而言之就是：定位quicklistNode，再在quicklistNode中的ziplist中寻找目标节点</p><h2 id="八、对象"><a href="#八、对象" class="headerlink" title="八、对象"></a>八、对象</h2><h3 id="1、简介-3"><a href="#1、简介-3" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="基本数据结构与对象的关系"><a href="#基本数据结构与对象的关系" class="headerlink" title="基本数据结构与对象的关系"></a>基本数据结构与对象的关系</h4><p>Redis<strong>并没有直接使用</strong>简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含<strong>字符串对象、列表对象、哈希对象、集合对象和有序集合对象</strong>这五种类型的对象</p><h4 id="使用对象的好处"><a href="#使用对象的好处" class="headerlink" title="使用对象的好处"></a>使用对象的好处</h4><ul><li>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令</li><li>我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而<strong>优化对象在不同场景下的使用效率</strong></li></ul><h4 id="对象的回收——引用计数法"><a href="#对象的回收——引用计数法" class="headerlink" title="对象的回收——引用计数法"></a>对象的回收——引用计数法</h4><p>Redis的对象系统还实现了基于<strong>引用计数</strong>技术的内存回收机制</p><p>Redis还<strong>通过引用计数技术实现了对象共享机制</strong>，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存</p><h3 id="2、对象的类型与编码"><a href="#2、对象的类型与编码" class="headerlink" title="2、对象的类型与编码"></a>2、对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们<strong>至少会创建两个对象</strong>，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象），如</p><pre><code class="hljs gams"><span class="hljs-keyword">set</span> hello <span class="hljs-comment">"hello world"</span></code></pre><p>其中键值对的<strong>键</strong>是一个包含了字符串值”hello”的对象，而键值对的<strong>值</strong>则是一个包含了字符串值”hello world”的对象</p><p>Redis中的每个对象都由一个<strong>redisObject</strong>结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>    <span class="hljs-comment">// 类型(对象类型)</span>    <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 编码(对象底层使用的数据结构)</span>    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 指向底层数据结构的指针</span>    <span class="hljs-keyword">void</span> *ptr;        ....        &#125; robj;</code></pre><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象的type属性记录了对象的类型，这个属性的值可以是下标所示的值</p><table><thead><tr><th align="center">类型常量</th><th align="center">对象名称</th></tr></thead><tbody><tr><td align="center">REDIS_STRING</td><td align="center">字符串对象</td></tr><tr><td align="center">REDIS_LIST</td><td align="center">列表对象</td></tr><tr><td align="center">REDIS_HASH</td><td align="center">哈希对象</td></tr><tr><td align="center">REDIS_SET</td><td align="center">集合对象</td></tr><tr><td align="center">REDIS_ZSET</td><td align="center">有序集合对象</td></tr></tbody></table><p>对于Redis数据库保存的键值对来说，<strong>键总是一个字符串对象</strong>，而值<strong>则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种</strong>，因此</p><ul><li>当我们称呼一个数据库键为<strong>字符串</strong>键时，我们指的是这个数据库键所对应的<strong>值为字符串对象</strong></li><li>当我们称呼一个键为<strong>列表键</strong>时，我们指的是这个数据库键所对应的值为<strong>列表对象</strong></li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，<strong>命令返回的结果为数据库键对应的值对象的类型</strong>，而不是键对象的类型，如</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116090708.png" srcset="/img/loading.gif" alt=""></p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定</p><p><strong>encoding属性记录了对象所使用的编码</strong>，也即是说这个对象使用了什么数据结构作为对象的底层实现</p><table><thead><tr><th align="center">编码常量</th><th align="center">编码所对应的底层数据结构</th></tr></thead><tbody><tr><td align="center">OBJ_ENCODING_INT</td><td align="center">long类型的整数</td></tr><tr><td align="center">OBJ_ENCODING_EMBSTR</td><td align="center">embstr编码的简单动态字符串</td></tr><tr><td align="center">OBJ_ENCODING_RAW</td><td align="center">简单动态字符串</td></tr><tr><td align="center">OBJ_ENCODING_HT</td><td align="center">字典</td></tr><tr><td align="center">OBJ_ENCODING_LINKEDLIST</td><td align="center">双向链表</td></tr><tr><td align="center">OBJ_ENCODING_ZIPLIST</td><td align="center">压缩列表</td></tr><tr><td align="center">OBJ_ENCODING_INTSET</td><td align="center">整数集合</td></tr><tr><td align="center">OBJ_ENCODING_SKIPLIST</td><td align="center">跳跃表</td></tr><tr><td align="center">OBJ_ENCODING_QUICKLIST</td><td align="center">快表</td></tr><tr><td align="center">OBJ_ENCODING_ZIPMAP</td><td align="center">压缩哈希表</td></tr><tr><td align="center">OBJ_ENCODING_STREAM</td><td align="center">消息流（用于消息队列）</td></tr></tbody></table><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="hljs-comment">/* Raw representation */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="hljs-comment">/* Encoded as integer */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="hljs-comment">/* Encoded as hash table */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="hljs-comment">/* Encoded as zipmap */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="hljs-comment">/* No longer used: old list encoding. */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="hljs-comment">/* Encoded as ziplist */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="hljs-comment">/* Encoded as intset */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="hljs-comment">/* Encoded as skiplist */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="hljs-comment">/* Embedded sds string encoding */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="hljs-comment">/* Encoded as linked list of ziplists */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="hljs-comment">/* Encoded as a radix tree of listpacks */</span></span></code></pre><p>每种类型的对象都<strong>至少使用了两种</strong>不同的编码，可以通过</p><pre><code class="hljs pgsql"><span class="hljs-keyword">OBJECT</span> <span class="hljs-keyword">ENCODING</span> key</code></pre><p>指令来查看</p><p><strong>使用不同编码带来的好处</strong></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，<strong>极大地提升了Redis的灵活性和效率</strong>，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p><h3 id="3、字符串对象"><a href="#3、字符串对象" class="headerlink" title="3、字符串对象"></a>3、字符串对象</h3><p>字符串对象的编码可以是<strong>int、raw或者embstr</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116154658.png" srcset="/img/loading.gif" alt=""></p><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>如果一个字符串对象保存的是<strong>整数值</strong>，并且这个整数值<strong>可以用long类型来表示</strong>，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116153722.png" srcset="/img/loading.gif" alt=""></p><h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p>如果字符串对象保存的是一个<strong>字符串值</strong>，并且这个字符串值的<strong>长度大于32字节</strong>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116153707.png" srcset="/img/loading.gif" alt=""></p><h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>embstr编码是专门用于保存<strong>短字符串</strong>的一种优化编码方式。这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而<strong>embstr编码则通过调用一次内存分配函数来分配一块连续的空间</strong>，空间中依次包含redisObject和sdshdr两个结构</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116154107.png" srcset="/img/loading.gif" alt=""></p><p>简单来说，raw和embstr都是用来保存字符串的。字符串长度较短时使用embstr，较长时使用raw</p><ul><li>raw的redisObject和sdshdr是分别分配空间的，通过redisObject的ptr指针联系起来</li><li>embstr的redisObject和sdshdr则是一起分配空间的，在内存中是一段连续的区域</li></ul><h4 id="浮点数的编码"><a href="#浮点数的编码" class="headerlink" title="浮点数的编码"></a>浮点数的编码</h4><p>浮点数在Redis中使用embstr或者raw进行编码</p><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象（<strong>int/embstr -&gt; raw</strong>）</p><p><strong>int转raw</strong></p><p>编码为int的字符串，在<strong>进行append操作后</strong>，编码会转换为raw</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116155237.png" srcset="/img/loading.gif" alt=""></p><p><strong>embstr转raw</strong></p><p>编码为embstr的字符串，<strong>进行append操作后</strong>，编码会转换为raw</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201116155653.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、列表对象"><a href="#4、列表对象" class="headerlink" title="4、列表对象"></a>4、列表对象</h3><p>列表对象的编码是quicklist，quicklist在上面部分已经介绍过了，在此不再赘述</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117214036.png" srcset="/img/loading.gif" alt=""></p><h3 id="5、哈希对象"><a href="#5、哈希对象" class="headerlink" title="5、哈希对象"></a>5、哈希对象</h3><p>哈希对象的编码可以是ziplist或者hashtable</p><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p><strong>ziplist编码</strong>的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了<strong>键</strong>的压缩列表节点推入到压缩列表表尾，然后再将保存了<strong>值</strong>的压缩列表节点推入到压缩列表表尾，因此</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存<strong>键的节点在前</strong>，保存<strong>值的节点在后</strong></li><li><strong>先</strong>添加到哈希对象中的键值对会被放在压缩列表的表头方向，而<strong>后</strong>来添加到哈希对象中的键值对会被放在压缩列表的表尾方向</li></ul><p>如果我们依次向哈希表中添加一下元素，那么哈希对象中的压缩列表结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117215013.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117215302.png" srcset="/img/loading.gif" alt=""></p><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存</p><ul><li>字典的每个键都是一个<strong>字符串对象</strong>，对象中保存了键值对的键</li><li>字典的每个值都是一个<strong>字符串对象</strong>，对象中保存了键值对的值</li></ul><p>如果前面profile键创建的不是ziplist编码的哈希对象，而是<strong>hashtable编码</strong>的哈希对象，结构则如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117215430.png" srcset="/img/loading.gif" alt=""></p><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象可以<strong>同时满足</strong>以下两个条件时，哈希对象使用<strong>ziplist编码</strong></p><ul><li>哈希对象保存的所有键值对的<strong>键和值的字符串长度都小于64字节</strong></li><li>哈希对象保存的键值对<strong>数量小于512个</strong></li></ul><p>不能满足这两个条件的哈希对象需要使用hashtable编码</p><p><strong>使用ziplist</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117215556.png" srcset="/img/loading.gif" alt=""></p><p><strong>使用hashtable</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201117215637.png" srcset="/img/loading.gif" alt=""></p><h3 id="6、集合-set-对象"><a href="#6、集合-set-对象" class="headerlink" title="6、集合(set)对象"></a>6、集合(set)对象</h3><p>集合对象的编码可以是intset或者hashtable</p><h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118192800.png" srcset="/img/loading.gif" alt=""></p><p>其结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118192819.png" srcset="/img/loading.gif" alt=""></p><h4 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h4><p>hashtable编码的集合对象使用字典作为底层实现，字典的每个<strong>键都是一个字符串对象</strong>，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118192946.png" srcset="/img/loading.gif" alt=""></p><p>其结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118193015.png" srcset="/img/loading.gif" alt=""></p><h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当集合对象可以<strong>同时满足</strong>以下两个条件时，对象使用intset编码</p><ul><li>集合对象保存的<strong>所有元素都是整数值</strong></li><li>集合对象保存的元素数量不超过512个</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码</p><h3 id="7、有序-sorted-set-集合"><a href="#7、有序-sorted-set-集合" class="headerlink" title="7、有序(sorted_set)集合"></a>7、有序(sorted_set)集合</h3><p>有序集合的编码可以是ziplist或者skiplist</p><h4 id="ziplist-1"><a href="#ziplist-1" class="headerlink" title="ziplist"></a>ziplist</h4><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素<strong>使用两个紧挨在一起的压缩列表节点来保存</strong>，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118194654.png" srcset="/img/loading.gif" alt=""></p><p>其结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118194930.png" srcset="/img/loading.gif" alt=""></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h4><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个跳跃表和一个字典</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span>    <span class="hljs-comment">// 跳跃表</span>    zskiplist *zsl;        <span class="hljs-comment">// 字典</span>    dict *dict&#125; zset;</code></pre><p>其结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118201719.png" srcset="/img/loading.gif" alt=""></p><p><strong>字典和跳表中的数据</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118201736.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：上图在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，<strong>字典和跳跃表会共享元素的成员和分值</strong>，所以并不会造成任何数据重复，也不会因此而浪费任何内存</p><p>zset结构中的zsl跳跃表按分值(score)<strong>从小到大保存了所有集合元素</strong>，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值</p><p>其结构如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118200641.png" srcset="/img/loading.gif" alt=""></p><p>除此之外，zset结构中的<strong>dict字典为有序集合创建了一个从成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，<strong>程序可以用O（1）复杂度查找给定成员的分值</strong>，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性</p><p><strong>为何sorted_set同时使用字典和跳表来作为底层的数据结构</strong></p><p><strong>字典</strong>可以保证查询效率为O(1)，但是对于范围查询就无能为力了</p><p><strong>跳表</strong>可以保证数据是有序的，范围查询效率较高，但是单个查询效率较低</p><h3 id="8、内存回收"><a href="#8、内存回收" class="headerlink" title="8、内存回收"></a>8、内存回收</h3><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个<strong>引用计数</strong>（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p><p>每个对象的引用计数信息由redisObject结构的<strong>refcount</strong>属性记录</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>    <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-keyword">unsigned</span> lru:LRU_BITS;         <span class="hljs-comment">// 引用计数</span>    <span class="hljs-keyword">int</span> refcount;    <span class="hljs-keyword">void</span> *ptr;&#125; robj;</code></pre><p>对象的引用计数信息会随着对象的使用状态而不断变化</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1</li><li>当对象被一个新程序使用时，它的引用计数值会被增一</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放</li></ul><h1 id="Redis的功能实现"><a href="#Redis的功能实现" class="headerlink" title="Redis的功能实现"></a>Redis的功能实现</h1><h2 id="一、RDB持久化"><a href="#一、RDB持久化" class="headerlink" title="一、RDB持久化"></a>一、RDB持久化</h2><h3 id="1、简介-4"><a href="#1、简介-4" class="headerlink" title="1、简介"></a>1、简介</h3><p>因为<strong>Redis是内存数据库</strong>，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。为了解决这个问题，<strong>Redis提供了RDB持久化功能</strong>，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失</p><p>更多关于RDB持久化的操作可以查看<a href="https://nyimac.gitee.io/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/#2%E3%80%81RDB"><strong>Redis学习文档——RDB</strong></a></p><h3 id="2、-RDB文件的创建与载入"><a href="#2、-RDB文件的创建与载入" class="headerlink" title="2、 RDB文件的创建与载入"></a>2、 RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是save，另一个是bgsave</p><ul><li>save命令会<strong>阻塞Redis服务器进程</strong>，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li><li>bgsave命令会<strong>派生出一个子进程</strong>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li></ul><h4 id="save命令执行时的服务器状态"><a href="#save命令执行时的服务器状态" class="headerlink" title="save命令执行时的服务器状态"></a>save命令执行时的服务器状态</h4><p>当save命令执行时，Redis服务器会被阻塞，所以当save命令正在执行时，客户端发送的所有命令请求都会被拒绝</p><p>只有在服务器执行完save命令、重新开始接受命令请求之后，客户端发送的命令才会被处理</p><h4 id="bgsave命令执行时的服务器状态"><a href="#bgsave命令执行时的服务器状态" class="headerlink" title="bgsave命令执行时的服务器状态"></a>bgsave命令执行时的服务器状态</h4><p>因为bgsave命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，<strong>在bgsave命令执行期间</strong>，服务器处理save、bgsave、bgrewriteaof三个命令的方式会和平时有所不同</p><ul><li>在bgsave命令执行期间，客户端发送的save命令会被服务器拒绝，服务器禁止save命令和bgsave命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，<strong>防止产生竞争条件</strong></li><li>在bgsave命令执行期间，客户端发送的bgsave命令会被服务器拒绝，因为同时执行两个bgsave命令也<strong>会产生竞争条件</strong></li><li>bgwriteaof和bgsave两个命令不能同时执行 <ul><li>如果bgsave命令正在执行，那么客户端发送的bgwriteaof命令会被延迟到bgsave命令执行完毕之后执行</li><li>如果bgwriteaof命令正在执行，那么客户端发送的bgsave命令<strong>会被服务器拒绝</strong></li></ul></li></ul><h3 id="3、自动间隔性保存"><a href="#3、自动间隔性保存" class="headerlink" title="3、自动间隔性保存"></a>3、自动间隔性保存</h3><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行bgsave命令，如果我们向服务器提供以下配置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119143917.png" srcset="/img/loading.gif" alt=""></p><ul><li>900秒内修改1次数据，则保存</li><li>300秒内修改10次数据，则保存</li><li>60秒内修改10000次数据，则保存</li></ul><h4 id="saveparams数组"><a href="#saveparams数组" class="headerlink" title="saveparams数组"></a><strong>saveparams数组</strong></h4><p>服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的<strong>saveparams</strong>属性</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span>    ...    <span class="hljs-comment">// 保存save配置参数</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> *<span class="hljs-title">saveparams</span>;</span>    ...&#125;;</code></pre><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件。saveparam的结构如下</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> &#123;</span>  <span class="hljs-comment">// 设定的秒数</span>    <span class="hljs-keyword">time_t</span> seconds;    <span class="hljs-comment">// 规定时间内的修改次数</span>    <span class="hljs-keyword">int</span> changes;&#125;;</code></pre><p>如果save的设定为</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119144559.png" srcset="/img/loading.gif" alt=""></p><p>那么，redisServer中的saveparams数组的结构如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119144621.png" srcset="/img/loading.gif" alt=""></p><h4 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a><strong>dirty计数器和lastsave属性</strong></h4><ul><li>dirty计数器记录距离上一次成功执行save命令或者bgsave命令之后，服务器对数据库状态（服务器中的所有数据库）<strong>进行了多少次修改</strong>（包括写入、删除、更新等操作）</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行save命令或者bgsave命令的<strong>时间</strong></li></ul><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span>    ...    <span class="hljs-comment">// 上次save到现在Redis中数据修改的次数</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dirty;                <span class="hljs-comment">/* Changes to DB from the last save */</span>        <span class="hljs-comment">// 上一次成功save到现在所经过的时间</span>    <span class="hljs-keyword">time_t</span> lastsave;                <span class="hljs-comment">/* Unix time of last successful save */</span>    ...&#125;;</code></pre><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数<strong>serverCron</strong>默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是<strong>检查save选项所设置的保存条件是否已经满足</strong>，如果满足的话，就执行bgsave命令</p><h2 id="二、AOF持久化"><a href="#二、AOF持久化" class="headerlink" title="二、AOF持久化"></a>二、AOF持久化</h2><h3 id="1、简介-5"><a href="#1、简介-5" class="headerlink" title="1、简介"></a>1、简介</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，<strong>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的</strong>，如图下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119150042.png" srcset="/img/loading.gif" alt=""></p><p>更多关于AOF持久化的操作可以查<a href="https://nyimac.gitee.io/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/#3%E3%80%81AOF"><strong>Redis学习文档——AOF</strong></a></p><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>AOF持久化功能的实现可以分为<strong>命令追加</strong>（append）、<strong>文件写入</strong>、<strong>文件同步</strong>（sync）三个步骤</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式<strong>将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</strong></p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span>    ...    <span class="hljs-comment">// 缓冲区，本质上是一个动态字符串</span>  sds aof_buf;      <span class="hljs-comment">/* AOF buffer, written before entering the event loop */</span>    ...&#125;;</code></pre><p><strong>步骤解析</strong></p><p>如果客户端向服务器发送以下命令</p><pre><code class="hljs q"><span class="hljs-built_in">set</span> <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span></code></pre><p>那么服务器在执行这个SET命令之后，会将以下<strong>协议内容追加到aof_buf缓冲区的末尾</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119150935.png" srcset="/img/loading.gif" alt=""></p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的<strong>文件事件</strong>负责接收客户端的命令请求，以及向客户端发送命令回复，而<strong>时间事件</strong>则负责执行像serverCron函数这样需要定时运行的函数</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器<strong>每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数</strong>，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</p><h3 id="3、文件的载入与数据还原"><a href="#3、文件的载入与数据还原" class="headerlink" title="3、文件的载入与数据还原"></a>3、文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以<strong>服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态</strong></p><h4 id="还原步骤"><a href="#还原步骤" class="headerlink" title="还原步骤"></a>还原步骤</h4><ul><li><p>创建一个<strong>不带网络连接</strong>的伪客户端（fake client）</p><ul><li>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样</li></ul></li><li><p>从AOF文件中分析并读取出一条写命令</p></li><li><p>使用伪客户端执行被读出的写命令</p></li><li><p>一直执行上面两步，直到AOF文件中的所有写命令都被处理完毕为止</p></li></ul><p><strong>以上过程的流程图如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119153503.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、重写"><a href="#4、重写" class="headerlink" title="4、重写"></a>4、重写</h3><h4 id="为什么需要重写"><a href="#为什么需要重写" class="headerlink" title="为什么需要重写"></a>为什么需要重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，<strong>所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多</strong>，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多</p><p>比如下面执行的命令，都是对list的操作，如果不加以重写，则会将4条操作语句都写入AOF文件中，导致AOF文件体积增大</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119154720.png" srcset="/img/loading.gif" alt=""></p><h4 id="重写的实现"><a href="#重写的实现" class="headerlink" title="重写的实现"></a>重写的实现</h4><p><strong>Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”</strong>，但实际上，AOF文件重写并<strong>不需要对现有的AOF文件进行任何读取、分析或者写入操作</strong>，这个功能是<strong>通过读取服务器当前的数据库状态来实现的</strong></p><p>例如上面执行的语句，<strong>通过重写可以合并为一条语句</strong></p><pre><code class="hljs stylus">rpush list <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c d</code></pre><p>执行该语句后，Redis数据库中数据的状态和执行上面4条语句以后的状态是一样的，但是写入AOF文件时只需写入一条语句，这就大大缩小了AOF文件的体积</p><p><strong>重写过程的伪代码</strong></p><p>重写过程伪代码如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119155315.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119155330.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119155427.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119155437.png" srcset="/img/loading.gif" alt=""></p><p>因为aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令，所以<strong>新AOF文件不会浪费任何硬盘空间</strong></p><h4 id="后台重写（bgrewriteaof）"><a href="#后台重写（bgrewriteaof）" class="headerlink" title="后台重写（bgrewriteaof）"></a>后台重写（bgrewriteaof）</h4><p>为了避免出现AOF重写出现服务器无法处理请求的情况，所以Redis决定<strong>将AOF重写程序放到子进程里执行</strong>，这样做可以有以下两个目的</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而<strong>新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致</strong>（有点像CMS垃圾回收期，在并发清理期间产生的垃圾，没法在本次GC中得到回收）</p><p>为了解决这种数据不一致问题，Redis服务器设置了一个<strong>AOF重写缓冲区</strong>（保存了子进程在重写过程中，主进程执行的操作），这个缓冲区在服务器创建子进程之后开始使用，<strong>当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区</strong>，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119160522.png" srcset="/img/loading.gif" alt=""></p><p>在子进程执行AOF重写期间，<strong>服务器进程需要执行以下三个工作</strong></p><ul><li>执行客户端发来的命令</li><li>将执行后的写命令追加到<strong>AOF缓冲区</strong></li><li>将执行后的写命令追加到<strong>AOF重写缓冲区</strong></li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作</p><ul><li>将<strong>AOF重写缓冲区</strong>中的所有内容写入到新AOF文件中，<strong>这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致</strong></li><li>对新的AOF文件进行改名，<strong>原子地（atomic）覆盖现有的AOF文件</strong>，完成新旧两个AOF文件的替换</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119201211.png" srcset="/img/loading.gif" alt=""></p><h2 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h2><h3 id="1、服务器中的数据库"><a href="#1、服务器中的数据库" class="headerlink" title="1、服务器中的数据库"></a>1、服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redisServer结构的<strong>db数组</strong>中，db数组的每个项都是一个redisDb结构，每个redisDb结构代表一个数据库。在初始化服务器时，程序会根据服务器状态的<strong>dbnum属性来决定应该创建多少个数据库</strong>，默认为16个</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span>...        <span class="hljs-comment">// 数据库</span>    redisDb *db;         <span class="hljs-comment">// 数据库的数量</span>    <span class="hljs-keyword">int</span> dbnum;                      <span class="hljs-comment">/* Total number of configured DBs */</span>    ...    &#125;</code></pre><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span>    <span class="hljs-comment">// 数据库键空间</span>    dict *dict;                 <span class="hljs-comment">/* The keyspace for this DB */</span>    <span class="hljs-comment">// 过期字典</span>    dict *expires;              <span class="hljs-comment">/* Timeout of keys with a timeout set */</span>    dict *blocking_keys;        <span class="hljs-comment">/* Keys with clients waiting for data (BLPOP)*/</span>    dict *ready_keys;           <span class="hljs-comment">/* Blocked keys that received a PUSH */</span>    dict *watched_keys;         <span class="hljs-comment">/* WATCHED keys for MULTI/EXEC CAS */</span>    <span class="hljs-keyword">int</span> id;                     <span class="hljs-comment">/* Database ID */</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> avg_ttl;          <span class="hljs-comment">/* Average TTL, just for stats */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> expires_cursor; <span class="hljs-comment">/* Cursor of the active expire cycle. */</span>    <span class="hljs-built_in">list</span> *defrag_later;         <span class="hljs-comment">/* List of key names to attempt to defrag one by one, gradually. */</span>&#125; redisDb;</code></pre><h3 id="2、数据库键空间"><a href="#2、数据库键空间" class="headerlink" title="2、数据库键空间"></a>2、数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redisDb结构表示，其中，redisDb结构的<strong>dict字典保存了数据库中的所有键值对</strong>，我们将这个字典称为键空间（key space）</p><p><strong>键空间和用户所见的数据库是直接对应的</strong></p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象</li></ul><p>如果我们在空白的数据库中执行以下命令</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122141436.png" srcset="/img/loading.gif" alt=""></p><p>那么在这些命令执行之后，数据库的键空间的结构如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122141457.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、设置键的生存时间或过期时间"><a href="#3、设置键的生存时间或过期时间" class="headerlink" title="3、设置键的生存时间或过期时间"></a>3、设置键的生存时间或过期时间</h3><p>通过<strong>EXPIRE</strong>命令或者<strong>PEXPIRE</strong>命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122141849.png" srcset="/img/loading.gif" alt=""></p><p>通过<strong>EXPIREAT</strong>和<strong>PEXPIREAT</strong>命令，可以设定一个时间戳，该过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键，可以通过<strong>TIME</strong>命令查看UNIX的时间</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122143212.png" srcset="/img/loading.gif" alt=""></p><p><strong>TTL</strong>命令和<strong>PTTL</strong>命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>通过上面的例子，可以看出Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）</p><ul><li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒</li><li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒</li><li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳</li><li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳</li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令<strong>都是使用PEXPIREAT命令来实现的</strong></p><ul><li>无论客户端执行的是以上四个命令中的哪一个，经过转换之后，<strong>最终的执行效果都和执行PEXPIREAT命令一样</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122143614.png" srcset="/img/loading.gif" alt=""></p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的<strong>expires</strong>字典保存了数据库中所有键的过期时间，我们称这个字典为<strong>过期字典</strong></p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span>    ...            <span class="hljs-comment">// 过期字典，用于存放有过期时间的对象</span>    dict *expires;              <span class="hljs-comment">/* Timeout of keys with a timeout set */</span>       ...        &#125; redisDb;</code></pre><ul><li>过期字典的<strong>键</strong>是一个指针，这个指针<strong>指向键空间中的某个键对象</strong>（也即是某个数据库键）</li><li>过期字典的<strong>值</strong>是一个long long类型的整数，这个整数<strong>保存了键所指向的数据库键的过期时间</strong>——一个毫秒精度的UNIX时间戳</li></ul><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL命令以<strong>秒</strong>为单位返回键的剩余生存时间，而PTTL命令则以<strong>毫秒</strong>为单位返回键的剩余生存时间。这两个命令都是<strong>通过计算键的过期时间和当前时间之间的差来实现的</strong></p><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期</p><ul><li>检查给定键是否存在于过期字典<ul><li>如果存在，那么取得键的过期时间</li></ul></li><li>检查当前UNIX时间戳是否大于键的过期时间<ul><li>是的话，那么键已经过期</li><li>不是的话，键未过期</li></ul></li></ul><h3 id="4、删除策略"><a href="#4、删除策略" class="headerlink" title="4、删除策略"></a>4、删除策略</h3><p>通过上面的知识，我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是：<strong>如果一个键过期了，那么它什么时候会被删除呢？</strong></p><p>有以下三种删除策略</p><ul><li><strong>定时删除</strong><ul><li>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，<strong>立即执行对键的删除操作</strong></li></ul></li><li><strong>惰性删除</strong><ul><li>放任键过期不管，但是每次从键空间中<strong>获取键时</strong>，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键</li></ul></li><li><strong>定期删除</strong><ul><li><strong>每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键</strong>。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定</li></ul></li></ul><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p><strong>优点</strong></p><ul><li>定时删除策略<strong>对内存是最友好的</strong><ul><li>通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存</li></ul></li></ul><p><strong>缺点</strong></p><ul><li>它对<strong>CPU时间是最不友好的</strong><ul><li>在过期键比较多的情况下，<strong>删除过期键这一行为可能会占用相当一部分CPU时间</strong>，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响</li></ul></li><li>创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——<strong>并不能高效地处理大量时间事件</strong></li></ul><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除的优缺点和定时删除恰恰相反</p><p><strong>优点</strong></p><ul><li>惰性删除策略对CPU时间来说是最友好的<ul><li>程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作<strong>只会在非做不可的情况下进行</strong>，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间</li></ul></li><li>它对内存是最不友好的<ul><li>如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放</li></ul></li></ul><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除是一种较为综合的删除策略，能够兼顾CPU与内存</p><ul><li>定期删除策略<strong>每隔一段时间执行一次删除过期键操作</strong>，并通过限制删除操作执行的时长和频率来<strong>减少删除操作对CPU时间的影响</strong></li><li>通过定期删除过期键，定期删除策略<strong>有效地减少了</strong>因为过期键而带来的<strong>内存浪费</strong></li></ul><h3 id="5、Redis中的删除策略"><a href="#5、Redis中的删除策略" class="headerlink" title="5、Redis中的删除策略"></a>5、Redis中的删除策略</h3><p>Redis服务器实际使用的是<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由<strong>expireIfNeeded</strong>函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作</li></ul><h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h4><p>过期键的定期删除策略由<strong>activeExpireCycle</strong>函数实现，每当Redis的服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，<strong>分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</strong></p><p>activeExpireCycle函数的工作模式可以总结如下</p><ul><li><p>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</p></li><li><p>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键</p></li><li><p>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作</p></li></ul><h2 id="四、事件"><a href="#四、事件" class="headerlink" title="四、事件"></a>四、事件</h2><h3 id="1、简介-6"><a href="#1、简介-6" class="headerlink" title="1、简介"></a>1、简介</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件</p><ul><li><strong>文件事件</strong>（file event）<ul><li>Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作</li></ul></li><li><strong>时间事件</strong>（time event）<ul><li>Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象</li></ul></li></ul><p><strong>这部分读起来有点难度，后面再进行补充</strong></p><h2 id="五、复制"><a href="#五、复制" class="headerlink" title="五、复制"></a>五、复制</h2><h3 id="1、简介-7"><a href="#1、简介-7" class="headerlink" title="1、简介"></a>1、简介</h3><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119202229.png" srcset="/img/loading.gif" alt=""></p><p>假设现在有两个Redis服务器，地址分别为127.0.0.1:6379和127.0.0.1:1111，如果我们向服务器127.0.0.1:1111发送以下命令</p><pre><code class="hljs angelscript">slaveof <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">1111</span></code></pre><p>那么服务器127.0.0.1:1111将成为127.0.0.1:6379的从服务器，而服务器127.0.0.1:6379则会成为127.0.0.1:1111的主服务器</p><p>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“<strong>数据库状态一致</strong>”，或者简称“一致”</p><h3 id="2、主从复制实现（旧版）"><a href="#2、主从复制实现（旧版）" class="headerlink" title="2、主从复制实现（旧版）"></a>2、主从复制实现（旧版）</h3><p>Redis的复制功能分为<strong>同步</strong>（sync）和<strong>命令传播</strong>（command propagate）两个操作：</p><ul><li><p>同步操作用于<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p></li><li><p>命令传播操作则用于在<strong>主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态</strong></p></li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器<strong>首先需要执行同步操作</strong>，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态</p><p>从服务器对主服务器的同步操作需要通过向主服务器发送<strong>SYNC</strong>命令来完成，SYNC命令的执行步骤如下</p><ul><li><p>从服务器向主服务器发送SYNC命令</p></li><li><p>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，<strong>并使用一个缓冲区记录从现在开始执行的所有写命令</strong></p></li><li><p>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，<strong>从服务器将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</strong></p></li><li><p>主服务器将记录在<strong>缓冲区里面的所有写命令发送给从服务器</strong>，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119213618.png" srcset="/img/loading.gif" alt=""></p><p><strong>虽然SYNC指令可以完成主从复制，但是该指令执行是十分消耗资源的！</strong></p><p>每次执行SYNC命令，主从服务器需要执行以下动作</p><ul><li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源</li><li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li><li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。因为SYNC命令是一个如此耗费资源的操作</li></ul><p><strong>所以Redis有必要保证在真正有需要时才执行SYNC命令</strong></p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，<strong>每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致</strong></p><p>例如下面这种情况</p><p>假设一个主服务器和一个从服务器刚刚完成同步操作，它们的数据库都保存了相同的五个键k1至k5，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119205735.png" srcset="/img/loading.gif" alt=""></p><p>这时，<strong>客户端向主服务器发送命令DEL k3</strong>，那么主服务器在执行完这个DEL命令之后，主从服务器的数据库将出现不一致，如下图所示</p><ul><li>主服务器的数据库已经不再包含键k3，但这个键却仍然包含在从服务器的数据库里面</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119205814.png" srcset="/img/loading.gif" alt=""></p><p>为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行<strong>命令传播</strong>操作</p><ul><li><strong>主服务器会将自己执行的写命令</strong>，也即是造成主从服务器不一致的那条写命令，<strong>发送给从服务器执行</strong>，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li></ul><p>在上面的例子中，<strong>主服务器因为执行了命令DEL k3而导致主从服务器不一致</strong>，所以主服务器将向从服务器发送相同的命令DEL k3。当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201119205917.png" srcset="/img/loading.gif" alt=""></p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>在Redis中，从服务器对主服务器的复制可以分为以下两种情况</p><ul><li><strong>初次复制</strong><ul><li>从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同</li></ul></li><li><strong>断线后重复制</strong><ul><li>处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并<strong>继续复制主服务器</strong></li></ul></li></ul><p>对于初次复制来说，旧版复制功能能够很好地完成任务，但<strong>对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低</strong></p><p><strong>例如下面这种断线重连情况</strong></p><table><thead><tr><th align="center">时间</th><th align="center">主服务器</th><th align="center">从服务器</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">主从服务器完成同步</td><td align="center">主从服务器完成同步</td></tr><tr><td align="center">T2</td><td align="center">执行命令并传播SET key1 val1</td><td align="center">接收主服务器传来的命令并执行SET key1 set1</td></tr><tr><td align="center">T3</td><td align="center">执行命令并传播SET key2 val2</td><td align="center">接收主服务器传来的命令并执行SET key2 set2</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">T1111</td><td align="center">执行命令并传播SET key1111 val1111</td><td align="center">接收主服务器传来的命令并执行SET key1111 set1111</td></tr><tr><td align="center">T1112</td><td align="center"><strong>主从服务器断开连接</strong></td><td align="center"><strong>主从服务器断开连接</strong></td></tr><tr><td align="center">T1113</td><td align="center">执行命令并传播SET key1112 val1112</td><td align="center">断线中，尝试重连</td></tr><tr><td align="center">T1114</td><td align="center">执行命令并传播SET key1113 val1113</td><td align="center">断线中，尝试重连</td></tr><tr><td align="center">T1115</td><td align="center"><strong>主从服务器重新建立连接</strong></td><td align="center"><strong>主从服务器重新建立连接</strong></td></tr><tr><td align="center">T1116</td><td align="center"></td><td align="center">发送SYNC指令</td></tr><tr><td align="center">T1117</td><td align="center">接收SYNC指令，先进行BGSAVE生成RDB文件，<strong>此文件中包含了key1~key1113</strong>。生成后将RDB文件发送给从服务器，并将此期间执行的操作记录在缓冲区中</td><td align="center"></td></tr><tr><td align="center">T1118</td><td align="center"></td><td align="center">接收到RDB文件，进行恢复</td></tr><tr><td align="center">T1119</td><td align="center">主从服务器再次完成同步</td><td align="center">主从服务器再次完成同步</td></tr></tbody></table><p>主从服务器断开连接后，在T1115秒再次建立连接。但<strong>因为这时主从服务器的状态已经不再一致，所以从服务器将向主服务器发送SYNC命令</strong>，而<strong>主服务器会将包含键key1至键key1113的RDB文件发送给从服务器</strong>，从服务器通过接收和载入这个RDB文件来将自己的数据库更新至主服务器数据库当前所处的状态</p><p>虽然再次发送SYNC命令可以让主从服务器重新回到一致状态，但<strong>传送RDB文件这一步实际上并不是非做不可的</strong></p><ul><li>主从服务器在时间T0至时间T1110中一直处于一致状态，<strong>这两个服务器保存的数据大部分都是相同的</strong></li><li>从服务器想要将自己更新至主服务器当前所处的状态，真正需要的是主从服务器连接中断期间，主服务器新添加的key1112、key1113这两个键的数据</li><li>但旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k1112的RDB文件，但<strong>实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的</strong>。并且如上面所说，SYNC操作是非常消耗资源的一种操作，所以要尽量避免不必要的同步操作</li></ul><h3 id="3、主从复制实现（新版）"><a href="#3、主从复制实现（新版）" class="headerlink" title="3、主从复制实现（新版）"></a>3、主从复制实现（新版）</h3><p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用<strong>PSYNC</strong>命令代替SYNC命令来执行复制时的同步操作</p><p>PSYNC命令具有<strong>完整重同步</strong>（full resynchronization）和<strong>部分重同步</strong>（partialresynchronization）两种模式</p><ul><li><strong>完整重同步用于处理初次复制情况</strong><ul><li>完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li></ul></li><li><strong>部分重同步则用于处理断线后重复制情况</strong><ul><li>当从服务器在断线后重新连接主服务器时，如果条件允许，<strong>主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul></li></ul><p>如上面所提到的情况，在新版的主从复制中的流程如下</p><table><thead><tr><th align="center">时间</th><th align="center">主服务器</th><th align="center">从服务器</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">主从服务器完成同步</td><td align="center">主从服务器完成同步</td></tr><tr><td align="center">T2</td><td align="center">执行命令并传播SET key1 val1</td><td align="center">接收主服务器传来的命令并执行SET key1 set1</td></tr><tr><td align="center">T3</td><td align="center">执行命令并传播SET key2 val2</td><td align="center">接收主服务器传来的命令并执行SET key2 set2</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">T1111</td><td align="center">执行命令并传播SET key1111 val1111</td><td align="center">接收主服务器传来的命令并执行SET key1111 set1111</td></tr><tr><td align="center">T1112</td><td align="center"><strong>主从服务器断开连接</strong></td><td align="center"><strong>主从服务器断开连接</strong></td></tr><tr><td align="center">T1113</td><td align="center">执行命令并传播SET key1112 val1112</td><td align="center">断线中，尝试重连</td></tr><tr><td align="center">T1114</td><td align="center">执行命令并传播SET key1113 val1113</td><td align="center">断线中，尝试重连</td></tr><tr><td align="center">T1115</td><td align="center"><strong>主从服务器重新建立连接</strong></td><td align="center"><strong>主从服务器重新建立连接</strong></td></tr><tr><td align="center">T1116</td><td align="center"></td><td align="center"><strong>发送PSYNC指令</strong></td></tr><tr><td align="center">T1117</td><td align="center">向从服务器返回+CONTINUE回复，表示执行部分重同步</td><td align="center"></td></tr><tr><td align="center">T1118</td><td align="center"></td><td align="center">接收+CONTINUE回复，准备部分重同步</td></tr><tr><td align="center">T1119</td><td align="center">向从服务器发送SET key1112 val1112和SET key1113 val1113两条指令</td><td align="center"></td></tr><tr><td align="center">T1120</td><td align="center"></td><td align="center">接收发送过来的两条SET指令，并执行</td></tr><tr><td align="center">T1121</td><td align="center">主从服务器再次完成同步</td><td align="center">主从服务器再次完成同步</td></tr></tbody></table><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120165728.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、部分重同步的实现"><a href="#4、部分重同步的实现" class="headerlink" title="4、部分重同步的实现"></a>4、部分重同步的实现</h3><p>部分重同步功能由以下三个部分构成</p><ul><li>主服务器的<strong>复制偏移量</strong>（replication offset）和从服务器的<strong>复制偏移量</strong></li><li>主服务器的<strong>复制积压缓冲区</strong>（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量</p><ul><li><strong>主服务器</strong>每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li><strong>从服务器</strong>每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul><p>例如下图，主从服务器拥有相同的偏移量</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120170641.png" srcset="/img/loading.gif" alt=""></p><p>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120170747.png" srcset="/img/loading.gif" alt=""></p><p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态</p><ul><li>如果主从服务器处于<strong>一致状态</strong>，那么主从服务器两者的<strong>偏移量总是相同的</strong></li><li>相反，如果主从服务器两者的<strong>偏移量并不相同</strong>，那么说明主从服务器并<strong>未处于一致状态</strong></li></ul><p>如果在主服务器要向从服务器传播长度为33字节的数据之前，从<strong>服务器A断线了</strong>，那么主服务器传播的数据将只有从服务器B和从服务器C能收到，在这之后，主服务器、从服务器B和从服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致，如下图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120171043.png" srcset="/img/loading.gif" alt=""></p><p>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？以上问题的答案都和<strong>复制积压缓冲区</strong>有关</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。当主服务器进行命令传播时，<strong>它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</strong>，如下图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120171229.png" srcset="/img/loading.gif" alt=""></p><p>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且<strong>复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</strong>，如下</p><table><thead><tr><th align="center">偏移量</th><th align="center">…</th><th align="center">1111</th><th align="center">1112</th><th align="center">1113</th><th align="center">1114</th><th align="center">1115</th><th align="center">1116</th><th align="center">1117</th><th align="center">…</th></tr></thead><tbody><tr><td align="center"><strong>字节值</strong></td><td align="center">…</td><td align="center">‘a’</td><td align="center">‘b’</td><td align="center">‘c’</td><td align="center">‘d’</td><td align="center">‘e’</td><td align="center">‘\n’</td><td align="center">‘f’</td><td align="center">…</td></tr></tbody></table><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作</p><ul><li>如果offset偏移量之后的<strong>数据</strong>（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的<strong>数据已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行<strong>完整重同步</strong>操作</li></ul><p>像上面的例子，从服务器A断线重连，向主服务器发送PSYNC指令后，主服务器接受从服务器的偏移量后，检查复制积压缓冲区中是否有偏移量之后的数据。如果有，就将这部分数据发送给从服务，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120171742.png" srcset="/img/loading.gif" alt=""></p><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）</p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li></ul><p>可以通过以下指令查看</p><pre><code class="hljs pgsql"><span class="hljs-keyword">info</span> <span class="hljs-keyword">server</span></code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201121084911.png" srcset="/img/loading.gif" alt=""></p><p>当从服务器对主服务器进行初次复制时，<strong>主服务器会将自己的运行ID传送给从服务器</strong>，而从服务器则会将这个运行ID保存起来</p><p>当从服务器<strong>断线并重新连</strong>上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID</strong>，这主要是用于验证从服务器当前所连的主服务器是否为断线前所连的那个主服务器</p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的运行<strong>ID相同</strong>，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行<strong>部分重同步</strong>操作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行<strong>ID并不相同</strong>，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行<strong>完整重同步</strong>操作</li></ul><h4 id="总结图解"><a href="#总结图解" class="headerlink" title="总结图解"></a>总结图解</h4><p>从服务器与主服务器建立连接后，<strong>主服务器会将自己的id发送给从服务器</strong>，从服务器会保存主服务器的id</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120175242.png" srcset="/img/loading.gif" alt=""></p><p>因为是第一次连接，所以会进行<strong>完整重同步</strong>，从服务器发送SYNC指令，主服务器执行BGSAVE，并将RDB文件发送给从服务。发送后再将缓冲区中的数据发送给从服务器</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120175357.png" srcset="/img/loading.gif" alt=""></p><p>完全重同步后，主从服务器的偏移量相同，此后开始<strong>命令传播</strong>过程</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120175428.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120175455.png" srcset="/img/loading.gif" alt=""></p><p>命令传播过程中，<strong>从服务器A与主服务器断开连接了</strong>，但是主服务器依然在执行客户端发来的指令，依然进行着命令传播</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120175525.png" srcset="/img/loading.gif" alt=""></p><p>从服务器A尝试重连主服务器，某个时刻成功连上了。但是<strong>它需要确定连上的主服务器是不是之前的主服务器</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120191548.png" srcset="/img/loading.gif" alt=""></p><p>确认是之前的主服务器后，开始<strong>部分复制</strong>操作</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120175130.png" srcset="/img/loading.gif" alt=""></p><p><strong>复制完成</strong></p><h4 id="PSYNC命令"><a href="#PSYNC命令" class="headerlink" title="PSYNC命令"></a>PSYNC命令</h4><p>PSYNC命令的调用方法有两种，主服务器通过<strong>PSYNC所带的参数</strong>来判断具体执行哪种重同步操作</p><ul><li>如果<strong>从服务器以前没有复制过任何主服务器</strong>，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送<strong>PSYNC ? -1</strong>命令，主动请求主服务器进行<strong>完整重同步</strong>（因为这时不可能执行部分重同步）</li><li>如果<strong>从服务器已经复制过某个主服务器</strong>，那么从服务器在开始一次新的复制时将向主服务器发送<strong>PSYNC ＜runid＞ ＜offset＞</strong>命令<ul><li>其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作</li></ul></li></ul><p>根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种</p><ul><li><p>如果主服务器返回+<strong>FULLRESYNC</strong> ＜runid＞ ＜offset＞回复，那么表示主服务器将与从服务器执行<strong>完整重同步</strong>操作</p><ul><li>其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，<strong>从服务器会将这个值作为自己的初始化偏移量</strong></li></ul></li><li><p>如果主服务器返回+<strong>CONTINUE</strong>回复，那么表示主服务器将与从服务器执行<strong>部分重同步</strong>操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</p></li><li><p>如果主服务器返回-<strong>ERR</strong>回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作</p></li></ul><p><strong>流程图如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120192712.png" srcset="/img/loading.gif" alt=""></p><h3 id="5、心跳检测"><a href="#5、心跳检测" class="headerlink" title="5、心跳检测"></a>5、心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令，以确保主从服务器连接正常</p><pre><code class="hljs xml">REPLCONE ACK <span class="hljs-tag">&lt;<span class="hljs-name">replication_offset</span>&gt;</span></code></pre><p>其中replication_offset是<strong>从服务器当前的复制偏移量</strong></p><p>发送REPLCONF ACK命令对于主从服务器有<strong>三个作用</strong></p><ul><li>检测主从服务器的网络连接状态</li><li>辅助实现min-slaves选项</li><li>检测命令丢失</li></ul><h4 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h4><p>主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常</p><p>如果主服务器<strong>超过一秒钟</strong>没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</p><ul><li>通过向主服务器发送<strong>INFO replication</strong>命令，在列出的从服务器列表的<strong>lag</strong>一栏中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120194014.png" srcset="/img/loading.gif" alt=""></p><p>在一般情况下，<strong>lag的值应该在0秒或者1秒之间跳动</strong>，如果超过1秒的话，那么说明主从服务器之间的连接出现了故障</p><h4 id="辅助实现min-slaves配置选项"><a href="#辅助实现min-slaves配置选项" class="headerlink" title="辅助实现min-slaves配置选项"></a>辅助实现min-slaves配置选项</h4><p>Redis的<strong>min-slaves-to-write</strong>和<strong>min-slaves-max-lag</strong>两个选项可以防止主服务器在不安全的情况下执行写命令</p><p>比如下面的参数设置</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">3</span><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">10</span></code></pre><p>那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，<strong>主服务器将拒绝执行写命令</strong>，这里的延迟值就是上面提到的INFOreplication命令的lag值</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>如果因为网络故障，<strong>主服务器传播给从服务器的写命令在半路丢失</strong>，那么当从服务器向主服务器发送<strong>REPLCONF ACK</strong>命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p><h2 id="六、Sentinel-哨兵"><a href="#六、Sentinel-哨兵" class="headerlink" title="六、Sentinel(哨兵)"></a>六、Sentinel(哨兵)</h2><h3 id="1、简介-8"><a href="#1、简介-8" class="headerlink" title="1、简介"></a>1、简介</h3><p>Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案</p><ul><li>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120200325.png" srcset="/img/loading.gif" alt=""></p><p>其中<strong>sever1为主服务器</strong>，剩下的为从服务器</p><p>假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4<strong>对主服务器的复制操作将被中止</strong>，并且Sentinel系统会察觉到server1已下线，如下图（下线的服务器用虚线表示）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120200431.png" srcset="/img/loading.gif" alt=""></p><p>当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行<strong>故障转移操作</strong>，具体操作如下</p><ul><li>Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的<strong>从服务器升级为新的主服务器</strong></li><li>Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始<strong>复制新的主服务器</strong>时，故障转移操作执行完毕</li><li>Sentinel还会<strong>继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</strong></li></ul><p>若server1下线，Sentinel系统选择新的主服务器的过程如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120200930.png" srcset="/img/loading.gif" alt=""></p><p>如果此期间server1重新上线了，那么<strong>它会降级成为从服务器</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201120201001.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、启动与初始化"><a href="#2、启动与初始化" class="headerlink" title="2、启动与初始化"></a>2、启动与初始化</h3><p>当一个Sentinel启动时，它需要执行以下步骤</p><ul><li>初始化服务器</li><li>将普通Redis服务器使用的代码<strong>替换成Sentinel专用代码</strong></li><li>初始化Sentinel状态</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ul><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>Sentinel<strong>本质上只是一个运行在特殊模式下的Redis服务器</strong>，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。不过，因为Sentinel执行的工作和普通Redis服务器执行的工作不同，所以Sentinel的初始化过程和普通Redis服务器的初始化过程<strong>并不完全相同</strong></p><p>例如：普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为<strong>Sentinel并不使用数据库</strong>，所以初始化Sentinel时就不会载入RDB文件或者AOF文件</p><h4 id="使用Sentinel专用代码"><a href="#使用Sentinel专用代码" class="headerlink" title="使用Sentinel专用代码"></a>使用Sentinel专用代码</h4><p>启动Sentinel的第二个步骤就是将一部分普通Redis服务器使用的代码<strong>替换成Sentinel专用代码</strong>。比如说，普通Redis服务器使用redis.h/REDIS_SERVERPORT常量的值作为服务器端口</p><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> REDIS_SERVERPORT 6379</span></code></pre><p>而Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口</p><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> REDIS_SENTINEL_PORT 6379</span></code></pre><h4 id="初始化Sentinel状态"><a href="#初始化Sentinel状态" class="headerlink" title="初始化Sentinel状态"></a>初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个<strong>sentinelState结构</strong>（后面简称“Sentinel状态”），这个结构保存了服务器中所有和Sentinel功能有关的状态（服务器的一般状态仍然由redisServer结构保存）。其代码如下</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sentinelState</span> &#123;</span>    <span class="hljs-keyword">char</span> myid[CONFIG_RUN_ID_SIZE+<span class="hljs-number">1</span>]; <span class="hljs-comment">/* This sentinel ID. */</span>    <span class="hljs-comment">// 当前纪元，用于故障转移</span>    <span class="hljs-keyword">uint64_t</span> current_epoch;         <span class="hljs-comment">/* Current epoch. */</span>        <span class="hljs-comment">// 保存了被该哨兵监视的主服务器（多个）</span>    <span class="hljs-comment">// 使用字典，键是主服务器的名字，值是指向主服务器的指针</span>    dict *masters;      <span class="hljs-comment">/* Dictionary of master sentinelRedisInstances.</span><span class="hljs-comment">                           Key is the instance name, value is the</span><span class="hljs-comment">                           sentinelRedisInstance structure pointer. */</span>    <span class="hljs-keyword">int</span> tilt;           <span class="hljs-comment">/* Are we in TILT mode? */</span>    <span class="hljs-keyword">int</span> running_scripts;    <span class="hljs-comment">/* Number of scripts in execution right now. */</span>    <span class="hljs-keyword">mstime_t</span> tilt_start_time;       <span class="hljs-comment">/* When TITL started. */</span>    <span class="hljs-keyword">mstime_t</span> previous_time;         <span class="hljs-comment">/* Last time we ran the time handler. */</span>    <span class="hljs-built_in">list</span> *scripts_queue;            <span class="hljs-comment">/* Queue of user scripts to execute. */</span>    <span class="hljs-keyword">char</span> *announce_ip;  <span class="hljs-comment">/* IP addr that is gossiped to other sentinels if</span><span class="hljs-comment">                           not NULL. */</span>    <span class="hljs-keyword">int</span> announce_port;  <span class="hljs-comment">/* Port that is gossiped to other sentinels if</span><span class="hljs-comment">                           non zero. */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> simfailure_flags; <span class="hljs-comment">/* Failures simulation. */</span>    <span class="hljs-keyword">int</span> deny_scripts_reconfig; <span class="hljs-comment">/* Allow SENTINEL SET ... to change script</span><span class="hljs-comment">                                  paths at runtime? */</span>    <span class="hljs-keyword">char</span> *sentinel_auth_pass;    <span class="hljs-comment">/* Password to use for AUTH against other sentinel */</span>    <span class="hljs-keyword">char</span> *sentinel_auth_user;    <span class="hljs-comment">/* Username for ACLs AUTH against other sentinel. */</span>&#125; sentinel;</code></pre><h4 id="初始化Sentinel状态的masters属性"><a href="#初始化Sentinel状态的masters属性" class="headerlink" title="初始化Sentinel状态的masters属性"></a>初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的<strong>masters字典</strong>记录了所有被Sentinel监视的主服务器的相关信息，其中</p><ul><li><p>字典的键是被监视主服务器的名字</p></li><li><p>字典的值是指向被监视的主服务器的指针</p></li></ul><p>每个sentinelRedisInstance结构（后面简称“<strong>实例结构</strong>”）代表一个<strong>被Sentinel监视的Redis服务器实例</strong>（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentinel</p><p><strong>sentinelRedisInstance结构的代码如下</strong></p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sentinelRedisInstance</span> &#123;</span>    <span class="hljs-keyword">int</span> flags;      <span class="hljs-comment">/* See SRI_... defines */</span>        <span class="hljs-comment">// 实例的名字</span>    <span class="hljs-keyword">char</span> *name;     <span class="hljs-comment">/* Master name from the point of view of this sentinel. */</span>        <span class="hljs-comment">// 实例的运行时id</span>    <span class="hljs-keyword">char</span> *runid;    <span class="hljs-comment">/* Run ID of this instance, or unique ID if is a Sentinel.*/</span>    <span class="hljs-keyword">uint64_t</span> config_epoch;  <span class="hljs-comment">/* Configuration epoch. */</span>        <span class="hljs-comment">// 实例的运行时地址。通过该变量来寻找主服务器</span>    sentinelAddr *addr; <span class="hljs-comment">/* Master host. */</span>        ...            <span class="hljs-comment">// 从服务器的字典</span>    dict *slaves;       <span class="hljs-comment">/* Slaves for this master instance. */</span>    <span class="hljs-comment">// 其他哨兵的字典</span>    dict *sentinels;    <span class="hljs-comment">/* Other sentinels monitoring the same master. */</span> &#125; sentinelRedisInstance;</code></pre><p>其中的addr为一个sentinelAddr类型的指针，sentinelAddr的代码如下</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sentinelAddr</span> &#123;</span>    <span class="hljs-comment">// 实例的ip</span>    <span class="hljs-keyword">char</span> *ip;    <span class="hljs-comment">// 实例的端口号</span>    <span class="hljs-keyword">int</span> port;&#125; sentinelAddr;</code></pre><p>若让哨兵分别监视两个主服务器的实例master1和master2，那么他们的结构如下图所示</p><p>两个主服务器的<strong>实例</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122104850.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122104856.png" srcset="/img/loading.gif" alt=""></p><p>Sentinel状态以及masters<strong>字典</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122104917.png" srcset="/img/loading.gif" alt=""></p><h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建<strong>两个</strong>连向主服务器的异步网络连接</p><ul><li>一个是<strong>命令连接</strong>，这个连接专门用于向主服务器发送命令，并接收命令回复</li><li>一个是<strong>订阅连接</strong>，这个连接专门用于订阅主服务器的<strong>sentinel</strong>:hello频道</li></ul><p><strong>为什么有两个连接？</strong></p><p>一方面，在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失<strong>sentinel</strong>:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息</p><p>另一方面，除了订阅频道之外，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122105405.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、获取主服务器信息"><a href="#3、获取主服务器信息" class="headerlink" title="3、获取主服务器信息"></a>3、获取主服务器信息</h3><p>Sentinel默认会以每十秒一次的频率，通过命令连接<strong>向被监视的主服务器发送INFO命令</strong>，并通过分析INFO命令的<strong>回复</strong>来获取主服务器的当前信息</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122110153.png" srcset="/img/loading.gif" alt=""></p><p>通过分析<strong>主服务器返回的INFO命令回复</strong>，Sentinel可以获取以下两方面的信息</p><ul><li><p>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</p></li><li><p>另一方面是关于主服务器属下所有从服务器的信息，每个<strong>从服务器都由一个”slave”字符串开头的行记录</strong>，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器</p></li></ul><p>Sentinel在分析INFO命令中包含的<strong>从服务器</strong>信息时，会检查从服务器对应的实例结构是否已经存在于slaves字典</p><ul><li>如果从服务器对应的实例结构已经存在，那么Sentinel对从服务器的实例结构进行更新</li><li>如果从服务器对应的实例结构不存在，那么说明这个从服务器是新发现的从服务器，Sentinel会在slaves字典中为这个从服务器新创建一个实例结构</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122110831.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、获取从服务器信息"><a href="#4、获取从服务器信息" class="headerlink" title="4、获取从服务器信息"></a>4、获取从服务器信息</h3><p>当Sentinel发现主服务器有<strong>新的从服务器</strong>出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的<strong>命令连接和订阅连接</strong></p><p>举个例子，对于下图所示的主从服务器关系来说</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122110153.png" srcset="/img/loading.gif" alt=""></p><p>Sentinel将对slave0、slave1和slave2<strong>三个从服务器分别创建命令连接和订阅连接</strong>，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122111758.png" srcset="/img/loading.gif" alt=""></p><h3 id="5、接收主从服务器的频道信息"><a href="#5、接收主从服务器的频道信息" class="headerlink" title="5、接收主从服务器的频道信息"></a>5、接收主从服务器的频道信息</h3><p>当Sentinel与一个主服务器或者从服务器建立起<strong>订阅连接</strong>之后，Sentinel就会通过订阅连接，向服务器发送以下命令</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122111958.png" srcset="/img/loading.gif" alt=""></p><p>Sentinel对<strong>sentinel</strong>:hello频道的订阅会一直持续到Sentinel与服务器的连接断开为止</p><p>这也就是说，对于每个与Sentinel连接的服务器，Sentinel既通过<strong>命令连接</strong>向服务器的<strong>sentinel</strong>:hello频道发送信息，又通过<strong>订阅连接</strong>从服务器的<strong>sentinel</strong>:hello频道接收信息</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122112131.png" srcset="/img/loading.gif" alt=""></p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于<strong>更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知</strong></p><p>举个例子，假设现在有sentinel1、sentinel2、sentinel3<strong>三个Sentinel</strong>在监视同一个服务器，那么当sentinel1向服务器的<strong>sentinel</strong>:hello频道发送一条信息时，<strong>所有</strong>订阅了<strong>sentinel</strong>:hello频道的Sentinel（包括sentinel1自己在内）都会收到这条信息，如图下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122112310.png" srcset="/img/loading.gif" alt=""></p><h4 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h4><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，还保存了<strong>所有同样监视这个主服务器的其他Sentinel的资料</strong></p><ul><li>键是其中一个Sentinel的名字，格式为ip:port</li><li>值则是键所对应Sentinel的实例结构</li></ul><p>当一个Sentinel接收到其他Sentinel发来的信息时（我们称呼发送信息的Sentinel为<strong>源Sentinel</strong>，接收信息的Sentinel为<strong>目标Sentinel</strong>），目标Sentinel会从信息中分析并提取出以下<strong>两方面参数</strong></p><ul><li><p>与Sentinel有关的参数</p><ul><li>源Sentinel的IP地址、端口号、运行ID和配置纪元</li></ul></li><li><p>与主服务器有关的参数</p><ul><li>源Sentinel正在监视的主服务器的名字、IP地址、端口号和配置纪元</li></ul></li></ul><p>根据信息中提取出的主服务器参数，目标Sentinel会在自己的Sentinel状态的masters字典中查找相应的主服务器实例结构，然后根据提取出的Sentinel参数，检查主服务器实例结构的sentinels字典中，源Sentinel的实例结构是否存在</p><p>因为一个Sentinel可以通过分析接收到的频道信息来获知其他Sentinel的存在，并通过发送频道信息来让其他Sentinel知道自己的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，<strong>监视同一个主服务器的多个Sentinel可以自动发现对方</strong></p><h4 id="创建Sentinel之间的命令连接"><a href="#创建Sentinel之间的命令连接" class="headerlink" title="创建Sentinel之间的命令连接"></a>创建Sentinel之间的命令连接</h4><p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还<strong>会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接</strong>（互相连接）。<strong>这是为了能够让多个哨兵中保存的主从服务器信息一致</strong>。最终监视同一主服务器的多个Sentinel将形成相互连接的网络，如下图所示</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122124243.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意：Sentinel之间不会创建订阅连接</strong></p><h3 id="出现故障的解决方案"><a href="#出现故障的解决方案" class="headerlink" title="出现故障的解决方案"></a>出现故障的解决方案</h3><h3 id="6、检测主观下线状态"><a href="#6、检测主观下线状态" class="headerlink" title="6、检测主观下线状态"></a>6、检测主观下线状态</h3><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122125242.png" srcset="/img/loading.gif" alt=""></p><p>实例对PING命令的<strong>回复</strong>可以分为以下两种情况</p><ul><li><strong>有效回复</strong><ul><li>实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种</li></ul></li><li><strong>无效回复</strong><ul><li>实例返回除+PONG、-LOADING、-MASTERDOWN三种回复<strong>之外</strong>的其他回复，或者在指定时限内没有返回任何回复</li></ul></li></ul><p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经<strong>进入主观下线状态</strong></p><h3 id="7、检查客观下线状态"><a href="#7、检查客观下线状态" class="headerlink" title="7、检查客观下线状态"></a>7、检查客观下线状态</h3><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，<strong>它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态</strong>（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201122130223.png" srcset="/img/loading.gif" alt=""></p><h3 id="8、选举领头Sentinel"><a href="#8、选举领头Sentinel" class="headerlink" title="8、选举领头Sentinel"></a>8、选举领头Sentinel</h3><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，<strong>选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作</strong></p><p>选举规则如下</p><ul><li><p>所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel</p></li><li><p>每次进行领头Sentinel<strong>选举之后</strong>，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的</p></li><li><p>在一个配置纪元里面，<strong>所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会</strong>，并且局部领头一旦设置，在这个配置纪元里面就不能再更改</p></li><li><p>每个<strong>发现主服务器进入客观下线</strong>的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</p></li><li><p>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel</p></li><li><p>Sentinel设置局部领头Sentinel的规则是<strong>先到先得</strong></p><ul><li>最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝</li></ul></li><li><p>目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</p></li><li><p>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel</p></li><li><p>如果有<strong>某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel</strong>，那么这个Sentinel成为领头Sentinel</p><ul><li>举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成为领头Sentinel</li></ul></li><li><p>因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel</p></li><li><p>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后<strong>再次进行选举，直到选出领头Sentinel为止</strong></p></li></ul><h3 id="9、故障转移"><a href="#9、故障转移" class="headerlink" title="9、故障转移"></a>9、故障转移</h3><p>在选举产生出领头Sentinel之后，<strong>领头Sentinel将对已下线的主服务器执行故障转移操作</strong>，该操作包含以下三个步骤</p><ul><li>在已下线主服务器<strong>属下</strong>的所有从服务器里面，<strong>挑选出一个从服务器，并将其转换为主服务器</strong></li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器</li></ul><h4 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h4><p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令（断开与主服务器的连接），<strong>将这个从服务器转换为主服务器</strong></p><p>领头Sentinel筛选新主服务器的规则如下</p><ul><li><strong>删除列表中所有处于下线或者断线状态的从服务器</strong>，这可以保证列表中剩余的从服务器都是正常在线的</li><li><strong>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器</strong>，这可以保证列表中剩余的从服务器都是最近成功进行过通信的</li><li>删除所有与已下线主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器</li></ul><p>之后，领头Sentinel将根据从服务器的<strong>优先级</strong>，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器</p><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的<strong>所有从服务器去复制新的主服务器</strong>，这一动作可以通过向从服务器发送<strong>SLAVEOF</strong>命令来实现</p><h4 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h4><p>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当<strong>server1重新上线</strong>时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</p><h2 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h2><p><a href="https://nyimac.gitee.io/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/#%E4%BA%94%E3%80%81Redis%E4%BA%8B%E5%8A%A1"><strong>Redis事务的基本使用</strong></a></p><h3 id="1、简介-9"><a href="#1、简介-9" class="headerlink" title="1、简介"></a>1、简介</h3><p>Redis通过<strong>MULTI、EXEC、WATCH</strong>等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且<strong>在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求</strong>，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求</p><h3 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h3><p>一个事务从开始到结束通常会经历以下<strong>三个阶段</strong></p><ul><li>事务开始</li><li>命令入队</li><li>事务执行</li></ul><h4 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h4><p><strong>MULTI</strong>命令的执行标志着事务的开始</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123095602.png" srcset="/img/loading.gif" alt=""></p><p>MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在<strong>客户端状态的flags</strong>属性中打开REDIS_MULTI标识来完成的</p><h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><p>当一个客户端处于<strong>非事务状态</strong>时，这个客户端发送的命令会立即被服务器执行。但是当切换为<strong>事务状态</strong>后，服务器会根据这个客户端发来的不同命令执行不同的操作</p><ul><li>如果客户端发送的命令为<strong>EXEC、DISCARD、WATCH、MULTI</strong>四个命令的其中一个，那么服务器立即执行这个命令</li><li>如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令<strong>以外的其他命令</strong>，那么服务器并不立即执行这个命令，而是将这个<strong>命令放入一个事务队列里面，然后向客户端返回QUEUED回复</strong></li></ul><p>服务器判断命令是该入队还是该立即执行的过程如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123095940.png" srcset="/img/loading.gif" alt=""></p><h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的<strong>mstate</strong>属性里面</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">client</span> &#123;</span>        ...            <span class="hljs-comment">// 事务状态    </span>    multiState mstate;      <span class="hljs-comment">/* MULTI/EXEC state */</span>        ...        &#125; client;</code></pre><p>事务状态包含一个<strong>事务队列</strong>，以及一个已入队命令的<strong>计数器</strong>（也可以说是事务队列的长度）</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiState</span> &#123;</span>    <span class="hljs-comment">// 事务队列，存放MULTI命令之后的命令</span>    multiCmd *commands;     <span class="hljs-comment">/* Array of MULTI commands */</span>        <span class="hljs-comment">// 命令的数量</span>    <span class="hljs-keyword">int</span> count;              <span class="hljs-comment">/* Total number of MULTI commands */</span>        <span class="hljs-keyword">int</span> cmd_flags;          <span class="hljs-comment">/* The accumulated command flags OR-ed together.</span><span class="hljs-comment">                               So if at least a command has a given flag, it</span><span class="hljs-comment">                               will be set in this field. */</span>    <span class="hljs-keyword">int</span> cmd_inv_flags;      <span class="hljs-comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span><span class="hljs-comment">                               is possible to know if all the commands have a</span><span class="hljs-comment">                               certain flag. */</span>    <span class="hljs-keyword">int</span> minreplicas;        <span class="hljs-comment">/* MINREPLICAS for synchronous replication */</span>    <span class="hljs-keyword">time_t</span> minreplicas_timeout; <span class="hljs-comment">/* MINREPLICAS timeout as unixtime. */</span>&#125; multiState;</code></pre><p>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiCmd</span> &#123;</span>    <span class="hljs-comment">// 参数</span>    robj **argv;        <span class="hljs-comment">// 命令数量</span>    <span class="hljs-keyword">int</span> argc;        <span class="hljs-comment">// 命令指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> *<span class="hljs-title">cmd</span>;</span>&#125; multiCmd;</code></pre><p>事务队列以先进先出（FIFO）的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面</p><p><strong>例如</strong>以下指令在执行后，事务队列的结构如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123101417.png" srcset="/img/loading.gif" alt=""></p><p><strong>结构</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123101433.png" srcset="/img/loading.gif" alt=""></p><h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>当一个处于<strong>事务状态的客户端向服务器发送EXEC命令时</strong>，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端    </p><h3 id="3、-WATCH命令的实现"><a href="#3、-WATCH命令的实现" class="headerlink" title="3、 WATCH命令的实现"></a>3、 WATCH命令的实现</h3><p>WATCH命令是一个<strong>乐观锁</strong>（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键<strong>是否至少有一个已经被修改过了</strong>，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复</p><p>如此出，执行watch指令监视name，监视期间name被另一个客户端所修改。<strong>该客户端执行事务失败</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123102913.png" srcset="/img/loading.gif" alt=""></p><h4 id="使用WATCH命令监视数据库键"><a href="#使用WATCH命令监视数据库键" class="headerlink" title="使用WATCH命令监视数据库键"></a>使用WATCH命令监视数据库键</h4><p>每个Redis数据库都保存着一个<strong>watched_keys</strong>字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span>        ...            <span class="hljs-comment">// 被监视的键    </span>    dict *watched_keys;         <span class="hljs-comment">/* WATCHED keys for MULTI/EXEC CAS */</span>        ...        &#125; redisDb;</code></pre><p>通过watched_keys字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键</p><h4 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h4><p>所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用<strong>touchWatchKey</strong>函数对watched_keys字典进行检查，查看是否有客户端正在<strong>监视</strong>刚刚被命令<strong>修改过的数据库键</strong>，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的<strong>REDIS_DIRTY_CAS标识打开</strong>，表示该客户端的事务安全性已经被破坏</p><p>touchWatchKey的伪代码如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123103628.png" srcset="/img/loading.gif" alt=""></p><h4 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h4><p>当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端<strong>是否打开了REDIS_DIRTY_CAS标识</strong>来决定是否执行事务</p><ul><li>如果客户端的REDIS_DIRTY_CAS标识已经被打开，那么说明客户端所监视的键当中，<strong>至少有一个键已经被修改过了</strong>，在这种情况下，客户端提交的事务已经<strong>不再安全</strong>，所以服务器会拒绝执行客户端提交的事务</li><li>如果客户端的REDIS_DIRTY_CAS标识没有被打开，那么说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务</li></ul><p>根据REDIS_DIRTY_CAS表示来判断是否执行事务的流程图如下</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201123103819.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2020/11/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>代理模式给某一个对象提供一个<strong>代理对象</strong>，并由代理对象控制对原对象的引用。同时代理对象可以调用被代理对象的方法，并对其进行增强。可以总结为<strong>代理对象 = 增强代码 + 目标对象（原对象）</strong></p><h2 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h2><p>疫情期间很多公司破产，导致很多劳动者都失业了，小文也是其中之一。公司拖欠小文的工资一直未能下发。小文希望通过劳动仲裁来要回属于自己的工资，所以和公司打官司。基本的仲裁步骤小文都懂，大概有：准备劳动仲裁申请书、收集证据、提交申请、开庭答辩等等，但是小文是第一次进行劳动仲裁，对这些具体的操作没什么经验，同时自己在这期间又有了新的工作，很难抽出时间去进行劳动仲裁。这时小文就掏钱找了一位律师，这位<strong>律师就相当于代理对象</strong>。律师替小文准备仲裁申请、提交申请、开庭后帮小文进行辩论阐述等等，<strong>律师不仅仅是按着仲裁需要的步骤做了，而且每一步都做的比小文更好，这就是对被代理对象方法的增强</strong></p><h2 id="3、场景"><a href="#3、场景" class="headerlink" title="3、场景"></a>3、场景</h2><p>面向切面编程中就用到了代理模式，具体的内容后面有机会再详细介绍吧</p><h1 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h1><h2 id="1、代码"><a href="#1、代码" class="headerlink" title="1、代码"></a>1、代码</h2><p>我们用静态代理来实现上面例子</p><p><strong>定义接口</strong>:无论是谁进行劳动仲裁，都需要按着这个流程执行</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArbitrationStep</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 准备仲裁申请</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepareApp</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 收集证据</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">collectEvi</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 开庭答辩</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debate</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>定义被代理类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoWen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ArbitrationStep</span> </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareApp</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"准备仲裁申请！"</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectEvi</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"收集证据！"</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debate</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"开庭答辩！"</span>);   &#125;&#125;</code></pre><p><strong>定义代理类</strong></p><p>可以看到代理类中不仅执行了被代理的方法，同时还对其方法进行了一定的增强</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LawyerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ArbitrationStep</span> </span>&#123;   <span class="hljs-keyword">private</span> XiaoWen xiaoWen;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LawyerProxy</span><span class="hljs-params">(XiaoWen xiaoWen)</span> </span>&#123;      <span class="hljs-keyword">this</span>.xiaoWen = xiaoWen;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareApp</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"律师听取小文的想法"</span>);      xiaoWen.prepareApp();      System.out.println(<span class="hljs-string">"律师对申请进行修改"</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectEvi</span><span class="hljs-params">()</span> </span>&#123;      xiaoWen.collectEvi();      System.out.println(<span class="hljs-string">"律师对证据进行整理"</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debate</span><span class="hljs-params">()</span> </span>&#123;      xiaoWen.debate();      System.out.println(<span class="hljs-string">"律师更详细的阐述"</span>);   &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tribunal</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      XiaoWen xiaoWen = <span class="hljs-keyword">new</span> XiaoWen();      System.out.println(<span class="hljs-string">"小文委托律师帮忙进行劳动仲裁"</span>);      LawyerProxy proxy = <span class="hljs-keyword">new</span> LawyerProxy(xiaoWen);      System.out.println(<span class="hljs-string">"-------第一步-------"</span>);      proxy.prepareApp();      System.out.println(<span class="hljs-string">"-------第二步-------"</span>);      proxy.collectEvi();      System.out.println(<span class="hljs-string">"-------第三步-------"</span>);      proxy.debate();      System.out.println();      System.out.println(<span class="hljs-string">"仲裁结束"</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">小文委托律师帮忙进行劳动仲裁-------第一步-------律师听取小文的想法准备仲裁申请！律师对申请进行修改-------第二步-------收集证据！律师对证据进行整理-------第三步-------开庭答辩！律师更详细的阐述仲裁结束</code></pre><h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><p>通过上面的代码可以总结出静态代理的步骤</p><ul><li>定义接口<ul><li>被代理类和代理类<strong>都需要实现该接口</strong></li></ul></li><li>定义被代理类<ul><li>实现上面定义的接口</li></ul></li><li>定义代理类<ul><li>实现上面定义的接口</li><li>创建被代理对象<ul><li>调用方法时需要<strong>调用被代理对象的方法，同时自己可以对方法进行增加</strong></li></ul></li></ul></li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201013134339.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、存在的问题"><a href="#3、存在的问题" class="headerlink" title="3、存在的问题"></a>3、存在的问题</h2><p>如果一个类需要被代理，就得去创建一个代理类。如果被代理的类过多，这样就需要手动创建很多代理类。为了解决这个问题，便有了动态代理</p><h1 id="三、基于Java反射的动态代理"><a href="#三、基于Java反射的动态代理" class="headerlink" title="三、基于Java反射的动态代理"></a>三、基于Java反射的动态代理</h1><h2 id="1、反射与类加载"><a href="#1、反射与类加载" class="headerlink" title="1、反射与类加载"></a>1、反射与类加载</h2><p>在这之前我们需要先了解<a href="https://nyimac.gitee.io/2020/10/13/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/#%E4%BA%8C%E3%80%81%E5%8F%8D%E5%B0%84"><strong>Java反射</strong></a>与<a href="https://nyimac.gitee.io/2020/06/08/JVM%E5%AD%A6%E4%B9%A0/#4%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><strong>类加载</strong></a></p><p>同时还可以参考<a href="https://www.zhihu.com/question/20794107/answer/658139129" target="_blank" rel="noopener"><strong>知乎回答——Java 动态代理作用是什么？</strong></a>(膜拜大佬啊！)</p><h2 id="2、使用反射实现动态代理"><a href="#2、使用反射实现动态代理" class="headerlink" title="2、使用反射实现动态代理"></a>2、使用反射实现动态代理</h2><p>接着上面的劳动仲裁的例子，不过这次我们用动态代理去实现</p><p><strong>但是需要用到Proxy类的两个静态方法</strong></p><ul><li><strong>getProxyClass</strong><ul><li>这个方法， 会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但<strong>新的Class对象带有构造器，是可以创建对象的</strong></li></ul></li><li><strong>newProxyInstance</strong>（一般直接用这个）<ul><li>封装了得到代理类Class对象、构造函数等细节，直接返回了代理对象</li></ul></li></ul><p><strong>接口和被代理类不变</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArbitrationStep</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 准备仲裁申请</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepareApp</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 收集证据</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">collectEvi</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 开庭答辩</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debate</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoWen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ArbitrationStep</span> </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareApp</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"准备仲裁申请！"</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectEvi</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"收集证据！"</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debate</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"开庭答辩！"</span>);   &#125;&#125;</code></pre><h3 id="通过反射获得代理对象"><a href="#通过反射获得代理对象" class="headerlink" title="通过反射获得代理对象"></a>通过反射获得代理对象</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tribunal2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;      <span class="hljs-comment">// 获取代理类的Class对象</span>      Class&lt;?&gt; proxyClazz = Proxy.getProxyClass(ArbitrationStep<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(), <span class="hljs-title">ArbitrationStep</span>.<span class="hljs-title">class</span>)</span>;      <span class="hljs-comment">// 获得构造函数</span>      Constructor&lt;?&gt; constructor = proxyClazz.getConstructor(InvocationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-comment">// 创建代理对象</span>      ArbitrationStep lawyerProxy = (ArbitrationStep) constructor.newInstance(<span class="hljs-keyword">new</span> InvocationHandler() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;            <span class="hljs-comment">// 创建被代理对象，用于调用方法</span>            XiaoWen xiaoWen = <span class="hljs-keyword">new</span> XiaoWen();                         <span class="hljs-comment">// 通过invoke方法调用了被代理对象的方法</span>            Object invoke = method.invoke(xiaoWen, args);                         <span class="hljs-comment">// 每个步骤都让律师帮忙处理</span>            System.out.println(<span class="hljs-string">"律师帮忙处理！"</span>);            <span class="hljs-keyword">return</span> invoke;         &#125;      &#125;);      <span class="hljs-comment">// 通过代理对象调用方法</span>      System.out.println(<span class="hljs-string">"-------第一步-------"</span>);      lawyerProxy.prepareApp();      System.out.println(<span class="hljs-string">"-------第二步-------"</span>);      lawyerProxy.collectEvi();      System.out.println(<span class="hljs-string">"-------第三步-------"</span>);      lawyerProxy.debate();      System.out.println();      System.out.println(<span class="hljs-string">"仲裁结束"</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">-------第一步-------准备仲裁申请！律师帮忙处理！-------第二步-------收集证据！律师帮忙处理！-------第三步-------开庭答辩！律师帮忙处理！仲裁结束</code></pre><h3 id="自己封装获得代理对象的方法"><a href="#自己封装获得代理对象的方法" class="headerlink" title="自己封装获得代理对象的方法"></a>自己封装获得代理对象的方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tribunal3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException </span>&#123;      XiaoWen xiaoWen = <span class="hljs-keyword">new</span> XiaoWen();      <span class="hljs-comment">// 获得代理对象</span>      ArbitrationStep lawyerProxy = (ArbitrationStep) getProxy(xiaoWen);             <span class="hljs-comment">// 通过代理对象调用方法</span>      System.out.println(<span class="hljs-string">"-------第一步-------"</span>);      lawyerProxy.prepareApp();      System.out.println(<span class="hljs-string">"-------第二步-------"</span>);      lawyerProxy.collectEvi();      System.out.println(<span class="hljs-string">"-------第三步-------"</span>);      lawyerProxy.debate();      System.out.println();      System.out.println(<span class="hljs-string">"仲裁结束"</span>);   &#125;   <span class="hljs-comment">// 该方法返回一个代理对象</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;      <span class="hljs-comment">// target为被代理对象，得到其代理类的Class对象</span>      Class&lt;?&gt; proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());      <span class="hljs-comment">// 获得构造函数</span>      Constructor&lt;?&gt; constructor = proxyClazz.getConstructor(InvocationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-comment">// 获得代理对象</span>      Object targetProxy = constructor.newInstance(<span class="hljs-keyword">new</span> InvocationHandler() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;            Object invoke = method.invoke(target, args);            System.out.println(<span class="hljs-string">"代理类增强方法"</span>);            <span class="hljs-keyword">return</span> invoke;         &#125;      &#125;);      <span class="hljs-keyword">return</span> targetProxy;   &#125;&#125;</code></pre><p>我们自己编写了一个getProxy方法，传入被代理的对象，返回一个代理对象。</p><h3 id="通过newProxyInstance-获得代理对象"><a href="#通过newProxyInstance-获得代理对象" class="headerlink" title="通过newProxyInstance()获得代理对象"></a><strong>通过newProxyInstance()获得代理对象</strong></h3><p>上面的getProxy方法返回代理对象的过程是我们自己写的，通过Proxy类的<strong>newProxyInstance()</strong>可以直接返回代理对象</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxyByProxyMethod</span><span class="hljs-params">(Object target)</span> </span>&#123;   <span class="hljs-comment">// 直接返回代理对象</span>   <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="hljs-keyword">new</span> InvocationHandler() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;         Object invoke = method.invoke(target, args);         System.out.println(<span class="hljs-string">"代理对象增强方法"</span>);         <span class="hljs-keyword">return</span> invoke;      &#125;   &#125;);&#125;</code></pre><p><strong>看看newProxyInstance帮我们做了些什么工作</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><span class="hljs-function"><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span></span><span class="hljs-function"><span class="hljs-params">                                      InvocationHandler h)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalArgumentException</span><span class="hljs-function"></span>&#123;         Objects.requireNonNull(h);    <span class="hljs-comment">// 下面这一段其实就是getProxyClass方法的内部实现</span>    <span class="hljs-comment">// --------------------------------------------------------------</span>    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();    <span class="hljs-keyword">final</span> SecurityManager sm = System.getSecurityManager();    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Look up or generate the designated proxy class.</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// 获得接口加上构造函数后的Class对象</span>    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    <span class="hljs-comment">// ----------------------------------------------------------------</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">     * Invoke its constructor with the designated invocation handler.</span><span class="hljs-comment">     */</span>        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        <span class="hljs-comment">// 获得构造函数</span>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);                <span class="hljs-keyword">final</span> InvocationHandler ih = h;        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;            AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    cons.setAccessible(<span class="hljs-keyword">true</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;            &#125;);        &#125;                <span class="hljs-comment">// 返回代理对象</span>        <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;h&#125;);            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;        Throwable t = e.getCause();        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;            <span class="hljs-keyword">throw</span> (RuntimeException) t;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(t.toString(), t);        &#125;    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);    &#125;&#125;</code></pre><p>我们自己获取代理对象的步骤是</p><ul><li>通过<strong>getProxyClass</strong>获得<strong>代理对象的Class对象</strong>（接口+对应的构造函数）</li><li>通过Class对象调用得到构造方法</li><li>构造方法去创建实例<ul><li>构造方法传入InvocationHandler实例，需要实现其invoke方法</li></ul></li></ul><p>newProxyInstance帮我们获取代理的步骤和上面类似，只不过Class对象是直接通过<strong>getProxyClass0(loader, intfs)</strong>来获取的。而我们自己封装的代码中，使用的是getProxyClass方法。但是该方法最终还是调用的getProxyClass0(loader, intfs)来获取的Class对象</p><p><strong>getProxyClass方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,                                     Class&lt;?&gt;... interfaces)    <span class="hljs-keyword">throws</span> IllegalArgumentException&#123;    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();    <span class="hljs-keyword">final</span> SecurityManager sm = System.getSecurityManager();    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    <span class="hljs-keyword">return</span> getProxyClass0(loader, intfs);&#125;</code></pre><p><strong>newProxynewInstance方法的前面部分的代码</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201013180152.png" srcset="/img/loading.gif" alt=""></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3、如何实现方法增强"><a href="#3、如何实现方法增强" class="headerlink" title="3、如何实现方法增强"></a>3、如何实现方法增强</h2><p>上面的例子确实将被代理对象的方法增强了，但这是如何实现的呢</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p>我们在获得代理类构造器的时候，传入了InvocationHandler</p><pre><code class="hljs java">Constructor&lt;?&gt; constructor = proxyClazz.getConstructor(InvocationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><p>InvocationHandler是一个<strong>接口，内部只有一个方法invoke</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable</span>;&#125;</code></pre><p>在通过constructor获取代理对象时，newInstance方法需要传入一个invocationHandler的实例，这个实例重写了invoke方法，就是<strong>通过它代理对象增强了被代理对象的方法</strong></p><pre><code class="hljs java">Object targetProxy = constructor.newInstance(<span class="hljs-keyword">new</span> InvocationHandler() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;         <span class="hljs-comment">// 调用被代理对象的对应方法</span>         <span class="hljs-comment">// target 被代理对象</span>         <span class="hljs-comment">// args 方法需要的参数</span>         Object invoke = method.invoke(target, args);         System.out.println(<span class="hljs-string">"代理类增强方法"</span>);         <span class="hljs-keyword">return</span> invoke;      &#125;   &#125;);   <span class="hljs-keyword">return</span> targetProxy;&#125;</code></pre><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a><strong>图解</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201013160426.png" srcset="/img/loading.gif" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>调用代理对象的方法时，<strong>实际上调用的是InvocationHandler的invoke方法</strong>，这个方法内部不仅调用了被代理对象的方法，还可以增加其他功能</p><h2 id="4、为什么必须实现接口"><a href="#4、为什么必须实现接口" class="headerlink" title="4、为什么必须实现接口"></a>4、为什么必须实现接口</h2><p>通过</p><pre><code class="hljs java">lawyerProxy.getClass().getSuperclass()</code></pre><p>可以获得代理对象的父类，可以看到其父类为</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">reflect</span>.<span class="hljs-title">Proxy</span></span></code></pre><p>也就是无论是什么<strong>代理类，都会继承自Proxy</strong>，而Java又是<strong>单继承</strong>的，所以想要被代理对象与代理对象产生联系，就只能通过接口来实现了</p><h1 id="四、基于CGLib的动态代理"><a href="#四、基于CGLib的动态代理" class="headerlink" title="四、基于CGLib的动态代理"></a>四、基于CGLib的动态代理</h1><p>Java动态代理是<strong>面向接口</strong>的代理模式，如果没有接口，但是想要去实现动态代理，就需要用到CGLib来进行动态代理了</p><p>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类</p><h2 id="1、使用CGLib实现动态代理"><a href="#1、使用CGLib实现动态代理" class="headerlink" title="1、使用CGLib实现动态代理"></a>1、使用CGLib实现动态代理</h2><p><strong>被代理的类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoWen</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareApp</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"准备仲裁申请"</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectEvi</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"收集证据"</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debate</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"开庭辩论"</span>);   &#125;&#125;</code></pre><p><strong>自定义拦截器实现MethodInterceptor接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LawyerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;      <span class="hljs-comment">// 前置增强</span>      System.out.println(<span class="hljs-string">"律师给出建议"</span>);      <span class="hljs-comment">// 被代理类执行的方法（被增强的方法）</span>      <span class="hljs-comment">// 注意这里是调用invokeSuper而不是invoke，否则死循环;</span>      <span class="hljs-comment">// methodProxy.invokeSuper执行的是原始类的方法;</span>      <span class="hljs-comment">// method.invoke执行的是子类的方法;</span>      Object invoke = methodProxy.invokeSuper(o, objects);      <span class="hljs-comment">// 后置增强</span>      System.out.println(<span class="hljs-string">"律师帮忙"</span>);      <span class="hljs-keyword">return</span> invoke;   &#125;&#125;</code></pre><p><strong>使用Enhancer创建代理对象</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 创建增强器</span>      Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();      <span class="hljs-comment">// 传入被代理的Class对象（作为代理对象的父类）</span>      enhancer.setSuperclass(XiaoWen<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-comment">// 设置回调函数，传入自定义的拦截器</span>      enhancer.setCallback(<span class="hljs-keyword">new</span> LawyerInterceptor());      <span class="hljs-comment">// 获取代理对象</span>      XiaoWen proxy = (XiaoWen) enhancer.create();      System.out.println(<span class="hljs-string">"小文委托律师帮忙进行劳动仲裁"</span>);      System.out.println(<span class="hljs-string">"-------第一步-------"</span>);      proxy.prepareApp();      System.out.println(<span class="hljs-string">"-------第二步-------"</span>);      proxy.collectEvi();      System.out.println(<span class="hljs-string">"-------第三步-------"</span>);      proxy.debate();      System.out.println();      System.out.println(<span class="hljs-string">"仲裁结束"</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs brainfuck"><span class="hljs-comment">小文委托律师帮忙进行劳动仲裁</span><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">第一步</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">律师给出建议</span><span class="hljs-comment">准备仲裁申请</span><span class="hljs-comment">律师帮忙</span><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">第二步</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">律师给出建议</span><span class="hljs-comment">收集证据</span><span class="hljs-comment">律师帮忙</span><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">第三步</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">律师给出建议</span><span class="hljs-comment">开庭辩论</span><span class="hljs-comment">律师帮忙</span><span class="hljs-comment"></span><span class="hljs-comment">仲裁结束</span></code></pre><h2 id="2、CGLib实现原理"><a href="#2、CGLib实现原理" class="headerlink" title="2、CGLib实现原理"></a>2、CGLib实现原理</h2><p>CGLib可以为没有实现接口的类创建代理类。其原理是CGLib底层使用了ASM框架，该框架可以通过修改字节码，来创建一个被代理类的子类，也就是代理类。并在子类中采用方法拦截的技术<strong>拦截所有父类方法的调用，顺势织入横切逻辑</strong>。这种思想符合<strong>里氏替换原则</strong>，即子类可以扩展父类的功能，但是不能改变父类原有的功能。</p><h3 id="代理类的父类"><a href="#代理类的父类" class="headerlink" title="代理类的父类"></a>代理类的父类</h3><p>就上面的例子，我们通过</p><pre><code class="hljs java">proxy.getClass().getSuperclass();</code></pre><p>来获取代理类的父类，可以看到其父类是</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">nyima</span>.<span class="hljs-title">study</span>.<span class="hljs-title">day01</span>.<span class="hljs-title">XiaoWen</span></span></code></pre><p>也就是我们的被代理类，这也从一定程度上说明自定义拦截器在调用被拦截对象的方法时，需要调用</p><pre><code class="hljs java">Object invoke = methodProxy.invokeSuper(o, objects);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>集合源码</title>
    <link href="/2020/10/26/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    <url>/2020/10/26/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="集合源码"><a href="#集合源码" class="headerlink" title="集合源码"></a>集合源码</h1><p>工欲善其事必先利其器</p><p><a href="https://www.bilibili.com/video/BV1V7411U78L" target="_blank" rel="noopener"><strong>CodeSheep——Java源码盘起来！演示搭建JDK源码阅读环境，利用IDEA搭建Java源码阅读环境视频教程</strong></a></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h2 id="一、ArrayList底层数据结构"><a href="#一、ArrayList底层数据结构" class="headerlink" title="一、ArrayList底层数据结构"></a>一、ArrayList底层数据结构</h2><h3 id="1、ArrayList集合介绍"><a href="#1、ArrayList集合介绍" class="headerlink" title="1、ArrayList集合介绍"></a>1、ArrayList集合介绍</h3><p>ArrayList是<strong>List</strong>集合<strong>可变大小</strong>的数组的实现</p><h3 id="2、数组"><a href="#2、数组" class="headerlink" title="2、数组"></a>2、数组</h3><p>数组大小一旦确定，就无法改变</p><p><strong>增删慢</strong>：每次添加或删除元素，都需要更改数组长度、拷贝以及移动元素位置</p><p><strong>查询快</strong>：由于数组在内存中是一块连续空间，因此可以根据地址+索引的方式快速获取对应位置上的元素</p><h2 id="二、ArrayList继承关系"><a href="#二、ArrayList继承关系" class="headerlink" title="二、ArrayList继承关系"></a>二、ArrayList继承关系</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911202214.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、Serializable标记性接口"><a href="#1、Serializable标记性接口" class="headerlink" title="1、Serializable标记性接口"></a>1、Serializable标记性接口</h3><p>此处可以查看<a href="https://www.bilibili.com/read/cv6257046" target="_blank" rel="noopener"><strong>CodeSheep——《序列化/反序列化，我忍你很久了！》</strong></a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>类的序列化由实现<strong>java.io.Serializable</strong>接口的类启用</li><li>不实现此接口的类将不会使任何状态序列化或反序列化</li><li>可序列化类的所有子类型都是可序列化的</li><li>序列化接口没有方法或字段，仅<strong>用于标识可串行化的语义</strong></li></ul><p>序列化：将对象的数据写入到文件(写对象) </p><p>反序列化：将文件中对象的数据读取出来(读对象)</p><p>如果<strong>不想对某些变量进行序列化</strong>（如密码等），可以在前面加上 <strong>transient</strong> 关键字，表示该字段不想被序列化</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializable</span> </span>&#123;&#125;</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><p>Student类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7515669154157983943L</span>;String name;<span class="hljs-keyword">int</span> age;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">", age="</span> + age +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p>测试类</p><pre><code class="hljs java"><span class="hljs-comment">//不使用集合</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;write();read();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-comment">//创建对象操作流，进行序列化操作</span>ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"student.txt"</span>));<span class="hljs-comment">//创建Student类的对象</span>Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Nyima"</span>, <span class="hljs-number">12</span>);<span class="hljs-comment">//调用操作流写对象的方法，将对象的数据写入文件中</span>objectOutputStream.writeObject(student);<span class="hljs-comment">//关闭输出流</span>objectOutputStream.close();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"student.txt"</span>));Student student = (Student) objectInputStream.readObject();System.out.println(student);objectInputStream.close();&#125;&#125;<span class="hljs-comment">//使用集合</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Chen"</span>, <span class="hljs-number">1</span>);Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Pan"</span>, <span class="hljs-number">1</span>);Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Wen"</span>, <span class="hljs-number">1</span>);ArrayList&lt;Student&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();lists.add(student1);lists.add(student2);lists.add(student3);ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"stu.txt"</span>));        <span class="hljs-comment">//通过集合进行序列化</span>oos.writeObject(lists);oos.close();ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"stu.txt"</span>));lists = (ArrayList&lt;Student&gt;) ois.readObject();<span class="hljs-keyword">for</span>(Student student : lists) &#123;System.out.println(student);&#125;ois.close();&#125;&#125;</code></pre><h3 id="2、Cloneable标记性接口"><a href="#2、Cloneable标记性接口" class="headerlink" title="2、Cloneable标记性接口"></a>2、Cloneable标记性接口</h3><p>此处可以查看<a href="https://www.bilibili.com/read/cv7349900" target="_blank" rel="noopener"><strong>CodeSheep——《一个工作三年的同事，居然还搞不清深拷贝/浅拷贝，被老大批了》</strong></a></p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>一个类<strong>实现 Cloneable 接口</strong>来指示 <strong>Object.clone()</strong> 方法，该方法对于该类的实例进行字段的复制是合法的。在不实现 Cloneable 接口的实例上调用对象的克隆方法会导致异常 CloneNotSupportedException 被抛出。</p><p>简言之：<strong>克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cloneable</span> </span>&#123;&#125;</code></pre><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li><p>被克隆对象所在的类必须<strong>实现Cloneable接口</strong></p></li><li><p><strong>重写clone()方法</strong></p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>基本使用</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">"Hello"</span>);list.add(<span class="hljs-string">"World"</span>);Object o = list.clone();System.out.println(o == list);System.out.println(list.toString());System.out.println(o.toString());&#125;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200908194627.png" srcset="/img/loading.gif" alt=""></p><h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p>在调用clone方法的地方打上断点</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200908195654.png" srcset="/img/loading.gif" alt=""></p><p>ArrayList实现clone()方法<strong>源码解析</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//此处调用了Object的clone()方法</span>            <span class="hljs-comment">//Object的clone()方法，此处调用了本地方法(native)</span>            <span class="hljs-comment">//protected native Object clone() throws CloneNotSupportedException;</span>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();                        <span class="hljs-comment">//elementData先保存了我们被复制的集合的数据，其中elementData对象为无法被序列化的Object类型的数组</span>            <span class="hljs-comment">//size为被复制数组的大小</span>            <span class="hljs-comment">//transient Object[] elementData; </span>            <span class="hljs-comment">//然后调用Arrays类的copyOf方法给elementData对象赋值</span>            <span class="hljs-comment">//copyOf()方法的调用见下面</span>            v.elementData = Arrays.copyOf(elementData, size);                        <span class="hljs-comment">//用于记录此列表被记录修改的次数</span>            v.modCount = <span class="hljs-number">0</span>;                        <span class="hljs-comment">//返回拷贝对象</span>            <span class="hljs-keyword">return</span> v;        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            <span class="hljs-comment">// this shouldn't happen, since we are Cloneable</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);        &#125;&#125;<span class="hljs-comment">//copyOf()方法</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-comment">//创建一个和原集合相同大小的集合copy</span>        T[] copy = ((Object)newType == (Object)Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>            ? (T[]) new Object[newLength]            : (T[]) Array.newInstance(newType.getComponentType(), newLength);    <span class="hljs-comment">//调用System的arraycopy方法进行复制</span>        System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,                         Math.min(original.length, newLength));    <span class="hljs-comment">//返回copy集合</span>        <span class="hljs-keyword">return</span> copy;&#125;</code></pre><p><strong>图解</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200908201550.png" srcset="/img/loading.gif" alt=""></p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;Skill skill = <span class="hljs-keyword">new</span> Skill(<span class="hljs-string">"Foot Attack"</span>);Hero hero1 = <span class="hljs-keyword">new</span> Hero(<span class="hljs-string">"LiQing"</span>, <span class="hljs-number">25</span>, skill);<span class="hljs-comment">//调用hero1对象的克隆方法</span>Hero hero2 = hero1.clone();<span class="hljs-comment">//打印结果</span>System.out.println(hero1 == hero2);System.out.println(hero1);System.out.println(hero2);<span class="hljs-comment">//更改hero2的年龄和技能</span>hero2.setName(<span class="hljs-string">"Kasa"</span>);skill.setSkillName(<span class="hljs-string">"Fly in the Sky"</span>);       hero2.setSkill(skill);<span class="hljs-comment">//打印结果</span>System.out.println(hero1 == hero2);System.out.println(hero1);System.out.println(hero2);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;String name;<span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//技能类</span>Skill skill;<span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 克隆后的对象</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> CloneNotSupportedException</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Hero <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="hljs-keyword">return</span> (Hero) <span class="hljs-keyword">super</span>.clone();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hero</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, Skill skill)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.age = age;<span class="hljs-keyword">this</span>.skill = skill;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Skill <span class="hljs-title">getSkill</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> skill;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkill</span><span class="hljs-params">(Skill skill)</span> </span>&#123;<span class="hljs-keyword">this</span>.skill = skill;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Hero&#123;"</span> +<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">", age='"</span> + age + <span class="hljs-string">'\''</span> +<span class="hljs-string">", skill="</span> + skill +<span class="hljs-string">'&#125;'</span>;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Skill</span> </span>&#123;String skillName;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Skill</span><span class="hljs-params">(String skillName)</span> </span>&#123;<span class="hljs-keyword">this</span>.skillName = skillName;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSkillName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> skillName;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkillName</span><span class="hljs-params">(String skillName)</span> </span>&#123;<span class="hljs-keyword">this</span>.skillName = skillName;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Skill&#123;"</span> +<span class="hljs-string">"skillName='"</span> + skillName + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909140608.png" srcset="/img/loading.gif" alt=""></p><p>说明：</p><p>创建了一个Hero对象hero1，然后通过其clone()方法克隆了一个hero2对象。然后<strong>我们修改hero2对象的姓名和技能</strong>，其中技能是Skill类构成的。修改后发现。hero1的name没有收到波及，但是<strong>hero1的Skill被改变了</strong></p><p>这就是浅拷贝存在的问题：<strong>基本数据类型可以达到完全复制，引用数据类型则不可以</strong>。这是因为在hero1被克隆的时候，其属性skill(引用数据类型)<strong>仅仅是拷贝了一份引用</strong>，因此当skill的值发生改 变时，被克隆对象hero1的属性skill也将跟随改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;Skill skill = <span class="hljs-keyword">new</span> Skill(<span class="hljs-string">"Foot Attack"</span>);Hero hero1 = <span class="hljs-keyword">new</span> Hero(<span class="hljs-string">"LiQing"</span>, <span class="hljs-number">25</span>, skill);<span class="hljs-comment">//调用hero1对象的克隆方法</span>Hero hero2 = hero1.clone();<span class="hljs-comment">//打印结果</span>System.out.println(hero1 == hero2);System.out.println(hero1);System.out.println(hero2);<span class="hljs-comment">//更改hero2的年龄和技能</span>hero2.setName(<span class="hljs-string">"Kasa"</span>);skill.setSkillName(<span class="hljs-string">"Fly in the Sky"</span>);hero2.setSkill(skill);<span class="hljs-comment">//打印结果</span>System.out.println(hero1 == hero2);System.out.println(hero1);System.out.println(hero2);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;String name;<span class="hljs-keyword">int</span> age;Skill skill;<span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 克隆后的对象</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> CloneNotSupportedException</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Hero <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="hljs-comment">//克隆个英雄对象</span>Hero hero =  (Hero) <span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//调用Skill的clone()方法，克隆出一个skill对象，并赋值给Hero对象</span><span class="hljs-keyword">this</span>.skill = <span class="hljs-keyword">this</span>.skill.clone();<span class="hljs-keyword">return</span> hero;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hero</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, Skill skill)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.age = age;<span class="hljs-keyword">this</span>.skill = skill;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Skill <span class="hljs-title">getSkill</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> skill;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkill</span><span class="hljs-params">(Skill skill)</span> </span>&#123;<span class="hljs-keyword">this</span>.skill = skill;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Hero&#123;"</span> +<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">", age='"</span> + age + <span class="hljs-string">'\''</span> +<span class="hljs-string">", skill="</span> + skill +<span class="hljs-string">'&#125;'</span>;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Skill</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;String skillName;<span class="hljs-comment">//重写克隆方法</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Skill <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="hljs-keyword">return</span> (Skill)<span class="hljs-keyword">super</span>.clone();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Skill</span><span class="hljs-params">(String skillName)</span> </span>&#123;<span class="hljs-keyword">this</span>.skillName = skillName;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSkillName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> skillName;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkillName</span><span class="hljs-params">(String skillName)</span> </span>&#123;<span class="hljs-keyword">this</span>.skillName = skillName;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Skill&#123;"</span> +<span class="hljs-string">"skillName='"</span> + skillName + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909143253.png" srcset="/img/loading.gif" alt=""></p><p>深拷贝与浅拷贝的不同是：若被拷贝对象中引用了其他类，<strong>被引用类也需要实现Cloneable接口，并重写clone()方法</strong></p><p>同时被拷贝对象的clone()方法<strong>不能只是调用父类的clone()方法，需要重写</strong>，规则如下</p><ul><li><p>先调用父类的clone()方法，克隆出一个被拷贝对象</p><pre><code class="hljs java">Hreo hero = (Hero)<span class="hljs-keyword">super</span>.clone();</code></pre></li><li><p>调用被引用类的clone()方法，克隆出一个被引用对象</p><pre><code class="hljs java">Skill skill = (Skill) <span class="hljs-keyword">this</span>.skill.clone()</code></pre></li><li><p>将克隆的<strong>被引用</strong>对象赋值给<strong>被拷贝</strong>对象</p><pre><code class="hljs ini"><span class="hljs-attr">this.skill</span> = skill<span class="hljs-comment">;</span></code></pre></li></ul><h3 id="3、-RandomAccess标记性接口"><a href="#3、-RandomAccess标记性接口" class="headerlink" title="3、 RandomAccess标记性接口"></a>3、 RandomAccess标记性接口</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>标记接口由 <strong>List</strong> 实现使用，以表明它们<strong>支持快速（通常为恒定时间）随机访问</strong></p><p>此接口的主要目的是<strong>允许通用算法更改其行为</strong>，以便在应用于随机访问列表或顺序访问列表时提供良好的性能</p><h4 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>实现了RandomAccess接口，随机访问速度比顺序访问更快</strong></p><p>注意ArrayList<strong>底层为数组</strong>，所以随机访问的效率高。RandomAccess接口<strong>只是用来标识其是否支持随机访问</strong>，而<strong>不是实现了该接口就能使随机访问效率更高</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//使用ArrayList</span>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//向list中添加十万条数据</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;list.add(<span class="hljs-string">"a"</span>);&#125;<span class="hljs-comment">//随机访问，并计算访问用时</span><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;list.get(i);&#125;<span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();System.out.println(<span class="hljs-string">"随机访问时间："</span> + (endTime - startTime));<span class="hljs-comment">//顺序访问</span>startTime = System.currentTimeMillis();<span class="hljs-keyword">for</span>(Iterator iterator = list.iterator(); iterator.hasNext();) &#123;iterator.next();&#125;endTime = System.currentTimeMillis();System.out.println(<span class="hljs-string">"顺序访问时间："</span> + (endTime - startTime));&#125;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909151646.png" srcset="/img/loading.gif" alt=""></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedLis随机访问比顺序访问更慢</strong>。因为LinkedList底层为链表，随机访问效率低，所以没有实现RandomAccess接口。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></code></pre><p><strong>代码</strong></p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Demo2 &#123;public static void main(String<span class="hljs-literal">[]</span> args) &#123;<span class="hljs-comment">//使用LinkedList</span>LinkedList&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;<span class="hljs-literal">()</span>;<span class="hljs-comment">//向list中添加十万条数据</span>for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<span class="hljs-built_in">list</span>.add(<span class="hljs-string">"a"</span>);&#125;<span class="hljs-comment">//随机访问，并计算访问用时</span>long startTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<span class="hljs-built_in">list</span>.get(i);&#125;long endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"随机访问时间："</span> + (endTime - startTime));<span class="hljs-comment">//顺序访问</span>startTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;for (Iterator iterator = <span class="hljs-built_in">list</span>.iterator<span class="hljs-literal">()</span>; iterator.has<span class="hljs-constructor">Next()</span>; ) &#123;iterator.next<span class="hljs-literal">()</span>;&#125;endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"顺序访问时间："</span> + (endTime - startTime));&#125;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909151730.png" srcset="/img/loading.gif" alt=""></p><p><strong>为什么LinkedList随机访问的效率这么低呢</strong></p><ul><li><p>随机访问的时候源码底层<strong>每次都需要进行折半的动作</strong>，再经过判断是从头还是从尾部一个个寻找</p></li><li><p>顺序访问只会在获取迭代器的时候<strong>进行一次折半的动作</strong>，以后每次都是在上一次的基础上获取下一个元素</p><p>因此顺序访问要比随机访问快得多</p></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>遍历集合前使用 <strong>instanceof</strong> 关键字来判断集合<strong>是否实现了 RandomAccess 接口</strong></p><ul><li>如果实现了，就使用随机访问</li><li>如果没实现，就使用顺序访问</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//链表</span>LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<span class="hljs-comment">//数组</span>ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//向集合中添加十万条数据</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;arrayList.add(<span class="hljs-string">"a"</span>);linkedList.add(<span class="hljs-string">"b"</span>);&#125;<span class="hljs-comment">//通过判断集合是否实现了RandomAccess接口，来选择适当的遍历方法</span><span class="hljs-keyword">if</span> (arrayList <span class="hljs-keyword">instanceof</span> RandomAccess) &#123;System.out.println(<span class="hljs-string">"随机访问"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;arrayList.get(i);&#125;&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">"顺序访问"</span>);<span class="hljs-comment">//实现了迭代器的集合，foreach会使用迭代器</span><span class="hljs-keyword">for</span> (String s : arrayList) &#123;<span class="hljs-comment">//取出元素，不做任何操作</span>&#125;&#125;<span class="hljs-keyword">if</span> (linkedList <span class="hljs-keyword">instanceof</span> RandomAccess) &#123;System.out.println(<span class="hljs-string">"随机访问"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; linkedList.size(); i++) &#123;linkedList.get(i);&#125;&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">"顺序访问"</span>);<span class="hljs-comment">//实现了迭代器的集合，foreach会使用迭代器</span><span class="hljs-keyword">for</span> (String s : linkedList) &#123;<span class="hljs-comment">//取出元素，不做任何操作</span>&#125;&#125;&#125;&#125;</code></pre><h3 id="4、AbstractList抽象类"><a href="#4、AbstractList抽象类" class="headerlink" title="4、AbstractList抽象类"></a>4、AbstractList抽象类</h3><p>该抽象类含有一个空构造方法，以及一些需要子类去实现的抽象方法</p><h2 id="三、ArrayList源码分析"><a href="#三、ArrayList源码分析" class="headerlink" title="三、ArrayList源码分析"></a>三、ArrayList源码分析</h2><h3 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h3><h4 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> </span>&#123;    <span class="hljs-comment">//默认的初始化容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;        <span class="hljs-comment">//默认的Object类型的空数组</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;        <span class="hljs-comment">//不可序列化的Object类型数组，用于存储ArrayList元素的数组</span>    <span class="hljs-keyword">transient</span> Object[] elementData;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果没有指定集合的大小，当第一次向集合中添加元素时，集合容量会扩充为10</span>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><p>无参构造方法没有指定集合的大小，所以当<strong>第一次向集合中添加元素的时候，集合的容量会扩充为10</strong></p><h4 id="initialCapacity构造方法"><a href="#initialCapacity构造方法" class="headerlink" title="initialCapacity构造方法"></a>initialCapacity构造方法</h4><pre><code class="hljs java"><span class="hljs-comment">//空的Objcet类型数组，区别于DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<span class="hljs-comment">//如果容量大于0</span>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//根据传入的容量大小创建Objcet类型的数组，赋值给elementData</span>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果容量等于0，就将elementData赋值为一个Object类型的空数组</span>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果容量小于0，就抛出异常</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                               initialCapacity);        &#125;&#125;</code></pre><p>initialCapacity构造函数会根据传入的容量大小来创建满足要求的集合</p><h4 id="Collection构造方法"><a href="#Collection构造方法" class="headerlink" title="Collection构造方法"></a>Collection构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 将传入的集合转成数组</span>        elementData = c.toArray();        <span class="hljs-comment">//判断传入集合的大小是否为0</span>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>            <span class="hljs-comment">// 存在一个bug，c.toArray方法的返回值可能不是一个Object类型的数组</span>            <span class="hljs-comment">// 如果elementData的类型不是一个Object类型的数组</span>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                // 就再次进行拷贝操作</span><span class="hljs-class">                <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// replace with empty array.</span>            <span class="hljs-comment">// 如果传入集合的大小为0，就赋值为一个空数组</span>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;        &#125;&#125;<span class="hljs-comment">// toArray方法</span><span class="hljs-keyword">public</span> Object[] toArray() &#123;    <span class="hljs-comment">// 调用了copyOf方法</span>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);&#125;<span class="hljs-comment">// copyOf方法</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-keyword">int</span> newLength) &#123;     调用了重载后的copyOf方法，对集合进行拷贝操作        <span class="hljs-keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());&#125;</code></pre><p>Collection构造方法主要是将传入的集合转变为数组类型。在转换后根据elementData的大小再次对elementData进行了赋值操作</p><ul><li>当size != 0时，要判断 c.toArray() 所返回的结果是不是Objcet类型的数组，如果不是，则还需要elementData该为Object数组</li><li>当size == 0时，将其赋值为一个空数组</li></ul><h3 id="2、添加方法"><a href="#2、添加方法" class="headerlink" title="2、添加方法"></a>2、添加方法</h3><h4 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 向集合中添加一个元素时，会调用add(E e)方法</span>list.add(<span class="hljs-string">"Nyima"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 传入需要扩容的最小容量，值为元素个数+1</span>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    <span class="hljs-comment">// 扩容后，放入要添加的元素</span>        elementData[size++] = e;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// 调用calculateCapacity方法，计算最小容量</span>        <span class="hljs-comment">//然后再调用ensureExplicitCapacity方法，来增加数组被修改次数modCount，以及查看是否真正需要扩容</span>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// 如果集合是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，也就是创建集合时没有传入容量大小，并且是第一次进行添加操作</span>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;            <span class="hljs-comment">// 返回默认容量10，和最小容量的较大者</span>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);        &#125;    <span class="hljs-comment">// 返回最小容量</span>        <span class="hljs-keyword">return</span> minCapacity;&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;     <span class="hljs-comment">// 增加modCount++</span>        <span class="hljs-comment">// modCount用于保存集合被修改的次数</span>        modCount++;        <span class="hljs-comment">// overflow-conscious code</span>     <span class="hljs-comment">// 如果容量不够，才扩容</span>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">// 真正的扩容操作</span>            grow(minCapacity);&#125;<span class="hljs-comment">// 真正的扩容操作</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-comment">// 保存扩容前数组的容量</span>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;        <span class="hljs-comment">// 得到扩容后数组的容量，扩大为原容量的1.5倍数</span>    <span class="hljs-comment">// 右移 &gt;&gt; : 右移多少位就是除以2的多少次幂，这里是除以2</span>    <span class="hljs-comment">// 左移 &lt;&lt; : 左移多少位就是乘以2的多少次幂</span>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-comment">// 如果扩容1.5倍后的容量小于最小容量</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)            <span class="hljs-comment">// 就按照最小容量进行扩容（选取较大的扩容方式）</span>            newCapacity = minCapacity;        <span class="hljs-comment">// 如果新容量大于数组的最大容量</span>        <span class="hljs-comment">// private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">//就将其令为最大容量</span>            newCapacity = hugeCapacity(minCapacity);            <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>    <span class="hljs-comment">// 将数组根据newCapacity扩容，并将其原来的元素放入到elementData中</span>        elementData = Arrays.copyOf(elementData, newCapacity);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;&#125;</code></pre><p><strong>总结</strong></p><ul><li>向集合中添加元素时，先进行容量检测，在进行添加操作</li><li>容量检测操作如下<ul><li>最小扩容容量为<strong>当前数组元素个数+1</strong></li><li>判断当前数组是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，也就是调用了无参构造函数来创建集合<ul><li>如果是，最小容量就变为DEFAULT_CAPACITY(10)和最小容量的较大者</li><li>如果不是，就返回较小容量</li></ul></li><li>返回得到的最小扩容容量</li></ul></li><li>然后调用方法，<strong>增加集合被修改的次数</strong>（modCount++），然后<strong>再次确定最小扩容容量是否大于数组当前的大小</strong>（也就是放入元素后会不会大于数组的当前长度，<strong>容量不足</strong>），如果满足，则调用<strong>最重要的grow方法</strong>进行数组的扩容，方法执行的操作如下<ul><li>用变量<strong>oldCapacity</strong>保存扩容前数组的大小（<strong>数组中元素的个数</strong>）</li><li>进行扩容，<strong>扩容大小为原容量的1.5倍</strong>（右移一位，表示除以2）</li><li>查看扩容后的容量是否小于最小扩容容量（如果原容量为0，如初始化了集合大小，newCapaticy就还是0，所以需要比较）<ul><li>如果是，就以最小扩容容量来进行扩容</li><li>如果不是，就扩大为原容量的1.5倍</li></ul></li></ul></li></ul><p><strong>补充：</strong>集合在被操作的时候，都会增加modCount的值，那么这个值到底有什么用呢？</p><p>在使用迭代器进行迭代时会用到这个变量。<strong>这个变量是用来保证线程的安全性的</strong>。如果在进行迭代的时候，发现modCount的值被修改了，那么就会抛出ConcurrentModificationException</p><p><strong>后面分析迭代器时，还会具体分析modCount</strong></p><h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);list.add(<span class="hljs-string">"Nyima1"</span>);list.add(<span class="hljs-string">"Nyima2"</span>);list.add(<span class="hljs-string">"Nyima3"</span>);<span class="hljs-comment">//向指定位置插入元素</span>list.add(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima4"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 判断插入的位置是否合法</span>        rangeCheckForAdd(index);    <span class="hljs-comment">// 对数组容量进行检查，查看是否需要进行扩容，并增加数组被修改的次数modCount</span>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">        * 进行拷贝操作，将插入位置及其后面的所有元素后移一位</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span>      src      the source array.</span><span class="hljs-comment">        * <span class="hljs-doctag">@param</span>      srcPos   starting position in the source array.</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      dest     the destination array.</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      destPos  starting position in the destination data.</span><span class="hljs-comment">        * <span class="hljs-doctag">@param</span>      length   the number of array elements to be copied.</span><span class="hljs-comment">        */</span>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,                         size - index);        <span class="hljs-comment">// 在目标位置插入该元素</span>        elementData[index] = element;    <span class="hljs-comment">// 集合容量加1</span>        size++;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// 如果插入位置超出了数组的范围，就抛出异常</span>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;</code></pre><h4 id="addAll-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)方法"></a>addAll(Collection&lt;? extends E&gt; c)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">"Nyima1"</span>);list.add(<span class="hljs-string">"Nyima2"</span>);list.add(<span class="hljs-string">"Nyima3"</span>);                <span class="hljs-comment">// 此处调用了addAll方法，将list集合中的所有元素插入到list2集合的末尾</span>list2.addAll(list);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 将要插入的集合转为Object类型的数组</span>        Object[] a = c.toArray();        <span class="hljs-comment">// 得到插入数组的长度</span>        <span class="hljs-keyword">int</span> numNew = a.length;        <span class="hljs-comment">// 增加modCount并根据需求进行扩容</span>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>        <span class="hljs-comment">// 调用数组拷贝的方法，将数组a中的所有元素添加到elementData数组的末尾</span>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);        <span class="hljs-comment">// 数组的大小增加，增加大小为被拷贝集合的大小</span>        size += numNew;        <span class="hljs-comment">// 返回是否添加成功。如果被添加集合是一个空数组，则添加失败</span>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="addAll-int-index-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)方法"></a>addAll(int index, Collection&lt;? extends E&gt; c)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();ArrayList&lt;String&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">"Nyima1"</span>);list.add(<span class="hljs-string">"Nyima2"</span>);list.add(<span class="hljs-string">"Nyima3"</span>);list2.add(<span class="hljs-string">"Nyima4"</span>);list2.add(<span class="hljs-string">"Nyima5"</span>);        <span class="hljs-comment">// 在指定位置插入所有集合</span>list2.addAll(<span class="hljs-number">1</span>, list);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 进行边界检查，如果超出集合范围，则会抛出异常</span>        rangeCheckForAdd(index);    <span class="hljs-comment">// 将要插入的集合转为Object类型的数组</span>        Object[] a = c.toArray();        <span class="hljs-comment">// 得到插入数组的长度</span>        <span class="hljs-keyword">int</span> numNew = a.length;           <span class="hljs-comment">// 根据需求进行扩容操作</span>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>    <span class="hljs-comment">// 计算需要移动的步数</span>        <span class="hljs-keyword">int</span> numMoved = size - index;        <span class="hljs-comment">// 如果需要移动的步数大于0， 则进行移动操作</span>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">// 先将被插入数组中在index之后的元素向后移动</span>            System.arraycopy(elementData, index, elementData, index + numNew,                             numMoved);    <span class="hljs-comment">// 在指定位置插入数组</span>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);        <span class="hljs-comment">// 增加size的大小</span>        size += numNew;        <span class="hljs-comment">// 返回是否插入成功</span>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;&#125;</code></pre><p>这里的插入操作和 add(int index, E element) 方法有一些类似。边界判断、集合转数组、数组扩容等。并且<strong>在移动被插入数组中的元素时，都用到了 System.arraycopy() 方法</strong>。只不过 add(int index, E element) 只用插入一个元素，所以直接插入就可以了。而 a<strong>ddAll(int index, Collection&lt;? extends E&gt; c) 方法</strong>因为需要插入多个元素，所以<strong>再次用到了 System.arraycopy()  方法</strong>，来进行多个元素的插入操作</p><h3 id="3、移除方法"><a href="#3、移除方法" class="headerlink" title="3、移除方法"></a>3、移除方法</h3><h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">// 判断是否越界</span>        rangeCheck(index);        modCount++;        E oldValue = elementData(index);    <span class="hljs-comment">// 需要移动的元素个数</span>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 从index+1开始，后面的元素全部前移1位</span>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);        <span class="hljs-comment">// 让最后一个元素置空，让GC来清楚它</span>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>    <span class="hljs-comment">// 返回被移除的元素</span>        <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre><h4 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">// 被移除的元素为空</span>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)            <span class="hljs-comment">// 移除为空的元素</span>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;                fastRemove(index);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)            <span class="hljs-comment">// 移除指定的元素</span>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;                <span class="hljs-comment">// 每次删除一个元素</span>                fastRemove(index);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;    &#125;    <span class="hljs-comment">// 移除失败</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// 这个方法和remove(int index)方法有些类似，只不过不用返回被删除的元素</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        modCount++;        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);        <span class="hljs-comment">// 让最后一个元素置空，让GC来清楚它</span>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>&#125;</code></pre><h3 id="4、set-get方法"><a href="#4、set-get方法" class="headerlink" title="4、set/get方法"></a>4、set/get方法</h3><h4 id="set-int-index-E-element-方法"><a href="#set-int-index-E-element-方法" class="headerlink" title="set(int index, E element)方法"></a>set(int index, E element)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 判断索引是否越界</span>        rangeCheck(index);    <span class="hljs-comment">// 用oldValue保存数组中index位置上的元素</span>        E oldValue = elementData(index);        <span class="hljs-comment">// 将要插入的元素插入到数组的index位置上</span>        elementData[index] = element;        <span class="hljs-comment">// 返回index原来位置上的元素</span>        <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre><p>set方法在改变数组中指定位置的元素时，<strong>会返回被覆盖的元素</strong></p><h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// 判断索引是否越界</span>        rangeCheck(index);     <span class="hljs-comment">// 返回数组中index位置上的元素</span>        <span class="hljs-keyword">return</span> elementData(index);&#125;</code></pre><h3 id="5、转化方法"><a href="#5、转化方法" class="headerlink" title="5、转化方法"></a>5、转化方法</h3><h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><p>ArrayList 的 toString 方法调用的是其祖宗类 AbstractCollection 的toString 方法</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910150556.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 获取迭代器</span>        Iterator&lt;E&gt; it = iterator();        <span class="hljs-comment">// 如果迭代器为空，就返回"[]"</span>        <span class="hljs-keyword">if</span> (! it.hasNext())            <span class="hljs-keyword">return</span> <span class="hljs-string">"[]"</span>;        <span class="hljs-comment">// 使用StringBuilder来进行字符串的拼接</span>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-string">'['</span>);        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 获取一个元素</span>            E e = it.next();                        <span class="hljs-comment">// 进行拼接操作</span>            sb.append(e == <span class="hljs-keyword">this</span> ? <span class="hljs-string">"(this Collection)"</span> : e);                        <span class="hljs-comment">// 看是否还有下一个元素</span>            <span class="hljs-keyword">if</span> (! it.hasNext())                <span class="hljs-comment">// 如果没有，就加上']'，并调用toStrng方法转化为String类型</span>                <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">']'</span>).toString();                        <span class="hljs-comment">// 如果还有下一个元素，就加上 ", " 进行分割</span>            sb.append(<span class="hljs-string">','</span>).append(<span class="hljs-string">' '</span>);        &#125;    &#125;&#125;</code></pre><h3 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h3><h4 id="iterator-普通迭代器"><a href="#iterator-普通迭代器" class="headerlink" title="iterator()普通迭代器"></a>iterator()普通迭代器</h4><p><strong>案例一</strong>：使用迭代器<strong>遍历</strong>获取集合的每一个元素</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();&#125;<span class="hljs-comment">// Itr为ArrayList中的内部类</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">// 光标，用于指向下次被查看的元素。 一开始为0</span>        <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span>    <span class="hljs-comment">// 最后一个元素的索引，如果没有元素就是-1</span>        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span>        <span class="hljs-comment">// 期望的被修改次数 = 开始迭代时被修改的次数。主要是为了检查多线程情况下，是否出现了并发安全性问题</span>        <span class="hljs-keyword">int</span> expectedModCount = modCount;    <span class="hljs-comment">// 无参构造函数</span>        Itr() &#123;&#125;    <span class="hljs-comment">// 查看是否到了末尾， 如果光标和数组大小相等，则到了末尾</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> cursor != size;&#125;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// 检查是否有并发安全性问题</span>            checkForComodification();                        <span class="hljs-comment">// i 用来访问数组中的元素。 把光标的值赋值给i</span>            <span class="hljs-keyword">int</span> i = cursor;                        <span class="hljs-comment">// 如果越界，抛出异常</span>            <span class="hljs-keyword">if</span> (i &gt;= size)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();                        <span class="hljs-comment">// 将被迭代的数组赋值给elementData</span>            Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                        <span class="hljs-comment">// 是否越界</span>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                        <span class="hljs-comment">// 光标后移</span>            cursor = i + <span class="hljs-number">1</span>;                        <span class="hljs-comment">// 给lastRet赋值，同时返回 i 指向的元素</span>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];        &#125;               <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// 看当前的 modCount 和迭代开始前的 modCount (expectedModCount)是否相同</span>            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-comment">// 如果不同，抛出异常</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;&#125;</code></pre><p><strong>案例二</strong>：在使用迭代器遍历元素时，删除<strong>最后一个</strong>元素</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();arrayList.add(<span class="hljs-string">"Nyima1"</span>);arrayList.add(<span class="hljs-string">"Nyima2"</span>);arrayList.add(<span class="hljs-string">"Nyima3"</span>);Iterator iterator = arrayList.iterator();<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;String tempStr = (String) iterator.next();            <span class="hljs-comment">// 移除最后一个元素</span><span class="hljs-keyword">if</span>(tempStr.equals(<span class="hljs-string">"Nyima3"</span>)) &#123;arrayList.remove(tempStr);&#125;&#125;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163121.png" srcset="/img/loading.gif" alt=""></p><p><strong>问题分析</strong></p><ul><li><p>每次进行遍历操作调用 next 方法时，在开头都会先调用<strong>checkForComodification</strong>方法，<strong>来判断modCount是否和expectedModCount是否一致</strong></p><ul><li><p>在删除指定元素前的遍历中，可以看到 modCount 和 expectedModCount 相同，都为3</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163407.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>进行删除操作，<strong>删除操作会使得数组的大小-1</strong><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163528.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;                    fastRemove(index);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;                    fastRemove(index);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span><span class="hljs-comment">     * return the value removed.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        modCount++;        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);                <span class="hljs-comment">// 这里会使得数组的大小-1</span>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>    &#125;</code></pre></li><li><p>继续向下执行，会发现在遍历了所有元素之后，<strong>循环并没有第一时间就停下来</strong>！</p><ul><li>可以看到，hasNext 是<strong>根据光标和数组大小是否一致来判断是否有下一个元素的</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163802.png" srcset="/img/loading.gif" alt=""></p><ul><li>再次执行next，此时发现<strong>modCount是否和expectedModCount不一致！</strong>便抛出了异常<ul><li>modCount的增加是因为<strong>前面进行了删除操作，使得modCount的值+1了</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910164004.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论</strong>：在使用迭代器进行遍历时，如果中途<strong>移除了最后一个元素</strong>，则会出现<strong>并发修改异常</strong>。因为在遍历过程中modCount的值被修改了</p><p><strong>案例三</strong>：使用迭代器删除<strong>倒数第二个</strong>元素</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();arrayList.add(<span class="hljs-string">"Nyima1"</span>);arrayList.add(<span class="hljs-string">"Nyima2"</span>);arrayList.add(<span class="hljs-string">"Nyima3"</span>);Iterator iterator = arrayList.iterator();<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;String tempStr = (String) iterator.next();            <span class="hljs-comment">// 移除倒数第二个元素</span><span class="hljs-keyword">if</span>(tempStr.equals(<span class="hljs-string">"Nyima2"</span>)) &#123;arrayList.remove(tempStr);&#125;&#125;&#125;&#125;</code></pre><p><strong>运行结果</strong>：没有抛出异常</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910165928.png" srcset="/img/loading.gif" alt=""></p><p>问题分析：</p><ul><li><p>在删除第二个元素的时候，modCount确实增加了 3-&gt;4</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910170113.png" srcset="/img/loading.gif" alt=""></p></li><li><p>因为删除了一个元素，<strong>此时的数组大小 size = 2，与光标cursor的大小一致了</strong> ！</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910170139.png" srcset="/img/loading.gif" alt=""></p><ul><li>所以<strong>还没来得及做下一次 modCount 和 expectedModCount 的检测，就跳出了循环</strong></li></ul><p>在遍历ArrayList时，不要对集合中的元素进行增加与修改操作。如果要进行元素的<strong>删除</strong>，最好<strong>使用迭代器自身的 remove() 方法</strong></p><pre><code class="hljs java">iterator.remove();</code></pre><h4 id="迭代器默认remove-方法"><a href="#迭代器默认remove-方法" class="headerlink" title="迭代器默认remove()方法"></a>迭代器默认remove()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();        <span class="hljs-comment">// 调用方法检测 modCount 和 expectedModCount，此时还未进行删除操作，所以两个值相同</span>    checkForComodification();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 调用ArrayList的remove(index)方法进行删除，此操作会修改modCount的值</span>        ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);          cursor = lastRet;        lastRet = -<span class="hljs-number">1</span>;                <span class="hljs-comment">// 更新 expectedModCount 的值</span>        expectedModCount = modCount;    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;</code></pre><p>可以看出，<strong>迭代器默认的remove方法，在进行完删除操作后，更新了 expectedModCount 的值，使得其与modCount一致</strong></p><h3 id="7、清空方法"><a href="#7、清空方法" class="headerlink" title="7、清空方法"></a>7、清空方法</h3><h4 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    modCount++;    <span class="hljs-comment">// clear to let GC do its work</span>    <span class="hljs-comment">// 依次将数组中的元素置为null，方便GC来回收内存</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)        elementData[i] = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 将容量设置为0</span>    size = <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="8、包含方法"><a href="#8、包含方法" class="headerlink" title="8、包含方法"></a>8、包含方法</h3><h4 id="contains-Object-o-方法"><a href="#contains-Object-o-方法" class="headerlink" title="contains(Object o)方法"></a>contains(Object o)方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 将参数转为了Object类型</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">// 调用 indexOf 方法，查找o的索引。如果索引值大于等于0，就返回true，反之返回false</span>    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">// 传入参数是否为 null</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 依次遍历数组，返回遇到的第一个null的索引</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 遍历数组，返回遇到的第一个o的索引</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))                    <span class="hljs-keyword">return</span> i;        &#125;    <span class="hljs-comment">// 如果数组中没有该元素，就返回-1</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h1 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="一、LinkedList底层数据结构"><a href="#一、LinkedList底层数据结构" class="headerlink" title="一、LinkedList底层数据结构"></a>一、LinkedList底层数据结构</h2><h3 id="1、LinkedList集合介绍"><a href="#1、LinkedList集合介绍" class="headerlink" title="1、LinkedList集合介绍"></a>1、LinkedList集合介绍</h3><p>LinkedList底层由一个<strong>拥有头、尾指针的双向链表构成</strong></p><h3 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h3><p>链表的<strong>增删插入效率高</strong>，但是<strong>查找效率较低</strong></p><p>详细可见<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8">Java数据结构与算法——链表</a></p><h2 id="二、LinkedList继承关系"><a href="#二、LinkedList继承关系" class="headerlink" title="二、LinkedList继承关系"></a>二、LinkedList继承关系</h2><h3 id="1、继承关系图"><a href="#1、继承关系图" class="headerlink" title="1、继承关系图"></a>1、继承关系图</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201227205501.png" srcset="/img/loading.gif" alt=""></p><p>LinkedList也实现了Serializable和Clonealbe接口，但因为链表随机访问效率较低，所以未实现RandomAccess方法</p><h3 id="2、clone方法"><a href="#2、clone方法" class="headerlink" title="2、clone方法"></a>2、clone方法</h3><pre><code class="hljs php"><span class="hljs-keyword">public</span> Object <span class="hljs-keyword">clone</span>() &#123;<span class="hljs-comment">// 调用本地方法，将链表进行克隆，此时clone里元素与被克隆链表的元素一致</span>    LinkedList&lt;E&gt; <span class="hljs-keyword">clone</span> = superClone();    <span class="hljs-comment">// Put clone into "virgin" state</span>    <span class="hljs-comment">// 克隆出来的链表的头、尾指针都为null。此时clone被清空了，因为没有指针指向clone链表的任意元素</span>    <span class="hljs-keyword">clone</span>.first = <span class="hljs-keyword">clone</span>.last = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 克隆出来的链表size为0</span>    <span class="hljs-keyword">clone</span>.size = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 修改次数为0</span>    <span class="hljs-keyword">clone</span>.modCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Initialize clone with our elements</span>    <span class="hljs-comment">// 初始化克隆链表，为其添加元素</span>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next)        <span class="hljs-keyword">clone</span>.add(x.item);<span class="hljs-comment">// 返回克隆链表</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span>;&#125; <span class="hljs-keyword">private</span> LinkedList&lt;E&gt; superClone() &#123;        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 调用本地方法进行克隆操作</span>            <span class="hljs-keyword">return</span> (LinkedList&lt;E&gt;) super.<span class="hljs-keyword">clone</span>();        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);        &#125;&#125;</code></pre><h2 id="三、LinkedList源码分析"><a href="#三、LinkedList源码分析" class="headerlink" title="三、LinkedList源码分析"></a>三、LinkedList源码分析</h2><h3 id="1、构造方法-1"><a href="#1、构造方法-1" class="headerlink" title="1、构造方法"></a>1、构造方法</h3><h4 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 链表的容量</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<span class="hljs-comment">// 链表的头指针</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-comment">// 链表的尾指针</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-comment">// 创建了一个空链表</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><h4 id="Collection构造方法-1"><a href="#Collection构造方法-1" class="headerlink" title="Collection构造方法"></a>Collection构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 先调用无参构造函数， 初始化集合容积 size = 0， 并创建头尾指针</span>    <span class="hljs-keyword">this</span>();        <span class="hljs-comment">// 调用方法，将传入的集合c添加到集合尾部</span>    addAll(c);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 调用重载后的addAll()方法，并返回其结果</span>    <span class="hljs-keyword">return</span> addAll(size, c);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 检查索引是否越界， 通过0和size来判断</span>        checkPositionIndex(index);    <span class="hljs-comment">// 将传入的集合转成Object类型的数组</span>        Object[] a = c.toArray();        <span class="hljs-comment">// 获得传入集合的长度，也就是需要插入的集合中元素的个数</span>        <span class="hljs-keyword">int</span> numNew = a.length;        <span class="hljs-comment">// 如果其长度为0，则返回添加失败</span>        <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 创建两个节点</span>    <span class="hljs-comment">// pred保存插入位置的前驱节点， succ保存插入位置的节点</span>        Node&lt;E&gt; pred, succ;        <span class="hljs-comment">// 如果是在集合的末尾进行插入</span>        <span class="hljs-keyword">if</span> (index == size) &#123;            <span class="hljs-comment">// succ为空，pred为尾节点</span>            succ = <span class="hljs-keyword">null</span>;            pred = last;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果不是在末尾进行插入, succ保存插入位置的节点，pred保存插入位置节点的前驱结点</span>            succ = node(index);            pred = succ.prev;        &#125;    <span class="hljs-comment">// 使用增加for，通过迭代器顺序访问插入集合</span>        <span class="hljs-keyword">for</span> (Object o : a) &#123;            <span class="hljs-comment">// 将遍历的元素o赋值给变量e</span>            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E) o;                        <span class="hljs-comment">// 创建Node对象，Node为LinkedList的内部类。</span>            <span class="hljs-comment">// 传入的值依次为：插入节点的前驱节点，该节点存储的数据，后继节点为null</span>            Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);                        <span class="hljs-comment">// 如果没有前驱节点，也就是在链表头部进行插入</span>            <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)                <span class="hljs-comment">// 该节点就是头结点</span>                first = newNode;            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 如果有前驱结点，前驱结点就指向该节点</span>                pred.next = newNode;            <span class="hljs-comment">// 前驱节点后移，指向该节点</span>            pred = newNode;        &#125;    <span class="hljs-comment">// 如果是在尾部进行插入</span>        <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// pred节点就是尾节点</span>            last = pred;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 否则 pred 与 succ 互相指向对方</span>            pred.next = succ;            succ.prev = pred;        &#125;    <span class="hljs-comment">// size扩大</span>        size += numNew;        <span class="hljs-comment">// 修改次数+1</span>        modCount++;        <span class="hljs-comment">// 返回修改成功</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            <span class="hljs-keyword">this</span>.item = element;            <span class="hljs-keyword">this</span>.next = next;            <span class="hljs-keyword">this</span>.prev = prev;        &#125;&#125;</code></pre><p>该构造函数先创建了一个空链表，然后调用了addAll()方法将待插入集合插入链表中</p><p><strong>图解插入过程：addAll()方法</strong></p><p><strong>情况一：在尾部插入</strong></p><ul><li>pred指向尾部的节点，succ指向null</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911214210.png" srcset="/img/loading.gif" alt=""></p><ul><li>遍历待插入数组，取出第一个元素<ul><li>调用Node&lt;&gt;的构造方法，在初始化节点时，将其前驱结点赋值为pred节点</li><li>放在pred节点的后面，pred.next指向newNode。<strong>此时succ依然指向null</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911214251.png" srcset="/img/loading.gif" alt=""></p><ul><li>pred后移，指向刚插入的节点</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911214321.png" srcset="/img/loading.gif" alt=""></p><ul><li>重复上面的步骤，直到待插入集合中所有元素都插入到链表当中</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911214841.png" srcset="/img/loading.gif" alt=""></p><ul><li>插入完毕后，因为succ为null，所以尾指针last变为pred</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911214948.png" srcset="/img/loading.gif" alt=""></p><p><strong>情况二：在中间进行插入</strong></p><ul><li>在index=2处（第三个节点）处进行插入，succ保存了插入位置的节点，pred为其前驱节点</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911215148.png" srcset="/img/loading.gif" alt=""></p><ul><li>在pred后面插入元素</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911215615.png" srcset="/img/loading.gif" alt=""></p><ul><li>一直插入元素，直到插入完成</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911215732.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果succ不为空（指向了插入位置处的节点），pred的后继节点为succ，succ的前驱为pred</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911215943.png" srcset="/img/loading.gif" alt=""></p><p><strong>可见，在LinkedList中间进行插入，是在index处节点之前进行插入操作的</strong></p><p><strong>情况三：在头部进行插入</strong></p><p>先使用头插法插入<strong>第一个元素</strong></p><ul><li>succ指向了头结点，pred指向其前驱，此时为null</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911220714.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果pred为空，则头指针 first 指向 newNode。<strong>让pred指向newNode</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911221015.png" srcset="/img/loading.gif" alt=""></p><ul><li>然后<strong>在头结点之后插入剩余元素，因为此时的pred已经不为空了</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911221252.png" srcset="/img/loading.gif" alt=""></p><ul><li>pred指向新插入的节点，此时待插入集合为空。pred 与 succ 互相指向对方。插入完毕</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200911221350.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、添加方法-1"><a href="#2、添加方法-1" class="headerlink" title="2、添加方法"></a>2、添加方法</h3><h4 id="addFirst-E-e-方法"><a href="#addFirst-E-e-方法" class="headerlink" title="addFirst(E e)方法"></a>addFirst(E e)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 调用linkFirst()方法</span>        linkFirst(e);&#125;<span class="hljs-comment">// 私有方法，用头插法插入元素</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 用 f 保存插入前链表中的头节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-comment">// 创建一个新节点，值为待插入元素的值(e)， 后继节点为 f (插入前的头结点)</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);        <span class="hljs-comment">// 头结点变为新插入的节点newNode</span>        first = newNode;        <span class="hljs-comment">// 如果 f 为空，也就是插入前链表为空</span>        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">// newNode同时也是尾节点</span>            last = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// 否则，newNode 为 f 的前驱结点</span>            f.prev = newNode;            size++;        modCount++;&#125;</code></pre><p>addFirst进行头插法插入元素时，会<strong>调用私有方法linkFirst来进行插入操作</strong></p><h4 id="addLast-E-e-方法"><a href="#addLast-E-e-方法" class="headerlink" title="addLast(E e)方法"></a>addLast(E e)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<span class="hljs-comment">// 调用linkLast()方法来进行尾部插入</span>    linkLast(e);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 用 l 来保存链表的尾节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-comment">// 创建新节点，值为待插入节点的值（e），前驱节点为l，也就是插入前的尾节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// newNode变为尾节点（last）</span>        last = newNode;        <span class="hljs-comment">// 如果 l 为空，也就是插入前链表为空</span>        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">// newNode也是头结点</span>            first = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// l的后继节点为newNode</span>            l.next = newNode;        size++;        modCount++;&#125;</code></pre><h4 id="add-E-e-方法-1"><a href="#add-E-e-方法-1" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 调用linkLast在末尾进行插入</span>        linkLast(e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h4 id="add-int-index-E-element-方法-1"><a href="#add-int-index-E-element-方法-1" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, E element) &#123;<span class="hljs-comment">// 检查index是否越界</span>    checkPositionIndex(<span class="hljs-keyword">index</span>);<span class="hljs-comment">// 如果 index == size，就在末尾进行插入</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == size)        linkLast(element);    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则就调用linkBefore()方法，在index处节点前进行插入</span>    <span class="hljs-comment">// 调用了node()方法，来获取指定索引出的元素</span>        linkBefore(element, node(<span class="hljs-keyword">index</span>));&#125;Node&lt;E&gt; node(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;        <span class="hljs-comment">// assert isElementIndex(index);</span><span class="hljs-comment">// 看index是在链表的前半段还是后半段</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;        <span class="hljs-comment">// 如果是前半段，就通过first节点从前向后扫描</span>            Node&lt;E&gt; x = first;                        <span class="hljs-comment">// 找到index处的元素并返回。0-&gt;index-1</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">index</span>; i++)                x = x.next;            <span class="hljs-keyword">return</span> x;        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 否则，就通过last从后往前找</span>            Node&lt;E&gt; x = last;                        <span class="hljs-comment">// 找到index的元素并返回。size-1 -&gt; index；</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; <span class="hljs-keyword">index</span>; i--)                x = x.prev;            <span class="hljs-keyword">return</span> x;        &#125;&#125;<span class="hljs-comment">// e: 待插入节点</span><span class="hljs-comment">// succ: index位置上的节点</span><span class="hljs-keyword">void</span> linkBefore(E e, Node&lt;E&gt; succ) &#123;        <span class="hljs-comment">// assert succ != null;</span>    <span class="hljs-comment">// 用pred为插入位置节点的前驱结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;                <span class="hljs-comment">// 创建新节点，值为插入节点e，前驱结点为pred，后继为succ</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, succ);                <span class="hljs-comment">// succ的前驱改为newNode，不再是pred</span>        succ.prev = newNode;                <span class="hljs-comment">// 如果pred为空，就是插入位置为链表头结点</span>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// newNode就是头结点</span>            first = newNode;        <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则，pred的后继为newNode</span>            pred.next = newNode;                    size++;        modCount++;&#125;</code></pre><h4 id="addAll-Collection-lt-extends-E-gt-c-方法-1"><a href="#addAll-Collection-lt-extends-E-gt-c-方法-1" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)方法"></a>addAll(Collection&lt;? extends E&gt; c)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 调用addAll(index, e)方法，也就是Collection构造函数时使用的那个方法</span>    <span class="hljs-keyword">return</span> addAll(size, c);&#125;</code></pre><h4 id="addAll-int-index-Collection-lt-extends-E-gt-c-方法-1"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c-方法-1" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)方法"></a>addAll(int index, Collection&lt;? extends E&gt; c)方法</h4><p>详见Collection构造函数调用 <a href="https://nyimac.gitee.io/2020/09/10/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/#Collection%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><strong>addAll()方法</strong></a>时的分析 </p><h3 id="3、移除方法-1"><a href="#3、移除方法-1" class="headerlink" title="3、移除方法"></a>3、移除方法</h3><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h4><p>remove()方法就是调用的removeFirst()方法，实际上是<strong>对removeFirst()及unlinkFirst()</strong>的解析</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 调用removeFirst()方法，移除链表首个元素</span>    <span class="hljs-keyword">return</span> removeFirst();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 创建新节点f用于保存头结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;    <span class="hljs-comment">// 如果头结点为空，也就是链表为空，抛出异常</span>        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();    <span class="hljs-comment">// 调用unlinkFirst()方法，并返回结果</span>        <span class="hljs-keyword">return</span> unlinkFirst(f);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span>    <span class="hljs-comment">// 创建element保存头结点的值，用于最后的返回</span>        <span class="hljs-keyword">final</span> E element = f.item;        <span class="hljs-comment">// next保存头结点后面的一个节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;        <span class="hljs-comment">// 头结点的属性置空，方便回收</span>        f.item = <span class="hljs-keyword">null</span>;        f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        <span class="hljs-comment">// 头指针first后移</span>        first = next;        <span class="hljs-comment">// 如果链表只有一个节点</span>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">// 尾指针为空</span>            last = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//否则，next的前驱结点为null（next现在是头结点）</span>            next.prev = <span class="hljs-keyword">null</span>;        size--;        modCount++;        <span class="hljs-comment">// 返回被移除的节点的值</span>        <span class="hljs-keyword">return</span> element;&#125;</code></pre><h4 id="removeFirst-方法"><a href="#removeFirst-方法" class="headerlink" title="removeFirst()方法"></a>removeFirst()方法</h4><p>见remove()方法解析</p><h4 id="removeLast-方法"><a href="#removeLast-方法" class="headerlink" title="removeLast()方法"></a>removeLast()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 创建新节点l保存尾节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-comment">// 如果尾节点为空(链表为空)，就抛出异常</span>        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-comment">// 返回unlinkLast()方法的返回结果</span>        <span class="hljs-keyword">return</span> unlinkLast(l);&#125;<span class="hljs-comment">// 该方法和unlinkFirst方法类似，只不过是对尾节点进行删除操作</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;        <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span>        <span class="hljs-keyword">final</span> E element = l.item;        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;        l.item = <span class="hljs-keyword">null</span>;        l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        last = prev;        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)            first = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span>            prev.next = <span class="hljs-keyword">null</span>;        size--;        modCount++;        <span class="hljs-keyword">return</span> element;&#125;</code></pre><h4 id="remove-Object-o-方法-1"><a href="#remove-Object-o-方法-1" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h4><p>移除<strong>首个</strong>遇到的指定元素</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">// 如果要删除的元素为null</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 从头开始遍历链表</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-comment">// 遇到节点值为null的，就调用unlink()方法执行删除操作</span>                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;                    unlink(x);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 从头开始遍历链表 </span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-comment">// 如果是要删除的元素，就调用unlink()方法执行删除操作</span>                <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;                    unlink(x);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;        <span class="hljs-comment">// assert x != null;</span>    <span class="hljs-comment">// 保存被删除节点的值，用于返回</span>        <span class="hljs-keyword">final</span> E element = x.item;        <span class="hljs-comment">// next节点用于保存被删除节点的后继节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;        <span class="hljs-comment">// prev节点用于保存被删除节点的前驱结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;    <span class="hljs-comment">// 如果前驱节点为null，即被删除的节点是头结点</span>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 头指针指向被删除节点的下一个节点（next）</span>            first = next;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 否则，被删除节点的前驱结点指向其后继节点</span>            prev.next = next;            <span class="hljs-comment">// 被删除节点的前驱结点为null</span>            x.prev = <span class="hljs-keyword">null</span>;        &#125;    <span class="hljs-comment">// 如果没有后继节点，即被删除元素是链表的尾节点</span>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 尾指针指向被删除节点的前一个节点</span>            last = prev;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 否则，被删除节点的后继节点指向其前驱结点</span>            next.prev = prev;                        <span class="hljs-comment">// 被删除节点的后继节点为null</span>            x.next = <span class="hljs-keyword">null</span>;        &#125;    <span class="hljs-comment">// 被删除节点的属性为null</span>        x.item = <span class="hljs-keyword">null</span>;        size--;        modCount++;        <span class="hljs-keyword">return</span> element;&#125;</code></pre><p><strong>可以看到，unlinkFirst()、unlinkLast()和unlink()方法非常类似</strong>，都用于让某个节点从链表中<strong>移除</strong>的操作。只不过unlinkFirst和unlinkLast删除的是头、尾节点，实现相对简单。而unlink则是一个更完整的实现，可以删除链表中的任一元素</p><h4 id="remove-int-index-方法-1"><a href="#remove-int-index-方法-1" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<span class="hljs-comment">// 检查索引是否越界</span>    checkElementIndex(index);        <span class="hljs-comment">// 找到该位置的节点，调用unlink方法进行删除</span>    <span class="hljs-keyword">return</span> unlink(node(index));&#125;</code></pre><h4 id="removeFirstOccurrence-Object-o-方法"><a href="#removeFirstOccurrence-Object-o-方法" class="headerlink" title="removeFirstOccurrence(Object o)方法"></a>removeFirstOccurrence(Object o)方法</h4><p>该方法用于移除链表中<strong>第一次出现</strong>该元素的节点</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">remove</span>(o);&#125;</code></pre><p>可以看出removeFirstOccurrence(Object o)方法其实就是调用的remove(Object o)方法，来进行链表首个指定元素的删除操作的</p><h4 id="removeLastOccurrence-Object-o-方法"><a href="#removeLastOccurrence-Object-o-方法" class="headerlink" title="removeLastOccurrence(Object o)方法"></a>removeLastOccurrence(Object o)方法</h4><p>该方法用于移除链表中<strong>最后一次出现</strong>该元素的节点</p><pre><code class="hljs gml">public boolean removeLastOccurrence(Object o) &#123;<span class="hljs-comment">// 从链表尾部进行查询，找到指定元素，删除后返回</span>    <span class="hljs-keyword">if</span> (o == null) &#123;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; <span class="hljs-symbol">x</span> = last; <span class="hljs-symbol">x</span> != null; <span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span>.prev) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-symbol">x</span>.item == null) &#123;                unlink(<span class="hljs-symbol">x</span>);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; <span class="hljs-symbol">x</span> = last; <span class="hljs-symbol">x</span> != null; <span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span>.prev) &#123;            <span class="hljs-keyword">if</span> (o.equals(<span class="hljs-symbol">x</span>.item)) &#123;                unlink(<span class="hljs-symbol">x</span>);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h3 id="4、迭代器"><a href="#4、迭代器" class="headerlink" title="4、迭代器"></a>4、迭代器</h3><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;    <span class="hljs-keyword">private</span> Node&lt;E&gt; next;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextIndex;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;    <span class="hljs-comment">// 构造方法，如果不传入index参数，则默认传入0</span>    ListItr(<span class="hljs-keyword">int</span> index) &#123;        <span class="hljs-comment">// assert isPositionIndex(index);</span>        <span class="hljs-comment">// 给next和nextIndex赋值</span>        next = (index == size) ? <span class="hljs-keyword">null</span> : node(index);        nextIndex = index;    &#125;    <span class="hljs-comment">// 是否还有下一个元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 索引小于size则返回true</span>        <span class="hljs-keyword">return</span> nextIndex &lt; size;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 检查是否有并发问题，modeCount与expectedModCount是否相等</span>        checkForComodification();                <span class="hljs-comment">// 如果没有下一个元素了，就抛出异常</span>        <span class="hljs-keyword">if</span> (!hasNext())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-comment">// 用于返回的元素</span>        lastReturned = next;                <span class="hljs-comment">// 后移一位</span>        next = next.next;                <span class="hljs-comment">// 索引+1</span>        nextIndex++;                <span class="hljs-comment">// 返回元素的值</span>        <span class="hljs-keyword">return</span> lastReturned.item;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> nextIndex &gt; <span class="hljs-number">0</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (modCount != expectedModCount)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;</code></pre><p><strong>注意</strong>：使用迭代器遍历时，如果要删除，请<strong>使用迭代器中的remove()方法</strong>，而不要使用LinkedList实现的remove()方法。和<a href="https://nyimac.gitee.io/2020/09/10/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/#6%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8">ArrayList相似</a></p><h3 id="5、清空方法"><a href="#5、清空方法" class="headerlink" title="5、清空方法"></a>5、清空方法</h3><h4 id="clear-方法-1"><a href="#clear-方法-1" class="headerlink" title="clear()方法"></a>clear()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Clearing all of the links between nodes is "unnecessary", but:</span>    <span class="hljs-comment">// - helps a generational GC if the discarded nodes inhabit</span>    <span class="hljs-comment">//   more than one generation</span>    <span class="hljs-comment">// - is sure to free memory even if there is a reachable Iterator</span>        <span class="hljs-comment">// 从头节点开始遍历链表，将每个节点的每个属性都设置为null，以便于GC更彻底的清理</span>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; ) &#123;        Node&lt;E&gt; next = x.next;        x.item = <span class="hljs-keyword">null</span>;        x.next = <span class="hljs-keyword">null</span>;        x.prev = <span class="hljs-keyword">null</span>;        x = next;    &#125;        first = last = <span class="hljs-keyword">null</span>;    size = <span class="hljs-number">0</span>;    modCount++;&#125;</code></pre><h3 id="6、包含方法"><a href="#6、包含方法" class="headerlink" title="6、包含方法"></a>6、包含方法</h3><h4 id="contains-Object-o-方法-1"><a href="#contains-Object-o-方法-1" class="headerlink" title="contains(Object o)方法"></a>contains(Object o)方法</h4><p>从头遍历，遇到需要查找的元素就<strong>返回其索引</strong>，然后<strong>根据其索引来判断是否有该元素</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-keyword">return</span> indexOf(o) != -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> index;                index++;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (o.equals(x.item))                    <span class="hljs-keyword">return</span> index;                index++;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h4 id="区分node-indexOf-和lastIndexOf-方法"><a href="#区分node-indexOf-和lastIndexOf-方法" class="headerlink" title="区分node(), indexOf()和lastIndexOf()方法"></a>区分node(), indexOf()和lastIndexOf()方法</h4><p>相同点</p><ul><li>这三个方法都用于查找</li></ul><p>不同点</p><ul><li>node(index)方法是用来<strong>返回指定索引处的节点的</strong></li><li>indexOf(o)是用来返回<strong>第一次</strong>遇到o时，<strong>节点的索引</strong>（从前往后找）</li><li>lastIndexOf(o)是用来返回<strong>最后一次</strong>遇到o时，<strong>节点的索引</strong>（从后往前找）</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>参考<a href="https://www.bilibili.com/video/BV18E411C7kD?from=search&seid=7736271791290237476" target="_blank" rel="noopener"><strong>Java 7/8 HashMap源码详解与面试题分析</strong></a></p><h2 id="一、哈希表简介"><a href="#一、哈希表简介" class="headerlink" title="一、哈希表简介"></a>一、哈希表简介</h2><p>可以参考<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#%E4%B8%83%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><strong>Java数据结构与算法——哈希表</strong></a></p><ul><li>核心是基于哈希值的<strong>桶和链表</strong><ul><li>一般用数组实现桶</li><li>发生哈希碰撞时，用链表来链接发生碰撞的元素</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200912171718.png" srcset="/img/loading.gif" alt=""></p><ul><li>O(1)的平均查找、插入、删除时间</li><li>致命缺点是<strong>哈希值的碰撞</strong>(collision)<ul><li>哈希碰撞：元素通过哈希函数计算后，被映射到同一个桶中。例如上图中的桶1, 5中的元素就发生了哈希碰撞</li></ul></li></ul><h2 id="二、继承关系"><a href="#二、继承关系" class="headerlink" title="二、继承关系"></a>二、继承关系</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200912194932.png" srcset="/img/loading.gif" alt=""></p><h2 id="三、Java-7-HashMap"><a href="#三、Java-7-HashMap" class="headerlink" title="三、Java 7 HashMap"></a>三、Java 7 HashMap</h2><p><strong>这里只针对 Java 7 中不足的地方做简单分析</strong></p><h3 id="1、构造方法-2"><a href="#1、构造方法-2" class="headerlink" title="1、构造方法"></a>1、构造方法</h3><h4 id="无参构造方法-1"><a href="#无参构造方法-1" class="headerlink" title="无参构造方法"></a>无参构造方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 默认初始化容量 2^4 = 16</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">// 最大容量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">// 默认负载因子 0.75，用于计算阈值，进行扩容操作。选择0.75是一种在时间和空间上的折中选择 </span><span class="hljs-comment">// 如果当前哈希表中的元素个数 &gt;= 容量 × 负载因子，就会进行扩容，否则可能就会发生严重的哈希碰撞</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-comment">// 此处调用了含容量和负载因子的构造方法来进行初始化操作</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;</code></pre><h4 id="含容量的构造方法"><a href="#含容量的构造方法" class="headerlink" title="含容量的构造方法"></a>含容量的构造方法</h4><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123; <span class="hljs-comment">// 调用了含容量和负载因子的构造方法来进行初始化操作，其中容量为传入的容量，负载因子为默认负载因子0.75</span>        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;</code></pre><h4 id="含容量和负载因子的构造方法"><a href="#含容量和负载因子的构造方法" class="headerlink" title="含容量和负载因子的构造方法"></a>含容量和负载因子的构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    <span class="hljs-comment">// 如果传入的初始化容量小于0，则抛出异常</span>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +                                               initialCapacity);        <span class="hljs-comment">// 如果传入的容量大于最大容量，就初始化为最大容量</span>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        <span class="hljs-comment">// 如果负载因子小于0，或者是非法的浮点数，抛出异常</span>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +                                               loadFactor);        <span class="hljs-comment">// 根据传入的负载因子给负载因子赋值</span>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;       <span class="hljs-comment">// int threshold</span>    <span class="hljs-comment">// 阈值，容量×负载因子。目前大小为initialCapacity（还未扩容）</span>    <span class="hljs-comment">// 超过阈值进行扩容操作</span>        threshold = initialCapacity;        <span class="hljs-comment">// 此处的init()方法是一个空方法，在向哈希表添加元素之前，不会真正地创建哈希表（以免占用过多的内存）</span>        init();&#125;<span class="hljs-comment">// 空方法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><p>可见，无论调用哪种构造函数来初始化HashMap，最终调用的都是<strong>含容量和负载因子的构造方法</strong>，并且都<strong>没有真正的开辟出需要的内存空间</strong></p><h3 id="2、添加方法-2"><a href="#2、添加方法-2" class="headerlink" title="2、添加方法"></a>2、添加方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 空集合，用于判断表是否为空。Entry为hashMap的静态内部类</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-comment">// 如果表是空的，就通过inflateTable()方法进行扩容</span>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;        <span class="hljs-comment">// 等到真正向哈希表中添加元素时，才开辟内存空间</span>        inflateTable(threshold);    &#125;        <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> putForNullKey(value);        <span class="hljs-comment">// 计算要插入元素的哈希值</span>    <span class="hljs-keyword">int</span> hash = hash(key);        <span class="hljs-comment">// 根据哈希值来判断插入元素应该放在哪个桶中</span>    <span class="hljs-comment">// 该方法决定了为什么哈希表的容量是2的幂</span>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);        <span class="hljs-comment">// 遍历哈希表</span>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;        Object k;                <span class="hljs-comment">// 看待插入元素在哈希表中是否已近存在了，如果存在了，就进行覆盖操作</span>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    modCount++;       <span class="hljs-comment">// 真正的添加操作，采用头插法，下面会单独来说</span>    addEntry(hash, key, value, i);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">// 哈希表扩容函数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inflateTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> toSize)</span> </span>&#123;        <span class="hljs-comment">// Find a power of 2 &gt;= toSize</span>    <span class="hljs-comment">// 让容量向上舍入变为2的幂。比如toSize = 10 就会变为 16。</span>        <span class="hljs-keyword">int</span> capacity = roundUpToPowerOf2(toSize);    <span class="hljs-comment">// 阈值，向上取整后的容量×负载因子 或 最大容量+1，取其中的较小值</span>    <span class="hljs-comment">// 该变量在第一次放入操作时不会用到</span>        threshold = (<span class="hljs-keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 根据capacity创建哈希表</span>        table = <span class="hljs-keyword">new</span> Entry[capacity];         <span class="hljs-comment">// 创建了一个哈希种子，重构String的hash算法，在后面的潜在安全漏洞会谈到</span>        initHashSeedAsNeeded(capacity);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">roundUpToPowerOf2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">// assert number &gt;= 0 : "number must be non-negative";</span>    <span class="hljs-comment">// 如果容量大于最大容量，就返回最大容量。</span>    <span class="hljs-comment">// 否则调用Integer.highestOneBit()方法让其向上舍入为2的幂</span>        <span class="hljs-keyword">return</span> number &gt;= MAXIMUM_CAPACITY                ? MAXIMUM_CAPACITY                : (number &gt; <span class="hljs-number">1</span>) ? Integer.highestOneBit((number - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 通过一系列移位操作与异或操作获得元素的哈希值。 JDK 8 中已不再使用该方法</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = hashSeed;    <span class="hljs-comment">// 如果哈希种子存在，并且进行哈希的元素的String类型</span>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;            <span class="hljs-comment">// 就让String使用另一种hash算法</span>            <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);        &#125;        h ^= k.hashCode();        <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span>        <span class="hljs-comment">// constant multiples at each bit position have a bounded</span>        <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span>        h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);        <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);&#125;</code></pre><h4 id="为什么哈希表大小一定是2的幂？"><a href="#为什么哈希表大小一定是2的幂？" class="headerlink" title="为什么哈希表大小一定是2的幂？"></a>为什么哈希表大小一定是2的幂？</h4><p>要回答这个问题，我们需要先看看哈希表中一个重要的方法：<strong>static int indexFor(int h, int length)</strong>，该方法会根据插入元素的哈希值<strong>决定该元素应该被放在桶中</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;        <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span>        <span class="hljs-comment">// 将传入的哈希值与其长度-1进行按位与操作，并返回其结果</span>        <span class="hljs-keyword">return</span> h &amp; (length<span class="hljs-number">-1</span>);&#125;</code></pre><p>我们知道，哈希表的致命缺点是发生<strong>哈希碰撞</strong>，也就是<strong>多个哈希值相同的元素被放置到了同一个桶中</strong></p><p>想要尽量避免发生哈希碰撞，分别分到不同的桶中，<strong>h &amp; (length-1)</strong> 就是这样一个操作，<strong>根据元素的哈希值和哈希表的长度-1来按位与</strong>，并且与运算的速度快，效率高</p><p>当哈希表的大小为2的幂时，我们拿16来举例，它的二进制表示是 <strong>10000</strong> ， 让其<strong>长度-1</strong>后就是 <strong>1111</strong>，全部都是1</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200912201609.png" srcset="/img/loading.gif" alt=""></p><p>我们知道，当<strong>一个二进制数与全为1的数进行按位与时，其结果就是该数本身并且小于等于桶的最大数量</strong>。这样一来，只要数不同，那么他们按位与下来的值也就不同了，所以我们需要哈希表的容量为2的幂</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200912201909.png" srcset="/img/loading.gif" alt=""></p><p><strong>为什么使用位运算，而不是直接取模？</strong></p><p><strong>位运算(&amp;)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</strong></p><h4 id="addEntry-方法"><a href="#addEntry-方法" class="headerlink" title="addEntry()方法"></a>addEntry()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;    <span class="hljs-comment">// 如果哈希表中的元素个数超过了阈值，并且该元素应该放入的桶中已经有了元素</span>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-keyword">null</span> != table[bucketIndex])) &#123;        <span class="hljs-comment">// 进行扩容，扩容大小为原大小的2倍，以保证扩容后容量仍为2的幂</span>        <span class="hljs-comment">// 并将扩容前哈希表中的元素全部重新计算哈希值，并放入到扩容后的桶中</span>        resize(<span class="hljs-number">2</span> * table.length);                <span class="hljs-comment">// 重新计算哈希值</span>        hash = (<span class="hljs-keyword">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;        bucketIndex = indexFor(hash, table.length);    &#125;    <span class="hljs-comment">// 创建节点，采用头插法将其放在对应的桶中</span>    createEntry(hash, key, value, bucketIndex);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;        Entry[] oldTable = table;        <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;        <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span>;        &#125;    <span class="hljs-comment">// 扩容为新容量</span>        Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];        <span class="hljs-comment">// 重新计算元素哈希值，再放入到扩容后的哈希表中</span>        transfer(newTable, initHashSeedAsNeeded(newCapacity));        table = newTable;        <span class="hljs-comment">//重新计算阈值</span>        threshold = (<span class="hljs-keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;        <span class="hljs-keyword">int</span> newCapacity = newTable.length;        <span class="hljs-comment">// 遍历原来哈希表中的元素</span>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;            <span class="hljs-comment">// 如果桶中元素不为空，就重新计算起哈希值，然后放入到扩容后的哈希表中</span>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123;                Entry&lt;K,V&gt; next = e.next;                <span class="hljs-keyword">if</span> (rehash) &#123;                    e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);                &#125;                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                                <span class="hljs-comment">// 扩容转移时使用头插法</span>                newTable[i] = e;                e = next;            &#125;        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;        Entry&lt;K,V&gt; e = table[bucketIndex];        <span class="hljs-comment">// 将新节点放在桶的第一个位置，也就是采用头插法进行插入</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;        Entry&lt;K,V&gt; e = table[bucketIndex];        table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);        size++;    &#125;        table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);        size++;&#125;</code></pre><h3 id="3、存在的问题"><a href="#3、存在的问题" class="headerlink" title="3、存在的问题"></a>3、存在的问题</h3><h4 id="容易发生死锁"><a href="#容易发生死锁" class="headerlink" title="容易发生死锁"></a>容易发生死锁</h4><p>因为HashMap本身是<strong>线程不安全</strong>的，所以在多线程环境下，可能会发生死锁问题</p><p>参考<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener"><strong>疫苗：Java HashMap的死循环</strong></a></p><h4 id="潜在的安全漏洞"><a href="#潜在的安全漏洞" class="headerlink" title="潜在的安全漏洞"></a>潜在的安全漏洞</h4><p>哈希碰撞可能使哈希表<strong>退化为链表</strong>，链表的查询效率低，一旦退话，将会严重拖慢我们程序的性能</p><p>String的哈希算法<strong>很容易就能产生多个哈希值相同字符串</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> h = hash;        <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">char</span> val[] = value;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;                h = <span class="hljs-number">31</span> * h + val[i];            &#125;            hash = h;        &#125;        <span class="hljs-keyword">return</span> h;&#125;</code></pre><p>黑客可以在url中携带多个哈希值一样的字符串，来访问我们的服务器，此时因为所有字符串的哈希值相同，所以都会被放到同一个桶中，使得哈希表退化为链表，大幅度降低我们的性能。为了避免这种攻击，<strong>在 JDK 7 的哈希表中，重构了String类型计算哈希值的方法</strong></p><h2 id="四、Java-8-HashMap"><a href="#四、Java-8-HashMap" class="headerlink" title="四、Java 8 HashMap"></a>四、Java 8 HashMap</h2><h3 id="1、红黑树TreeMap"><a href="#1、红黑树TreeMap" class="headerlink" title="1、红黑树TreeMap"></a>1、红黑树TreeMap</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>一种<strong>二叉查找树</strong>，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（<strong>非红即黑</strong>）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保<strong>没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种<strong>弱平衡二叉树</strong>（由于是弱平衡，可以看到，<strong>在相同的节点情况下，AVL树的高度低于红黑树）</strong>，相对于要求严格的AVL树来说，它的旋转次数少，所以<strong>对于搜索，插入，删除操作较多的情况下，我们就用红黑树</strong></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>每个节点非红即黑</li><li>根节点（root）是黑的</li><li><strong>不能有两个红色的节点连在一起</strong>（黑色可以）</li><li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的</li><li>如果一个节点是红的，那么它的两儿子都是黑的</li><li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点</li><li>每条路径<strong>都包含相同的黑节点</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913110321.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913163158.png" srcset="/img/loading.gif" alt=""></p><h4 id="为什么用到了红黑树"><a href="#为什么用到了红黑树" class="headerlink" title="为什么用到了红黑树"></a>为什么用到了红黑树</h4><p>让我们来看看注释</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">HashMap 底层是基于散列算法实现，散列算法分为散列再探测和拉链式。HashMap 则使用了拉链式的散列算法，并在 JDK 1.8 中引入了红黑树优化过长的链表</span><span class="hljs-comment">    实现注意事项。</span><span class="hljs-comment">    链表结构（这里叫 bin ，箱子）</span><span class="hljs-comment">    Map通常充当一个binned（桶）的哈希表，但是当箱子变得太大时，它们就会被转换成TreeNodes的箱子，每个箱子的结构都类似于java.util.TreeMap。</span><span class="hljs-comment">    大多数方法都尝试使用普通的垃圾箱，但是在适用的情况下（只要检查一个节点的实例）就可以传递到TreeNode方法。</span><span class="hljs-comment">    可以像其他的一样遍历和使用TreeNodes，但是在过度填充的时候支持更快的查找</span><span class="hljs-comment">    然而，由于大多数正常使用的箱子没有过多的填充，所以在表方法的过程中，检查树箱的存在可能会被延迟。</span><span class="hljs-comment">    树箱(bins即所有的元素都是TreeNodes）主要是由hashCode来排序的，但是在特定的情况下，</span><span class="hljs-comment">    如果两个元素是相同的“实现了Comparable接口”，那么使用它们的比较方法排序。</span><span class="hljs-comment">    （我们通过反射来保守地检查泛型类型，以验证这一点——参见方法comparableClassFor）。</span><span class="hljs-comment">    使用树带来的额外复杂，是非常有价值的，因为能提供了最坏只有O(log n)的时间复杂度当键有不同的散列或可排序。</span><span class="hljs-comment">    因此,性能降低优雅地在意外或恶意使用hashCode()返回值的分布很差,以及许多key共享一个hashCode,只要他们是可比较的。</span><span class="hljs-comment">    （如果这两种方法都不适用，同时不采取任何预防措施，我们可能会在时间和空间上浪费大约两倍的时间。</span><span class="hljs-comment">    但是，唯一已知的案例源于糟糕的用户编程实践，这些实践已经非常缓慢，这几乎没有什么区别。）</span><span class="hljs-comment">    因为TreeNodes大小大约是普通节点的两倍，所以只有当容器包含足够的节点来保证使用时才使用它们（见treeifythreshold）。</span><span class="hljs-comment">    当它们变得太小（由于移除或调整大小），它们就会被转换回普通bins。</span><span class="hljs-comment">    在使用良好的用户hashcode的用法中，很少使用树箱。</span><span class="hljs-comment">    理想情况下，在随机的hashcode中，箱子中节点的频率遵循泊松分布（http://en.wikipedia.org/wiki/Poisson_distribution），</span><span class="hljs-comment">    默认大小调整阈值为0.75，但由于调整粒度的大小有很大的差异。</span><span class="hljs-comment">    忽略方差，list的长度 k=(exp(-0.5) * pow(0.5, k) / factorial(k))</span><span class="hljs-comment">    第一个值是:</span><span class="hljs-comment">            0:0.60653066</span><span class="hljs-comment">            1:0.30326533</span><span class="hljs-comment">            2:0.07581633</span><span class="hljs-comment">            3:0.01263606</span><span class="hljs-comment">            4:0.00157952</span><span class="hljs-comment">            5:0.00015795</span><span class="hljs-comment">            6:0.00001316</span><span class="hljs-comment">            7:0.00000094</span><span class="hljs-comment">            8:0.00000006</span><span class="hljs-comment">    more: less than 1 in ten million 如果再多的话，概率就小于十万分之一了</span><span class="hljs-comment">    树箱（tree bin很难翻译啊！）的根通常是它的第一个节点。</span><span class="hljs-comment">    然而，有时（目前只在Iterator.remove）中，根可能在其他地方，但是可以通过父链接（方法TreeNode.root()）恢复。</span><span class="hljs-comment">    所有适用的内部方法都接受散列码作为参数（通常由公共方法提供），允许它们在不重新计算用户hashcode的情况下调用彼此。</span><span class="hljs-comment">    大多数内部方法也接受一个“标签”参数，通常是当前表，但在调整或转换时可能是新的或旧的。</span><span class="hljs-comment">    当bin列表被树化、分割或取消时（ treeified, split, or untreeified），我们将它们保持在相同的相对存取/遍历顺序（例如</span><span class="hljs-comment">    字段Node.next）为了更好地保存位置，并稍微简化对调用迭代器的拆分和traversals的处理(splits and traversals that invoke iterator.remove)。</span><span class="hljs-comment">    当在插入中使用比较器时，为了在重新平衡中保持一个总排序（或者在这里需要的接近），我们将类和标识符码作为连接开关。</span><span class="hljs-comment">    由于子类LinkedHashMap的存在，普通(plain)与树模型(tree modes)之间的使用和转换变得复杂起来。</span><span class="hljs-comment">    请参阅下面的hook方法，这些方法在插入、删除和访问时被调用，允许LinkedHashMap内部结构保持独立于这些机制。</span><span class="hljs-comment">            （这还要求将Map实例传递给一些可能创建新节点的实用方法。）</span><span class="hljs-comment">    concurrent-programming-like SSA-based编码风格有助于避免在所有扭曲的指针操作中出现混叠错误。</span><span class="hljs-comment">*/</span></code></pre><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历<strong>查找会非常慢</strong></p><p>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了<strong>查找数据快</strong>O(log n)，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当<strong>桶中元素大于8并且桶的个数大于64</strong>的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢</p><p>链表转红黑树体现了<strong>空间换时间</strong>的思想</p><h3 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h3><pre><code class="hljs java"><span class="hljs-comment">// 初始容量 16 (2的4次方)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">// 最大容量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">// 默认负载因子，默认为0.75，用于和容量一起决定扩容的阈值</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-comment">// 使用红黑树的阈值，当桶中的元素个数（链表长度）大于8时，才会使用红黑树进行存储</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<span class="hljs-comment">// 使用链表的阈值，当桶中的元素个数小于6个时，就会由红黑树转变为链表</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<span class="hljs-comment">// 最小的红黑树化的桶数，当桶的个数大于64个时，就会使用红黑树进行存储</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<span class="hljs-comment">// Node数组，也就是桶</span><span class="hljs-keyword">transient</span> Node&lt;K, V&gt;[] table;<span class="hljs-comment">// 缓存entrySet</span><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<span class="hljs-comment">// map中k-v键值对的个数</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">// 修改访问标记</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<span class="hljs-comment">// 扩容阈值，等于 容量 × 负载因子，初始化时值为向上取2的幂</span><span class="hljs-keyword">int</span> threshold;<span class="hljs-comment">// 负载因子</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;</code></pre><h3 id="3、存储结构"><a href="#3、存储结构" class="headerlink" title="3、存储结构"></a>3、存储结构</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-keyword">this</span>.hash = hash;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;        <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">"="</span> + value; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;        V oldValue = value;        value = newValue;        <span class="hljs-keyword">return</span> oldValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h3 id="4、构造方法"><a href="#4、构造方法" class="headerlink" title="4、构造方法"></a>4、构造方法</h3><h4 id="无参构造方法-2"><a href="#无参构造方法-2" class="headerlink" title="无参构造方法"></a>无参构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 初始化了负载因子</span>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>&#125;</code></pre><h4 id="HashMap-int-initialCapacity-构造方法"><a href="#HashMap-int-initialCapacity-构造方法" class="headerlink" title="HashMap(int initialCapacity)构造方法"></a>HashMap(int initialCapacity)构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;</code></pre><h4 id="HashMap-int-initialCapacity-float-loadFactor-方法"><a href="#HashMap-int-initialCapacity-float-loadFactor-方法" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)方法"></a>HashMap(int initialCapacity, float loadFactor)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +                                           initialCapacity);    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +                                           loadFactor);    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;        <span class="hljs-comment">// 阈值，初始化时为传入容量取幂后的值</span>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);&#125;<span class="hljs-comment">// 容量向上取整为2的幂</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="5、添加方法"><a href="#5、添加方法" class="headerlink" title="5、添加方法"></a>5、添加方法</h3><h4 id="put-K-V-方法"><a href="#put-K-V-方法" class="headerlink" title="put(K, V)方法"></a>put(K, V)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-comment">// 因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的</span><span class="hljs-comment">// 那么这种处理就可以有效避免类似情况下的哈希碰撞</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;    <span class="hljs-comment">// 如果key不为null，就让key的高16位和低16位取异或</span>    <span class="hljs-comment">// 和Java 7 相比，hash算法确实简单了不少</span>    <span class="hljs-comment">// 使用异或尽可能的减少碰撞</span>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;<span class="hljs-comment">// 放入元素的操作</span><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    <span class="hljs-comment">// tab相当于哈希表</span>        Node&lt;K,V&gt;[] tab;     Node&lt;K,V&gt; p;         <span class="hljs-comment">// n保存了桶的个数</span>    <span class="hljs-comment">// i保存了应放在哪个桶中</span>    <span class="hljs-keyword">int</span> n, i;        <span class="hljs-comment">// 如果还没初始化哈希表，就调用resize方法进行初始化操作</span>    <span class="hljs-comment">// resize()方法在后面分析</span>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;            <span class="hljs-comment">// 这里的 (n - 1) &amp; hash 相当于 Java 7 中的indexFor()方法，用于确定元素应该放在哪个桶中</span>    <span class="hljs-comment">// (n - 1) &amp; hash 有以下两个好处：1、放入的位置不会大于桶的个数（n-1全为1） 2、用到了hash值，确定其应放的对应的位置</span>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">// 如果桶中没有元素，就将该元素放到对应的桶中</span>            <span class="hljs-comment">// 把这个元素放到桶中，目前是这个桶里的第一个元素</span>            tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">else</span> &#123;            Node&lt;K,V&gt; e;             <span class="hljs-comment">// 创建和键类型一致的变量</span>            K k;                        <span class="hljs-comment">// 如果该元素已近存在于哈希表中，就覆盖它</span>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                e = p;            <span class="hljs-comment">// 如果采用了红黑树结构，就是用红黑树的插入方法</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);            <span class="hljs-comment">// 否则，采用链表的扩容方式</span>            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// binCount用于计算桶中元素的个数</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                    <span class="hljs-comment">// 找到插入的位置（链表最后）</span>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// 尾插法插入元素</span>                        p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                        <span class="hljs-comment">// 如果桶中元素个数大于阈值，就会调用treeifyBin()方法将其结构改为红黑树(但不一定转换成功)</span>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                            treeifyBin(tab, hash);                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-comment">// 如果遇到了相同的元素，就覆盖它</span>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-keyword">break</span>;                    p = e;                &#125;            &#125;                        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>                V oldValue = e.value;                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                    e.value = value;                afterNodeAccess(e);                <span class="hljs-keyword">return</span> oldValue;            &#125;        &#125;            ++modCount;        <span class="hljs-comment">// 如果size大于阈值，就进行扩容操作</span>        <span class="hljs-keyword">if</span> (++size &gt; threshold)            resize();            afterNodeInsertion(evict);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h4 id="resize-扩容方法"><a href="#resize-扩容方法" class="headerlink" title="resize()扩容方法"></a>resize()扩容方法</h4><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 原容量大于0（已近执行了put操作以后的扩容）</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">// 原容量扩大一倍后小于最大容量，那么newCap就为原容量扩大一倍，同时新阈值为老阈值的一倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">// 调用了含参构造方法的扩容</span>    <span class="hljs-comment">// 原容量小于等于0，但是阈值大于0，那么新容量就位原来的阈值（阈值在调用构造函数时就会确定，但容量不会）</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        newCap = oldThr;        <span class="hljs-comment">// 调用了无参构造方法的扩容操作</span>    <span class="hljs-keyword">else</span> &#123;                       <span class="hljs-comment">// zero initial threshold signifies using defaults</span>        <span class="hljs-comment">// 如果连阈值也为0，那就调用的是无参构造方法，就执行初始化操作</span>        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;        <span class="hljs-comment">// 如果新阈值为0，就初始化它</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);    &#125;        <span class="hljs-comment">// 阈值改为新阈值</span>    threshold = newThr;    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)        <span class="hljs-comment">// 创建新的表，将旧表中的元素进行重新放入</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];    table = newTab;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;                oldTab[j] = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 为空就直接放入</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                                <span class="hljs-comment">// 如果是树节点，就调用红黑树的插入方式</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);                                <span class="hljs-comment">// 链表的插入操作</span>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    <span class="hljs-comment">// lo 和 hi 分别为两个链表，保存了原来一个桶中元素被拆分后的两个链表</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;                        loTail.next = <span class="hljs-keyword">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;                        hiTail.next = <span class="hljs-keyword">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre><p><strong>图解扩容对链表的重构</strong></p><ul><li>比如哈希表中桶的个数是4个，其中0、4、8、12因为低两位都是0，与 4-1=3(11) 进行按位与后，都被放在了第一个桶中</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913155253.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>然后开始了扩容操作。将元素<strong>哈希值按位与旧容量（不是旧容量-1）</strong>为0的放在lo链表中，不为0的放在hi链表中</p><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;    next = e.next;    <span class="hljs-comment">// 当前元素的hash值和容量进行按位与，决定被分配到哪个链表中</span>    <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)            loHead = e;        <span class="hljs-keyword">else</span>            loTail.next = e;        loTail = e;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)            hiHead = e;        <span class="hljs-keyword">else</span>            hiTail.next = e;        hiTail = e;    &#125;&#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);</code></pre></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913155409.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913155424.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913155454.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913155514.png" srcset="/img/loading.gif" alt=""></p><ul><li>遍历链表，将lo中的放在原来的桶中，hi中的放在增加的桶中</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 通过头指针直接将链表放入桶中</span><span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;    loTail.next = <span class="hljs-keyword">null</span>;    newTab[j] = loHead;&#125;<span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;    hiTail.next = <span class="hljs-keyword">null</span>;    newTab[j + oldCap] = hiHead;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200913155710.png" srcset="/img/loading.gif" alt=""></p><p><strong>总结</strong>：</p><ul><li>先将原桶中的元素的<strong>hash值与旧容量进行按位与</strong>操作<ul><li>如果结果为0，就放入lo链表中</li><li>如果结果不为0，就放入hi链表中</li></ul></li><li>lo链表中的元素继续放在新的哈希表中原来的位置</li><li>hi链表中的元素放在新的哈希表中，扩容后相对于原来的位置上(j+oldCap)<ul><li><strong>两个桶之间的间隔数就为增加原来哈希表的容量</strong></li></ul></li></ul><p><strong>好处</strong></p><ul><li>顺序放入，减少了发生死锁的几率</li><li>使得元素<strong>相对均匀</strong>地存在于哈希表中</li></ul><h4 id="putAll-方法"><a href="#putAll-方法" class="headerlink" title="putAll()方法"></a>putAll()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;    putMapEntries(m, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    <span class="hljs-comment">// 获得待插入表的大小</span>        <span class="hljs-keyword">int</span> s = m.size();        <span class="hljs-comment">// 如果待插入表中有元素</span>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果当前哈希表为空</span>            <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span>                <span class="hljs-comment">// 容量调整过程，如果超过阈值，就调用tableSizeFor()方法扩容(直接扩容，因为此时哈希表为空)</span>                <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;                <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?                         (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);                <span class="hljs-keyword">if</span> (t &gt; threshold)                    threshold = tableSizeFor(t);            &#125;            <span class="hljs-comment">// 超过阈值，就调用resize()方法扩容</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)                resize();            <span class="hljs-comment">// 把元素依次放入到哈希表中</span>            <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);            &#125;        &#125;&#125;</code></pre><p>最后这里用到了hash()，那就更深入地研究一下吧！</p><p><a href="https://www.hollischuang.com/archives/2091" target="_blank" rel="noopener"><strong>全网把Map中的hash()分析的最透彻的文章，别无二家</strong></a></p><h3 id="6、移除方法"><a href="#6、移除方法" class="headerlink" title="6、移除方法"></a>6、移除方法</h3><h4 id="remove-方法-1"><a href="#remove-方法-1" class="headerlink" title="remove()方法"></a>remove()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt; e;    <span class="hljs-comment">// 调用removeNode()方法，返回其返回的结果</span>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?        <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><span class="hljs-function"><span class="hljs-params">                               <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;        <span class="hljs-comment">// 桶中有元素, p保存了桶中的首个元素</span>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;                        <span class="hljs-comment">// 找到对应的元素，保存在node中</span>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                node = p;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 遍历链表，找到要删除的元素</span>                    <span class="hljs-keyword">do</span> &#123;                        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                             (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;                            node = e;                            <span class="hljs-keyword">break</span>;                        &#125;                        p = e;                    &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);                &#125;            &#125;                        <span class="hljs-comment">// 该元素不为空</span>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||                                 (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;                <span class="hljs-comment">// 如果是树节点，就调用红黑树的删除方法</span>                <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);                <span class="hljs-comment">// 如果是第一个元素，桶的索引就保存其下一个元素</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)                    tab[index] = node.next;                                <span class="hljs-comment">// 否则就不在指向这个元素</span>                <span class="hljs-keyword">else</span>                    p.next = node.next;                                ++modCount;                --size;                afterNodeRemoval(node);                <span class="hljs-keyword">return</span> node;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="7、查找方法"><a href="#7、查找方法" class="headerlink" title="7、查找方法"></a>7、查找方法</h3><h4 id="get-Object-key-方法"><a href="#get-Object-key-方法" class="headerlink" title="get(Object key)方法"></a>get(Object key)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt; e;    <span class="hljs-comment">// 通过key的哈希值和key来进行查找</span>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;        <span class="hljs-comment">// 哈希表不为空</span>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;            (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// 如果第一个元素就是要查找的元素，就返回</span>            <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>                ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                <span class="hljs-keyword">return</span> first;                        <span class="hljs-comment">// 如果第一个元素不是，就继续往后找。找到就返回，没至找到就返回null</span>            <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                    <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-keyword">return</span> e;                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="8、树化方法"><a href="#8、树化方法" class="headerlink" title="8、树化方法"></a>8、树化方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;        <span class="hljs-comment">// 如果当前哈希表中桶的数目，小于最小树化容量，就调用resize()方法进行扩容</span>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();        <span class="hljs-comment">// 当桶中元素个数大于8，且桶的个数大于64时，进行树化</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">do</span> &#123;            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)                hd = p;            <span class="hljs-keyword">else</span> &#123;                p.prev = tl;                tl.next = p;            &#125;            tl = p;        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)            hd.treeify(tab);    &#125;&#125;</code></pre><p><strong>链表变为红黑树的条件</strong>：元素个数大于8同时桶的个数大于64</p><ul><li>当某个桶中的<strong>元素个数大于8</strong>时，会调用treeifyBin()方法，但并不一定就会变为红黑树</li><li>当哈希表中<strong>桶的个数大于64</strong>时，才会真正进行让其转化为红黑树</li></ul><p><strong>为什么</strong>桶中元素多于了8个，桶的个数小于64，<strong>调用resize()方法就可以进行调整</strong>？</p><ul><li>因为调用resize()方法进行扩容时，会让同一个桶中的<strong>元素进行桶的重新分配</strong>。一部分会被放新哈希表中在原来的位置上，一部分会被放在扩容后的位置上</li></ul><p>详见上面<a href="https://nyimac.gitee.io/2020/09/10/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/#resize-%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><strong>resize()方法的分析和图解</strong></a></p><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h2 id="一、优先队列简介"><a href="#一、优先队列简介" class="headerlink" title="一、优先队列简介"></a>一、优先队列简介</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>平时我们了解到的队列，是一种满足<strong>先进先出</strong>的线性数据结构。优先队列与其有相似之处，但是也有所不同。</p><p>当我们向优先队列中插入元素的时候，<strong>优先队列会根据一定的条件将该元素插入到合适的位置</strong></p><h3 id="2、演示"><a href="#2、演示" class="headerlink" title="2、演示"></a>2、演示</h3><p>创建一个一般队列Queue和优先队列PriorityQueue，分别向队列中以 2、1、3的顺序放入元素，观察他们的遍历结果</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Queue&lt;Integer&gt; normalQueue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();      normalQueue.add(<span class="hljs-number">2</span>);      normalQueue.add(<span class="hljs-number">1</span>);      normalQueue.add(<span class="hljs-number">3</span>);      System.out.println(<span class="hljs-string">"一般队列元素顺序"</span>);      <span class="hljs-keyword">for</span> (Integer num : normalQueue) &#123;         System.out.print(num + <span class="hljs-string">" "</span>);      &#125;      System.out.println();      PriorityQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();      priorityQueue.add(<span class="hljs-number">2</span>);      priorityQueue.add(<span class="hljs-number">1</span>);      priorityQueue.add(<span class="hljs-number">3</span>);      System.out.println(<span class="hljs-string">"优先队列元素顺序"</span>);      <span class="hljs-keyword">for</span> (Integer num : priorityQueue) &#123;         System.out.print(num + <span class="hljs-string">" "</span>);      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">一般队列元素顺序<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> 优先队列元素顺序<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre><h3 id="3、Comparator接口"><a href="#3、Comparator接口" class="headerlink" title="3、Comparator接口"></a>3、Comparator接口</h3><p>当我们想根据对象中的某些特定属性，来对对象进行排序的话，需要实现Comparator中的compare方法</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;    <span class="hljs-comment">// o1为待插入元素，o2为被比较元素</span>    <span class="hljs-keyword">return</span> o1.val - o2.val;&#125;</code></pre><h3 id="4、-Comparable接口"><a href="#4、-Comparable接口" class="headerlink" title="4、 Comparable接口"></a>4、 Comparable接口</h3><p>基本类型的包装类、集合类与接口几乎都实现了这个接口</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200930152042.png" srcset="/img/loading.gif" alt=""></p><p>该接口中的compareTo(T o)一般<strong>用于比较包装类型的大小</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;</code></pre><p>如Integer类中的该方法</p><p>如果该值大于被比较的值，则返回1</p><p>相等则返回0，小于则返回-1</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Integer anotherInteger)</span> </span>&#123;    <span class="hljs-keyword">return</span> compare(<span class="hljs-keyword">this</span>.value, anotherInteger.value);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> (x &lt; y) ? -<span class="hljs-number">1</span> : ((x == y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);&#125;</code></pre><h3 id="5、按对象中的特定值进行插入"><a href="#5、按对象中的特定值进行插入" class="headerlink" title="5、按对象中的特定值进行插入"></a>5、按对象中的特定值进行插入</h3><p>如果我们想将<strong>对象</strong>放入PriorityQueue中，并<strong>按照指定的方式进行排序</strong>，可以这样做</p><p>创建优先队列是，传入Comparator对象，并重写其compare方法，则会按照我们设定的规定进行比较</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 创建优先队列，传入Comparator对象，并重写其compare方法</span>      PriorityQueue&lt;Student&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;            <span class="hljs-comment">// 其中o1为要插入的值，o2为比较的目标值</span>            <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();         &#125;      &#125;);      Student st1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"A"</span>, <span class="hljs-number">3</span>);      Student st2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"B"</span>, <span class="hljs-number">1</span>);      Student st3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"C"</span>, <span class="hljs-number">2</span>);      priorityQueue.add(st1);      priorityQueue.add(st2);      priorityQueue.add(st3);      <span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123;         System.out.println(priorityQueue.remove());      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">private</span> String name;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.age = age;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> age;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.age = age;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +            <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">", age="</span> + age +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;</code></pre><h2 id="二、大顶堆和小顶堆"><a href="#二、大顶堆和小顶堆" class="headerlink" title="二、大顶堆和小顶堆"></a>二、大顶堆和小顶堆</h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><p>大顶堆和小顶堆都是完全二叉树，并且具有以下性质</p><p><strong>大顶堆</strong></p><ul><li>根节点的值都大于其所有孩子的值</li></ul><p><strong>小顶堆</strong></p><ul><li>根节点的值都小于其所有孩子的值</li></ul><p>因为大顶堆小顶堆都是完全二叉树，所以大顶堆和小顶堆都<strong>可以用数组加以表示</strong></p><p>如果一个数组，根节点的下标为index</p><ul><li>那么它左孩子的下标为2*index+1，</li><li>右孩子的值为2*(index+1)</li></ul><p><strong>以小顶堆为例</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200930140529.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、如何构造"><a href="#2、如何构造" class="headerlink" title="2、如何构造"></a>2、如何构造</h3><p>若我们要构建小顶堆，当叶子节点的值小于其父节点的值时，将其于其父节点的值进行交换，知道换在了合适的位置上。我们称这个过程为<strong>上浮</strong></p><p>详见：<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#11%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"><strong>Java数据结构与算法——堆排序</strong></a></p><h2 id="三、属性和存储结构"><a href="#三、属性和存储结构" class="headerlink" title="三、属性和存储结构"></a>三、属性和存储结构</h2><pre><code class="hljs java"><span class="hljs-comment">// 默认容量大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">11</span>;<span class="hljs-comment">// Object数组，用于存放我们的元素,在操作过程中体现为堆</span><span class="hljs-keyword">transient</span> Object[] queue; <span class="hljs-comment">// non-private to simplify nested class access</span><span class="hljs-comment">// 数组中元素的个数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<span class="hljs-comment">// 比较器，其中的compare方法可用于比较插入元素的值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator;<span class="hljs-comment">// 操作次数计数器</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span></code></pre><h2 id="四、构造方法"><a href="#四、构造方法" class="headerlink" title="四、构造方法"></a>四、构造方法</h2><h3 id="1、默认构造方法"><a href="#1、默认构造方法" class="headerlink" title="1、默认构造方法"></a>1、默认构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="hljs-keyword">null</span>);&#125;</code></pre><h3 id="2、带初始容量构造方法"><a href="#2、带初始容量构造方法" class="headerlink" title="2、带初始容量构造方法"></a>2、带初始容量构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-keyword">null</span>);&#125;</code></pre><h3 id="3、带比较器的构造方法"><a href="#3、带比较器的构造方法" class="headerlink" title="3、带比较器的构造方法"></a>3、带比较器的构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;    <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);&#125;</code></pre><h3 id="4、带容量和比较器的构造方法"><a href="#4、带容量和比较器的构造方法" class="headerlink" title="4、带容量和比较器的构造方法"></a>4、带容量和比较器的构造方法</h3><p>从上面的三个构造函数可以看出，<strong>最终调用的都是这个构造函数</strong>。如果没有指定容量，就是用默认容量，如果没有指定比较器，就是用默认比较器</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,</span></span><span class="hljs-function"><span class="hljs-params">                     Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;    <span class="hljs-comment">// Note: This restriction of at least one is not actually needed,</span>    <span class="hljs-comment">// but continues for 1.5 compatibility</span>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">1</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-comment">// 初始化数组</span>    <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> Object[initialCapacity];    <span class="hljs-comment">// 给比较器赋值</span>    <span class="hljs-keyword">this</span>.comparator = comparator;&#125;</code></pre><h2 id="五、添加方法"><a href="#五、添加方法" class="headerlink" title="五、添加方法"></a>五、添加方法</h2><h3 id="1、add-E-e-方法"><a href="#1、add-E-e-方法" class="headerlink" title="1、add(E e)方法"></a>1、add(E e)方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">return</span> offer(e);&#125;</code></pre><h3 id="2、offer-E-e-方法"><a href="#2、offer-E-e-方法" class="headerlink" title="2、offer(E e)方法"></a>2、offer(E e)方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    modCount++;    <span class="hljs-comment">// 保存当前元素的个数</span>    <span class="hljs-keyword">int</span> i = size;    <span class="hljs-comment">// 如果元素大于了Object数组的长度，就进行扩容</span>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)        grow(i + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 否则元素个数+1</span>    size = i + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 如果数组中还没有元素，就直接放入</span>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)        queue[<span class="hljs-number">0</span>] = e;    <span class="hljs-comment">// 否则，进行调整操作</span>    <span class="hljs-comment">// 其中i为队列最后一个元素的下一个位置，e为待插入元素</span>    <span class="hljs-keyword">else</span>        siftUp(i, e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h4 id="grow-int-minCapacity-方法"><a href="#grow-int-minCapacity-方法" class="headerlink" title="grow(int minCapacity)方法"></a>grow(int minCapacity)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">int</span> oldCapacity = queue.length;    <span class="hljs-comment">// Double size if small; else grow by 50%</span>    <span class="hljs-comment">// 如果队列容量小于64，就按照两倍扩容，否则就扩容50%</span>    <span class="hljs-comment">// 如 20 -&gt; 42    100 -&gt; 150</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="hljs-number">64</span>) ?                                     (oldCapacity + <span class="hljs-number">2</span>) :                                     (oldCapacity &gt;&gt; <span class="hljs-number">1</span>));    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);        <span class="hljs-comment">// 扩容后的复制操作</span>    queue = Arrays.copyOf(queue, newCapacity);&#125;</code></pre><h4 id="siftUp-int-k-E-x-函数"><a href="#siftUp-int-k-E-x-函数" class="headerlink" title="siftUp(int k, E x)函数"></a>siftUp(int k, E x)函数</h4><p>其中k为队列最后一个元素的<strong>下一个位置</strong>，x为<strong>待插入元素</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;    <span class="hljs-comment">// 如果指定了比较器，就使用指定比较器的比较方法</span>    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-keyword">null</span>)        siftUpUsingComparator(k, x);    <span class="hljs-comment">// 否则就使用默认的比较方法</span>    <span class="hljs-keyword">else</span>        siftUpComparable(k, x);&#125;</code></pre><h4 id="指定了比较器的比较方法siftUpUsingComparator-int-k-E-x"><a href="#指定了比较器的比较方法siftUpUsingComparator-int-k-E-x" class="headerlink" title="指定了比较器的比较方法siftUpUsingComparator(int k, E x)"></a>指定了比较器的比较方法siftUpUsingComparator(int k, E x)</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;    <span class="hljs-comment">// 如果要放入的位置不是根节点，就继续</span>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 得到该元素的父节点</span>        <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;                <span class="hljs-comment">// 保存其父节点</span>        Object e = queue[parent];                <span class="hljs-comment">// 如果父节点的值小于插入节点的值，就停止循环</span>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// 否则父节点下沉(插入元素上浮)</span>        queue[k] = e;                <span class="hljs-comment">// k保存其父节点的位置</span>        k = parent;    &#125;    <span class="hljs-comment">// 将待插入元素放到对应的位置</span>    queue[k] = x;&#125;</code></pre><p><strong>图解</strong></p><p>如果小顶堆中要插入元素3</p><p><strong>此时k = 4</strong>，我们通过 <strong>parent = (k-1)/2</strong>，可以得到父节点的下标为1，也是就元素4所在的位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200930144311.png" srcset="/img/loading.gif" alt=""></p><p>3和4通过compare函数进行比较，结果小于0，待插入元素需要上浮，父节点元素需要下沉<strong>queue[k] = e</strong></p><p>然后令 <strong>k = parrent</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200930144459.png" srcset="/img/loading.gif" alt=""></p><p>再次计算父节点的下标 <strong>parent = (k-1)/2 = 0</strong>，也就是元素1</p><p>1与3比较，3&gt;1，结束循环</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)      <span class="hljs-keyword">break</span>;</code></pre><p>将待插入元素放到对应位置<strong>queue[k] = x</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200930144649.png" srcset="/img/loading.gif" alt=""></p><p><strong>总结</strong>：可以看到，待插入元素一直在与其父节点进行比较，如果待插入元素的值小于父节点，则待父节点下沉，待插入元素上浮</p><h4 id="默认比较方法siftUpComparable-int-k-E-x"><a href="#默认比较方法siftUpComparable-int-k-E-x" class="headerlink" title="默认比较方法siftUpComparable(int k, E x)"></a>默认比较方法siftUpComparable(int k, E x)</h4><p>和指定了比较器的比较方法类似，只不过是通过Comparable来实现的</p><h2 id="六、移除元素"><a href="#六、移除元素" class="headerlink" title="六、移除元素"></a>六、移除元素</h2><h3 id="1、remove-函数"><a href="#1、remove-函数" class="headerlink" title="1、remove()函数"></a>1、remove()函数</h3><p>调用父类AbstractQueue的remove()函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 调用改类的poll函数</span>    E x = poll();    <span class="hljs-keyword">if</span> (x != <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();&#125;</code></pre><h4 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll()函数"></a>poll()函数</h4><p>移除队首元素</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// s为新的元素个数</span>    <span class="hljs-keyword">int</span> s = --size;    modCount++;    <span class="hljs-comment">// 队首元素</span>    E result = (E) queue[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 保存最后一个元素</span>    E x = (E) queue[s];    queue[s] = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 如果队列中还有元素</span>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)        <span class="hljs-comment">// 下沉</span>        siftDown(<span class="hljs-number">0</span>, x);    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h4 id="siftDown-int-k-E-x-函数"><a href="#siftDown-int-k-E-x-函数" class="headerlink" title="siftDown(int k, E x)函数"></a>siftDown(int k, E x)函数</h4><p>k为移除元素的位置，x为队尾元素</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-keyword">null</span>)        siftDownUsingComparator(k, x);    <span class="hljs-keyword">else</span>        siftDownComparable(k, x);&#125;</code></pre><h4 id="指定了比较器的siftDownUsingComparator-int-k-E-x-函数"><a href="#指定了比较器的siftDownUsingComparator-int-k-E-x-函数" class="headerlink" title="指定了比较器的siftDownUsingComparator(int k, E x)函数"></a>指定了比较器的siftDownUsingComparator(int k, E x)函数</h4><p>调整小顶堆，让其保持其特性</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;    <span class="hljs-keyword">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (k &lt; half) &#123;        <span class="hljs-comment">// 删除节点的左孩子的下标</span>        <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;                <span class="hljs-comment">// c保存了左孩子的值</span>        Object c = queue[child];                <span class="hljs-comment">// 删除节点的右孩子的下标</span>        <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;                <span class="hljs-comment">// 如果右孩子小标小于size 并且 右孩子的值小于左孩子</span>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;            comparator.compare((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)                        <span class="hljs-comment">// child保存右孩子小标，c保存右孩子</span>            c = queue[child = right];                <span class="hljs-comment">// 如果队尾元素小于c的值，就停止</span>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// 下沉</span>        queue[k] = c;        k = child;    &#125;    <span class="hljs-comment">// 赋值</span>    queue[k] = x;&#125;</code></pre><h4 id="siftDownComparable-int-k-E-x"><a href="#siftDownComparable-int-k-E-x" class="headerlink" title="siftDownComparable(int k, E x)"></a>siftDownComparable(int k, E x)</h4><p>和指定了比较器的比较方法类似，只不过是通过Comparable来实现的</p><h3 id="2、remove-Object-o-方法"><a href="#2、remove-Object-o-方法" class="headerlink" title="2、remove(Object o)方法"></a>2、remove(Object o)方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">// 找到移除元素的下标</span>    <span class="hljs-keyword">int</span> i = indexOf(o);    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 移除该元素</span>        removeAt(i);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h4 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf()方法"></a>indexOf()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-keyword">if</span> (o != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)            <span class="hljs-comment">// 找到该对象并返回</span>            <span class="hljs-keyword">if</span> (o.equals(queue[i]))                <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h4 id="removeAt-int-i-方法"><a href="#removeAt-int-i-方法" class="headerlink" title="removeAt(int i)方法"></a>removeAt(int i)方法</h4><p>移除指定元素，保证移除后仍为小顶堆</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">removeAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span>    modCount++;    <span class="hljs-keyword">int</span> s = --size;    <span class="hljs-keyword">if</span> (s == i) <span class="hljs-comment">// removed last element</span>        queue[i] = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">else</span> &#123;        E moved = (E) queue[s];        queue[s] = <span class="hljs-keyword">null</span>;        siftDown(i, moved);        <span class="hljs-keyword">if</span> (queue[i] == moved) &#123;            siftUp(i, moved);            <span class="hljs-keyword">if</span> (queue[i] != moved)                <span class="hljs-keyword">return</span> moved;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h2 id="六、优先队列的应用"><a href="#六、优先队列的应用" class="headerlink" title="六、优先队列的应用"></a>六、优先队列的应用</h2><h4 id="LeetCode–347-前-K-个高频元素"><a href="#LeetCode–347-前-K-个高频元素" class="headerlink" title="LeetCode–347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">LeetCode–347. 前 K 个高频元素</a></h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200930152616.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;   <span class="hljs-comment">// 哈希表，用于存放数字出现的次数</span>   <span class="hljs-comment">// key：数字 value：出现次数</span>   <span class="hljs-keyword">int</span> length = nums.length;   HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(length);   <span class="hljs-comment">// 遍历数组</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;      <span class="hljs-keyword">if</span> (!map.containsKey(nums[i])) &#123;         <span class="hljs-comment">// 如果该数字是第一次出现，直接放入哈希表中</span>         map.put(nums[i], <span class="hljs-number">1</span>);      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// 否则，将其出现次数+1</span>         map.put(nums[i], map.get(nums[i]) + <span class="hljs-number">1</span>);      &#125;   &#125;   <span class="hljs-comment">// 创建优先队列，小顶堆</span>   PriorityQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;         <span class="hljs-comment">// 插入元素与队尾元素的插值</span>         <span class="hljs-keyword">return</span> map.get(o1) - map.get(o2);      &#125;   &#125;);   <span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;      <span class="hljs-keyword">if</span> (priorityQueue.size() &lt; k) &#123;         priorityQueue.add(key);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(key) &gt; map.get(priorityQueue.peek())) &#123;         <span class="hljs-comment">// 次数最少的元素在队首</span>         priorityQueue.remove();         <span class="hljs-comment">// 放入该数字</span>         priorityQueue.add(key);      &#125;   &#125;   <span class="hljs-keyword">int</span> size = priorityQueue.size();   <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;      result[i] = priorityQueue.remove();   &#125;   <span class="hljs-keyword">return</span> result;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>注解与反射</title>
    <link href="/2020/10/13/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2020/10/13/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h1><h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。</p><h2 id="2、常见注解"><a href="#2、常见注解" class="headerlink" title="2、常见注解"></a>2、常见注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>用于标记重写某个方法</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;&#125;</code></pre><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>用于标记已经过时的方法、属性等内容</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;&#125;</code></pre><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>用于镇压警告</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;    String[] value();&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出注解有这么几个部分</p><ul><li><p>@interface + 注解名称</p></li><li><p>@Target : 注解的作用域</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ElementType &#123;    TYPE,    FIELD,    METHOD,    PARAMETER,    CONSTRUCTOR,    LOCAL_VARIABLE,    ANNOTATION_TYPE,    PACKAGE,<span class="hljs-comment">// JDK 8 以后添加的注解</span>    TYPE_PARAMETER,        TYPE_USE&#125;</code></pre></li></ul><ul><li><p>@Retention : 注解的生命周期</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> RetentionPolicy &#123;    SOURCE,    CLASS,    RUNTIME&#125;</code></pre></li></ul><h2 id="3、元注解"><a href="#3、元注解" class="headerlink" title="3、元注解"></a>3、元注解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>元注解的目的就是<strong>注解其他注解</strong>，Java提供了4个meta-annotation，他们被用来对其他注解提供说明</p></li><li><p>他们可以在 java.lang.annotation 包下被找到</p></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>用于标明注解的作用范围</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;    ElementType[] value();&#125;</code></pre><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>用于标明注解的生命周期</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the retention policy.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the retention policy</span><span class="hljs-comment">     */</span>    <span class="hljs-function">RetentionPolicy <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>用于标明该注解将会被包含在javadoc中</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Documented &#123;&#125;</code></pre><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>用于标明子类可以继承父类的该注解</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Inherited &#123;&#125;</code></pre><h2 id="4、自定义注解"><a href="#4、自定义注解" class="headerlink" title="4、自定义注解"></a>4、自定义注解</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>通过 <strong>@interface</strong> 关键字定义注解名称。此时会自动继承 <strong>java.lang.annotation.Annotation</strong></li><li>需要给定一个或多个元注解</li><li>自定义注解的参数声明方式是 ： <strong>参数类型 参数名称 ();</strong> ，如 String name();<ul><li>可以定义默认值，如 String name () default = “Nyima”;</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-meta">@MyAnnotation</span>(name = <span class="hljs-string">"Main Method"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         &#125;&#125;<span class="hljs-meta">@Target</span>(value = &#123;ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(value =  RetentionPolicy.RUNTIME)<span class="hljs-meta">@interface</span> MyAnnotation &#123;   <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;&#125;</code></pre><h1 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h1><h2 id="1、Java-Reflection"><a href="#1、Java-Reflection" class="headerlink" title="1、Java Reflection"></a>1、Java Reflection</h2><ul><li><p>Reflection 是 Java被视为动态语言（运行时改变其结构）的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p></li><li><p>加载完类之后，在对内存的方法去中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象地称之为：反射</p></li></ul><p>正常方式创建对象：</p><ul><li>引入需要的包的名称</li><li>通过new实例化</li><li>获得实例化对象</li></ul><p>反射方式创建对象：</p><ul><li>实例化对象</li><li>getClass()方法</li><li>得到完整的包的名称</li></ul><h2 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以实现动态创建对象和编译，体现出很大的灵活性</li><li>对性能有所影响</li></ul><h2 id="3、相关API"><a href="#3、相关API" class="headerlink" title="3、相关API"></a>3、相关API</h2><ul><li>java.lang.Class：代表一个类</li><li>java.lang.reflect.Method：代表类的方法</li><li>java.lang.reflect.Field：代表类的成员变量</li><li>java.lang.reflect.Constructor：代表类的构造器</li></ul><h2 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h2><h3 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h3><p>获取类的Class对象有<strong>三种方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<span class="hljs-comment">// 通过反射获取多个User类的Class对象，看其是否相等</span><span class="hljs-comment">// 通过Class类的forName()方法来获得类的Class对象</span>Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.User"</span>);<span class="hljs-comment">// 通过类的class属性获得Class对象</span>Class c2 = User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<span class="hljs-comment">// 通过对象的getClass()方法获得Class对象</span>Class c3 = <span class="hljs-keyword">new</span> User().getClass();System.out.println(c1.hashCode());System.out.println(c2.hashCode());System.out.println(c3.hashCode());c3.getClass();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">1163157884</span><span class="hljs-number">1163157884</span><span class="hljs-number">1163157884</span></code></pre><p><strong>结论</strong>：可以看出，通过反射获取某个类的Class对象，获取的对象都是相同的。也就是每个类有且只有一个Class对象</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Object类中定义以下方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();</code></pre><p>这个方法的返回值就是Class类，<strong>Class类是反射的源头</strong></p><ul><li>Class本身也是一个类</li><li>Class对象<strong>只能由系统建立对象</strong></li><li>一个加载的类在<strong>JVM中只会有一个Class实例</strong></li><li>一个Class对象对应的是一个 加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类中的<strong>所有被加载的结构</strong></li><li><strong>Class类是Reflection的根源</strong>，针对任何你想动态加载、运行的类，唯有先获得相应的对象</li></ul><h4 id="拥有Class对象的类型"><a href="#拥有Class对象的类型" class="headerlink" title="拥有Class对象的类型"></a>拥有Class对象的类型</h4><p>class：外部类、内部内、静态内部类等</p><p>interface：接口</p><p>[]：数组</p><p>enum：枚举</p><p>annotation：注解@interface</p><p>primitive type：基本数据类型</p><p>void</p><pre><code class="hljs javapublic">public class Demo3 &#123;   public static void main(String[] args) &#123;      Class c1 &#x3D; Object.class;      Class c2 &#x3D; Collection.class;      Class c3 &#x3D; int[].class;      Class c4 &#x3D; ElementType.class;      Class c5 &#x3D; SuppressWarnings.class;      Class c6 &#x3D; Integer.class;      Class c7 &#x3D; void.class;   &#125;&#125;</code></pre><h3 id="通过反射获得类的信息"><a href="#通过反射获得类的信息" class="headerlink" title="通过反射获得类的信息"></a>通过反射获得类的信息</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;      Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.User"</span>);            <span class="hljs-comment">// 获得所有公共属性</span>      Field[] fields = c1.getFields();            <span class="hljs-comment">// 获得所有属性</span>      Field[] declaredFields = c1.getDeclaredFields();            <span class="hljs-comment">// 获得指定属性</span>      Field name = c1.getDeclaredField(<span class="hljs-string">"name"</span>);      <span class="hljs-comment">// 获得所有公有方法</span>      Method[] methods = c1.getMethods();            <span class="hljs-comment">// 获得所有方法</span>      Method[] declaredMethods = c1.getDeclaredMethods();            <span class="hljs-comment">// 获得指定方法</span>      Method setAge = c1.getDeclaredMethod(<span class="hljs-string">"setAge"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;   &#125;&#125;</code></pre><h3 id="通过反射获得类的对象"><a href="#通过反射获得类的对象" class="headerlink" title="通过反射获得类的对象"></a>通过反射获得类的对象</h3><p><strong>通过newInstance()方法</strong></p><ul><li>类必须含有一个<strong>无参构造器</strong></li><li>类的构造器的访问权限要足够</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;      Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.User"</span>);      User user = (User) c1.newInstance();      System.out.println(user);   &#125;&#125;</code></pre><p>如果重载了一个方法的构造方法，最好再补上一个无参构造函数</p><p><strong>通过获得类的构造器，再进行初始化</strong></p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Demo5 &#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> main(<span class="hljs-built_in">String</span>[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;      Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.User"</span>);      Constructor <span class="hljs-keyword">constructor</span> = c1.getDeclaredConstructor(<span class="hljs-params"><span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>, int.<span class="hljs-keyword">class</span></span>);      User user2 = (User) <span class="hljs-keyword">constructor</span>.newInstance(<span class="hljs-params">"Nyima", 20</span>);      System.out.println(user2.getAge());   &#125;&#125;</code></pre><p><strong>总结</strong>：获得类的实例的步骤</p><ul><li>通过类的Class对象</li><li>如果想通过调用<strong>无参构造方法</strong>创建实例<ul><li>直接调用Class对象的newInstance()方法</li><li>将返回值强转为对应的类型</li></ul></li><li>如果想通过<strong>有参构造方法</strong>创建实例<ul><li>调用Class对象的getDeclaredConstructor()并传入构造方法相应的参数的类型</li><li>通过获得的有参构造器，调用newInstance()方法，传入相应参数</li><li>将返回值强转为对应的类型</li></ul></li></ul><h3 id="通过反射调用类的方法"><a href="#通过反射调用类的方法" class="headerlink" title="通过反射调用类的方法"></a>通过反射调用类的方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;      Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.User"</span>);      User user = (User) c1.newInstance();      Method setName = c1.getDeclaredMethod(<span class="hljs-string">"setName"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      setName.invoke(user, <span class="hljs-string">"Nyima"</span>);      System.out.println(user.getName());   &#125;&#125;</code></pre><p><strong>步骤</strong></p><ul><li>获得类的Class对象</li><li>调用Class对象的newInstance()方法，获取类的对象</li><li>调用Class对象的getDeclaredMethod()方法</li><li>调用返回对象的invoke()方法，传入所需的参数（参数包含对哪个对象调用该方法），如 setName.invoke(<strong>user</strong>, “Nyima”);</li></ul><h3 id="通过反射设置属性值"><a href="#通过反射设置属性值" class="headerlink" title="通过反射设置属性值"></a>通过反射设置属性值</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;      Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.User"</span>);      User user = (User) c1.newInstance();      Field name = c1.getDeclaredField(<span class="hljs-string">"name"</span>);      name.set(user, <span class="hljs-string">"Nyima2"</span>);      System.out.println(user.getName());   &#125;&#125;</code></pre><p><strong>步骤</strong></p><ul><li>获得类的Class对象</li><li>调用Class对象的newInstance()方法，获取类的对象</li><li>调用Class对象的getDeclaredField()方法，获取属性</li><li>调用属性对象的set()方法进行赋值<ul><li>如果是<strong>私有属性</strong>，还需要调用name.setAccessible(true);方法进行设定</li></ul></li></ul><h3 id="通过获得注解信息"><a href="#通过获得注解信息" class="headerlink" title="通过获得注解信息"></a>通过获得注解信息</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException, NoSuchMethodException </span>&#123;Class c1 = Class.forName(<span class="hljs-string">"main.study.day4.Student"</span>);Student student = (Student) c1.newInstance();<span class="hljs-comment">// 获得类的注解</span>Annotation[] declaredAnnotations = c1.getDeclaredAnnotations();System.out.println(Arrays.toString(declaredAnnotations));<span class="hljs-comment">// 获得属性上的注解</span>Field name = c1.getDeclaredField(<span class="hljs-string">"name"</span>);Annotation annotation = name.getAnnotation(FieldAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(annotation);<span class="hljs-comment">// 获得方法的注解</span>Method getName = c1.getDeclaredMethod(<span class="hljs-string">"getName"</span>);MethodAnnotation methodAnnotation = getName.getAnnotation(MethodAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(methodAnnotation);&#125;&#125;<span class="hljs-meta">@ClassAnnotation</span>(name = <span class="hljs-string">"myStudent"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<span class="hljs-meta">@FieldAnnotation</span>(name = <span class="hljs-string">"name"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@FieldAnnotation</span>(name = <span class="hljs-string">"age"</span>)<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-meta">@MethodAnnotation</span>(name = <span class="hljs-string">"getName"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Nyima</span><span class="hljs-comment"> * 类的注解</span><span class="hljs-comment"> */</span><span class="hljs-meta">@interface</span> ClassAnnotation &#123;<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Nyima</span><span class="hljs-comment"> * 属性的注解</span><span class="hljs-comment"> */</span><span class="hljs-meta">@interface</span> FieldAnnotation &#123;<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Nyima</span><span class="hljs-comment"> * 方法的注解</span><span class="hljs-comment"> */</span><span class="hljs-meta">@interface</span> MethodAnnotation &#123;<span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>步骤</strong></p><ul><li>先获取到对应的类，如<ul><li>想获得类注解，需要先获得Class类对象</li><li>想获得属性的注解，需要先获得对应的属性</li><li>想获得方法的注解，需要先获得对应的方法</li><li>…</li></ul></li><li>通过对应的对象调用getDeclaredAnnotation()或者其他获取注解的方法，并传入需要的参数即可</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>指令流程和中断</title>
    <link href="/2020/09/12/%E6%8C%87%E4%BB%A4%E6%B5%81%E7%A8%8B%E5%92%8C%E4%B8%AD%E6%96%AD/"/>
    <url>/2020/09/12/%E6%8C%87%E4%BB%A4%E6%B5%81%E7%A8%8B%E5%92%8C%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="指令流程和中断"><a href="#指令流程和中断" class="headerlink" title="指令流程和中断"></a>指令流程和中断</h1><h1 id="一、指令系统"><a href="#一、指令系统" class="headerlink" title="一、指令系统"></a>一、指令系统</h1><h2 id="1、什么是指令"><a href="#1、什么是指令" class="headerlink" title="1、什么是指令"></a>1、什么是指令</h2><p>指令是指能让计算机完成某种操作的命令。</p><h2 id="2、什么是指令系统"><a href="#2、什么是指令系统" class="headerlink" title="2、什么是指令系统"></a>2、什么是指令系统</h2><p>指令系统是指一台计算机所能执行的全部指令。</p><h2 id="3、指令格式"><a href="#3、指令格式" class="headerlink" title="3、指令格式"></a>3、指令格式</h2><p>指令可以分为<strong>操作码字段</strong>和<strong>地址码字段</strong></p><ul><li><strong>操作码</strong>字段负责告诉计算机执行什么操作</li><li><strong>地址码</strong>字段负责<ul><li>存放操作数或操作数地址</li><li>存放运算结果的地址</li><li>给出后继指令地址</li></ul></li><li>操作码和地址码的位数不确定，需要更具具体的指令来决定</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921130430.png" srcset="/img/loading.gif" alt=""></p><p>可以根据地址码字段结构的不同，分为四地址指令、三地址指令、二地址指令、一地址指令和零地址指令。</p><h2 id="4、寻址方式"><a href="#4、寻址方式" class="headerlink" title="4、寻址方式"></a>4、寻址方式</h2><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>所需的操作数由指令直接给出的寻址方式，称为立即寻址，如</p><p>把立即数1234H放入R1寄存器中</p><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R1</span>, <span class="hljs-number">1234H</span></code></pre><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>地址码为操作数所在主存单元的实际地址的寻址方式，称为直接寻址，如</p><p>把地址为1234H单元中的数据放入到R1寄存器中</p><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R1</span>, (<span class="hljs-number">1234H</span>)</code></pre><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>地址码部分给出的是存放操作数地址的内存单元的地址，这个地址叫做间接地址。通过间接地址来寻址的方式称为间接寻址。如</p><p>把存放在地址为1234H内存单元中的地址取出，然后再通过该地址取找到需要的立即数，然后再将该立即数放入R1寄存器中</p><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R1</span>, ((<span class="hljs-number">1234H</span>))</code></pre><h3 id="寄存器直接寻址"><a href="#寄存器直接寻址" class="headerlink" title="寄存器直接寻址"></a>寄存器直接寻址</h3><p>指令所需的操作数在寄存器中，按指令给出的寄存器地址去获取操作数的寻址方式，称为寄存器直接寻址，如</p><p>把R2寄存器中的数据放入R1寄存器中</p><pre><code class="hljs armasm"><span class="hljs-keyword">MOV </span><span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span></code></pre><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器中存放了操作数在内存单元中的地址，通过寄存器获得立即数在内存单元中的地址，然后通过地址得到立即数的寻址方式，称为寄存器间接寻址，如</p><p>把BX寄存器中存放的数据取出，通过该数据找到内存单元中对应位置中存放的立即数</p><pre><code class="hljs armasm"><span class="hljs-keyword">MOV </span><span class="hljs-built_in">R1</span>, (<span class="hljs-built_in">R2</span>)</code></pre><h3 id="自增型寄存器间接寻址"><a href="#自增型寄存器间接寻址" class="headerlink" title="自增型寄存器间接寻址"></a>自增型寄存器间接寻址</h3><p>和寄存器间接寻址类似，不过在取出寄存器中存放的地址后，需要该地址的值+1，然后再放回该寄存器中，如</p><pre><code class="hljs armasm"><span class="hljs-keyword">MOV </span><span class="hljs-built_in">R1</span>, (<span class="hljs-built_in">R2</span>)+</code></pre><h3 id="自减型寄存器间接寻址"><a href="#自减型寄存器间接寻址" class="headerlink" title="自减型寄存器间接寻址"></a>自减型寄存器间接寻址</h3><p>和寄存器间接寻址类似，不过在取出寄存器中存放的地址时，需要将改地址-1，使用后需要将地址放回寄存器中，如</p><pre><code class="hljs armasm"><span class="hljs-keyword">MOV </span><span class="hljs-built_in">R1</span>, -(<span class="hljs-built_in">R2</span>)</code></pre><h4 id="自增-自减型寄存器间接寻址的区别"><a href="#自增-自减型寄存器间接寻址的区别" class="headerlink" title="自增/自减型寄存器间接寻址的区别"></a>自增/自减型寄存器间接寻址的区别</h4><p>自增型寄存器间接寻址在取出寄存器中存放的数据后，<strong>直接使用该数据</strong>。使用完毕后，将该数据+1后再放回寄存器中。类似于</p><pre><code class="hljs brainfuck"><span class="hljs-comment">x</span>++</code></pre><p>自减型寄存器间接寻址在取出寄存器中存放的数据后，<strong>先将数据-1，然后再使用</strong>。使用后将该数据放回到寄存器中。类似于</p><pre><code class="hljs ada"><span class="hljs-comment">--x</span></code></pre><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>选用专用寄存器(IX)或通用寄存器(R0)用于存放偏移地址。将寄存器中的值加上基准地址的值(D)来作为最终地址的寻址方式，称为变址寻址。</p><p>如</p><p>选用<strong>专用寄存器IX</strong>作为变址寄存器，目标地址为</p><pre><code class="hljs ini"><span class="hljs-attr">EA</span> = (IX) + D</code></pre><p>选用<strong>通用寄存器R0</strong>作为变址寄存器，目标地址为</p><pre><code class="hljs ini"><span class="hljs-attr">EA</span> = (R0) + D</code></pre><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>基址寻址和变址寻址相反，寄存器中存放的是基准地址，D中存放的是偏移地址。该寻址方式称为基址寻址。如</p><p>选用<strong>专用寄存器BR</strong>作为基址寄存器，目标地址为</p><pre><code class="hljs ini"><span class="hljs-attr">EA</span> = (BR) + D</code></pre><p>选用通用寄存器R0作为基址寄存器，目标地址为</p><pre><code class="hljs ini"><span class="hljs-attr">EA</span> = (R0) + D</code></pre><h4 id="变址-基址寻址的区别"><a href="#变址-基址寻址的区别" class="headerlink" title="变址/基址寻址的区别"></a>变址/基址寻址的区别</h4><p>无论是变址寻址还是基址寻址，目标地址 =  <strong>基准地址 + 偏移地址</strong> ，只不过在不同的寻址方式中，由不同的寄存器和形式地址给出。</p><ul><li><strong>变址寻址</strong>中，由寄存器提供偏移地址，D提供基准地址</li><li><strong>基址寻址</strong>中，由寄存器提供基准地址，D提供偏移地址</li></ul><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>相对寻址是基于基址寻址的一种寻址方式，是一种由<strong>程序计数器PC给出基准地址，D给出偏移地址</strong>的寻址方式。</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p><strong>操作数存放在堆栈中</strong>，隐含使用堆栈指针（SP）作为操作数地址。</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按“<strong>后进先出</strong>（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为<strong>堆栈指针</strong>（SP）。</p><h1 id="二、指令流程"><a href="#二、指令流程" class="headerlink" title="二、指令流程"></a>二、指令流程</h1><h2 id="1、流程中会用到的寄存器"><a href="#1、流程中会用到的寄存器" class="headerlink" title="1、流程中会用到的寄存器"></a>1、流程中会用到的寄存器</h2><p>Ri Rj：通用寄存器，用于存放源操作数或元操作数地址</p><p>C：暂存器C，用于暂存数据</p><p>D：暂存器D，用于暂存数据</p><p>MAR：地址寄存器，用于存放地址</p><p>MDR：数据寄存器，用于存放从主存读取出来的数据数据</p><p>PC：程序计数器，指向下一条指令的地址</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921143115.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、指令流程的划分"><a href="#2、指令流程的划分" class="headerlink" title="2、指令流程的划分"></a>2、指令流程的划分</h2><p>由数据通路可以将指令的执行过程分为4个基本的阶段</p><ul><li>取指令周期FT</li><li>源操作数周期ST</li><li>目的操作数周期DT</li><li>执行周期ET</li></ul><h2 id="3、取指令周期FT"><a href="#3、取指令周期FT" class="headerlink" title="3、取指令周期FT"></a>3、取指令周期FT</h2><p>取指令周期为指令流程的<strong>公操作</strong>。具有两个步骤，在一个时钟周期内完成。</p><p>步骤一：将主存中的指令读取，放入指令寄存器IR中</p><p>步骤二：程序计数器+1，指向下一条指令的地址</p><pre><code class="hljs clean">M-&gt;IRPC+<span class="hljs-number">1</span>-&gt;PC</code></pre><h2 id="4、源操作数周期ST"><a href="#4、源操作数周期ST" class="headerlink" title="4、源操作数周期ST"></a>4、源操作数周期ST</h2><p>该周期主要是为了得到源操作数的值</p><p><strong>以MOV指令为例</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921144737.png" srcset="/img/loading.gif" alt=""></p><h3 id="寄存器直接寻址-R"><a href="#寄存器直接寻址-R" class="headerlink" title="寄存器直接寻址 R"></a>寄存器直接寻址 R</h3><p>因为寄存器中存放的就是源操作数，所以<strong>直接取出即可</strong></p><h3 id="寄存器间接寻址-R"><a href="#寄存器间接寻址-R" class="headerlink" title="寄存器间接寻址 (R)"></a>寄存器间接寻址 (R)</h3><p>因为寄存器中存放的是源操作数在内存单元中的地址，所以我们需要通过寄存器，访问对应的内存单元，然后获得源操作数。</p><ul><li><p>先将寄存器中的值放入地址寄存器中 <strong>Ri -&gt; MAR</strong></p></li><li><p>通过地址寄存器访问对应的内存单元，将单元中的值放入数据寄存器中  <strong>M-&gt;MDR</strong> ，然后通过数据寄存器中放入暂存器C中 <strong>MDR-&gt;C</strong></p></li></ul><h3 id="自增-自减型寄存器间接寻址-R-R"><a href="#自增-自减型寄存器间接寻址-R-R" class="headerlink" title="自增/自减型寄存器间接寻址 (R)+/-(R)"></a>自增/自减型寄存器间接寻址 (R)+/-(R)</h3><p>和寄存器间接寻址类似，只不过多了一个自增/自减的步骤</p><p><strong>自增型寄存器间接寻址</strong>在<strong>取出源操作数后</strong>，要将寄存器中存储的值+1，再放回该寄存器中</p><p><strong>自减型寄存器间接寻址</strong>在<strong>取出寄存器中的值前</strong>，要将寄存器中存储的值-1，然后以-1后的值进行寻址操作，获取源操作数</p><h3 id="自增型寄存器双间接寻址-R"><a href="#自增型寄存器双间接寻址-R" class="headerlink" title="自增型寄存器双间接寻址 @(R)+"></a>自增型寄存器双间接寻址 @(R)+</h3><p>这种寻址方式需要两次访问主存，才能获得源操作数的最终地址</p><ul><li><p>先将寄存器中的值放入地址寄存器中 <strong>Ri -&gt; MAR</strong></p></li><li><p>通过地址寄存器访问对应的内存单元，将单元中的值放入数据寄存器中  <strong>M-&gt;MDR</strong> ，然后通过数据寄存器中放入暂存器C中</p><p> <strong>MDR-&gt;C</strong>，此时C中存放的是源操作数的地址</p></li><li><p>寄存器中存储的值+1，再放回该寄存器中 <strong>Ri+1 -&gt; Ri</strong></p></li><li><p>再次进行寄存器间接寻址 <strong>C -&gt; MAR</strong></p></li><li><p>通过地址寄存器访问对应的内存单元，将单元中的值放入数据寄存器中  <strong>M-&gt;MDR</strong> ，然后通过数据寄存器中放入暂存器C中 <strong>MDR-&gt;C</strong></p></li></ul><h3 id="变址寻址-X-R"><a href="#变址寻址-X-R" class="headerlink" title="变址寻址 X(R)"></a>变址寻址 X(R)</h3><p>变址寻址需要将<strong>寄存器中的值</strong>加上<strong>基准地址的值(D</strong>)来作为最终地址</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921143823.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>公操作进行了 <strong>PC+1 -&gt; PC</strong>，所以当前PC保存的是寄存地址D的值。先将基准地址取出 <strong>PC -&gt; MAR</strong>，放入到暂存器C中 </p><p><strong>M -&gt; MDR -&gt;C</strong></p></li><li><p>PC指向下一条指令的地址 <strong>PC + 1 -&gt; PC</strong></p></li><li><p>偏移地址+基准地址 获得最终地址 <strong>C+R -&gt; MAR</strong></p></li><li><p>将结果放入暂存器C中 M -&gt; MDR -&gt; C</p></li></ul><p><strong>经过源操作数周期ST后，暂存器C中保存了源操作数的值</strong></p><h2 id="5、目的操作数周期DT"><a href="#5、目的操作数周期DT" class="headerlink" title="5、目的操作数周期DT"></a>5、目的操作数周期DT</h2><p>该步骤主要是为了<strong>找到目的操作数的地址</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921145635.png" srcset="/img/loading.gif" alt=""></p><h3 id="寄存器直接寻址-R-1"><a href="#寄存器直接寻址-R-1" class="headerlink" title="寄存器直接寻址 R"></a>寄存器直接寻址 R</h3><p>直接放入寄存器中，无需目的操作数地址</p><h3 id="寄存器间接寻址-R-1"><a href="#寄存器间接寻址-R-1" class="headerlink" title="寄存器间接寻址 (R)"></a>寄存器间接寻址 (R)</h3><p>取出寄存器中存放的目的地址，将该地址放入MAR中 <strong>Rj -&gt; MAR</strong></p><h3 id="自增-自减型寄存器间接寻址-R-R-1"><a href="#自增-自减型寄存器间接寻址-R-R-1" class="headerlink" title="自增/自减型寄存器间接寻址 (R)+/-(R)"></a>自增/自减型寄存器间接寻址 (R)+/-(R)</h3><p>和寄存器间接寻址类似，将地址放入了MAR中，只不过多了自增/自减的步骤</p><h3 id="自增型寄存器双间接寻址-R-1"><a href="#自增型寄存器双间接寻址-R-1" class="headerlink" title="自增型寄存器双间接寻址 @(R)+"></a>自增型寄存器双间接寻址 @(R)+</h3><ul><li>通过寄存器中存放的地址，访问主存单元 <strong>Rj -&gt; MAR</strong></li><li>访问后Rj寄存器中的值+1 <strong>Rj +1 -&gt; Rj</strong></li><li>将主存单元中的值取出，放入到地址寄存器中。 <strong>M-&gt;MDR-&gt;MAR</strong></li></ul><h3 id="变址寻址-X-R-1"><a href="#变址寻址-X-R-1" class="headerlink" title="变址寻址 X(R)"></a>变址寻址 X(R)</h3><ul><li><p>公操作进行了 <strong>PC+1 -&gt; PC</strong>，所以当前PC保存的是寄存地址D的值。先将基准地址取出 <strong>PC -&gt; MAR</strong>，放入到暂存器D中 </p><p><strong>M -&gt; MDR -&gt;D</strong></p></li><li><p>PC指向下一条指令的地址 <strong>PC + 1 -&gt; PC</strong></p></li><li><p>偏移地址+基准地址 获得最终地址 <strong>D+R -&gt; MAR</strong></p></li></ul><h2 id="6、执行周期ET"><a href="#6、执行周期ET" class="headerlink" title="6、执行周期ET"></a>6、执行周期ET</h2><p><strong>将源操作数放入目的寄存器或目的主存单元中</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921150628.png" srcset="/img/loading.gif" alt=""></p><h3 id="寄存器直接寻址-1"><a href="#寄存器直接寻址-1" class="headerlink" title="寄存器直接寻址"></a>寄存器直接寻址</h3><p>Ri中的内容直接放入Rj中</p><h3 id="目的间接寻址，源直接寻址"><a href="#目的间接寻址，源直接寻址" class="headerlink" title="目的间接寻址，源直接寻址"></a>目的间接寻址，源直接寻址</h3><p>将源操作数<strong>通过数据寄存器</strong>放入主存中</p><h3 id="目的直接寻址，源间接寻址"><a href="#目的直接寻址，源间接寻址" class="headerlink" title="目的直接寻址，源间接寻址"></a>目的直接寻址，源间接寻址</h3><p>将暂存器C中存放的值放入目的寄存器Rj中</p><h3 id="目的、源都为间接寻址"><a href="#目的、源都为间接寻址" class="headerlink" title="目的、源都为间接寻址"></a>目的、源都为间接寻址</h3><p>将暂存器C中存放的值放入数据寄存器中，通过数据寄存器放入主存单元中</p><h3 id="公操作-PC-gt-MAR"><a href="#公操作-PC-gt-MAR" class="headerlink" title="公操作 PC -&gt; MAR"></a>公操作 PC -&gt; MAR</h3><p>程序计数器寻找下一条指令的地址</p><h1 id="三、中断"><a href="#三、中断" class="headerlink" title="三、中断"></a>三、中断</h1><h2 id="1、什么是中断"><a href="#1、什么是中断" class="headerlink" title="1、什么是中断"></a>1、什么是中断</h2><p> 在处理器中，中断是一个过程，即CPU在正在执行程序过程中，遇到外部/内部紧急事件需要处理，暂时中止当前程序执行转而去为事件服务，待服务完毕，再返回到暂停处（断点）继续执行原来的程序。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200921152218.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、几个概念"><a href="#2、几个概念" class="headerlink" title="2、几个概念"></a>2、几个概念</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>一个地址，程序在该处中断，转而取执行中断程序的地址</p><h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><p>引起中断的信号源</p><h3 id="中断服务程序"><a href="#中断服务程序" class="headerlink" title="中断服务程序"></a>中断服务程序</h3><p>中断后需要去执行的程序</p><h3 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h3><p>中断服务程序发出的请求，请求CPU中断正在执行的程序，转而去执行该程序</p><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>CPU做出响应，中断正在执行的程序，转而去执行中断服务程序的过程</p><h3 id="现场保护"><a href="#现场保护" class="headerlink" title="现场保护"></a>现场保护</h3><p>将中断前的现场保存起来，便于执行完中断服务程序后，可以继续执行中断前的程序</p><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>执行中断服务程序</p><h3 id="恢复现场"><a href="#恢复现场" class="headerlink" title="恢复现场"></a>恢复现场</h3><p>恢复到中断前的样子</p><h3 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h3><p>继续执行中断前正在执行的程序</p><h2 id="3、中断流程"><a href="#3、中断流程" class="headerlink" title="3、中断流程"></a>3、中断流程</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200922093045.png" srcset="/img/loading.gif" alt=""></p><ul><li><p><strong>关中断</strong><br> 进入不可再次响应中断的状态，由硬件自动实现。因为接下去要保存断点，保存现场。<strong>在保存现场过程中，即使有更高级的中断源申请中断，CPU也不应该响应</strong>；否则如果现场保存不完整，在中断服务程序结束之后，也就不能正确地恢复现场并执行现行程序</p></li><li><p><strong>保存断点，保存现场</strong><br> 为了在中断处理结束后能正确地返回到中断点，在响应中断时，必须把当前的程序计数器PC中的内容（即断点）保存起来</p></li><li><p><strong>判别中断源，转入中断服务程序</strong><br> 在多个中断源同时请求中断的情况下，本次实际响应的只能是优先权最高的那个中断源。所以需要进一步判别中断源，并转入相应的中断服务程序入口</p></li><li><p><strong>开中断</strong><br> 因为接下去就要执行中断服务程序，开中断将允许更高级中断请求得到相应，实现中断嵌套</p></li><li><p><strong>执行中断服务程序</strong><br> 不同中断源的中断服务程序是不同的，实际有效的中断处理工作是在此程序段中实现的</p></li><li><p><strong>退出中断</strong><br> 在退出时，又应该进入不可中断状态，即关中断，恢复现场，恢复断点，然后开中断，返回原程序执行</p></li></ul><p>进入中断时执行的关中断，保存断点等操作一般是<strong>由硬件实现</strong>的，它类似于一条指令，但它与一般的指令不同，不能被编写在程序中。因此，常常称为“<strong>中断隐指令</strong>”</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级</title>
    <link href="/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/"/>
    <url>/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>该博客是根据<a href="https://www.bilibili.com/video/BV1KW411u7vy?p=9" target="_blank" rel="noopener"><strong>尚硅谷MySQL数据库高级，mysql优化，数据库优化</strong></a>学习时，所做的笔记</p><p>同时又参考了<a href="https://www.bilibili.com/video/av541567925?p=1" target="_blank" rel="noopener"><strong>2020最新完整版MYSQL高级教程</strong></a></p><h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h1 id="一、Mysql逻辑架构"><a href="#一、Mysql逻辑架构" class="headerlink" title="一、Mysql逻辑架构"></a>一、Mysql逻辑架构</h1><h2 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png" srcset="/img/loading.gif" alt=""></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端/服务端工具实现的类似于tcp/ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p><table><thead><tr><th>Management Serveices &amp; Utilities</th><th>系统管理和控制工具</th></tr></thead><tbody><tr><td>SQL Interface</td><td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等</td></tr></tbody></table><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁（不适合高并发）</td><td>行锁（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p><h1 id="二、性能与JOIN"><a href="#二、性能与JOIN" class="headerlink" title="二、性能与JOIN"></a>二、性能与JOIN</h1><h2 id="1、性能下降原因"><a href="#1、性能下降原因" class="headerlink" title="1、性能下降原因"></a>1、性能下降原因</h2><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p><strong>单值索引</strong></p><p>创建语句</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_表名_字段名 <span class="hljs-keyword">ON</span> 表名(字段名);</code></pre><p><strong>复合索引</strong></p><pre><code class="hljs angelscript">CREATE INDEX idx_表名_字段名<span class="hljs-number">1</span>字段名<span class="hljs-number">2.</span>.. ON 表名(字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span> ...);</code></pre><h3 id="关联太多JOIN"><a href="#关联太多JOIN" class="headerlink" title="关联太多JOIN"></a>关联太多JOIN</h3><p>内连接、外连接的表不要过多</p><h3 id="服务器调优及参数设置"><a href="#服务器调优及参数设置" class="headerlink" title="服务器调优及参数设置"></a>服务器调优及参数设置</h3><h2 id="2、SQL执行加载顺序"><a href="#2、SQL执行加载顺序" class="headerlink" title="2、SQL执行加载顺序"></a>2、SQL执行加载顺序</h2><h3 id="手写顺序"><a href="#手写顺序" class="headerlink" title="手写顺序"></a>手写顺序</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112248.png" srcset="/img/loading.gif" alt=""></p><p>随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而<strong>动态调整执行顺序</strong></p><p>下面是经常出现的查询顺序：</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112330.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112343.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814191644.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、7种JOIN"><a href="#3、7种JOIN" class="headerlink" title="3、7种JOIN"></a>3、7种JOIN</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814150926.png" srcset="/img/loading.gif" alt=""></p><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a><strong>建表语句</strong></h3><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_dept`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">`deptName`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">`address`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_emp`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">`age`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">`deptId`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, empno <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>), <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_dept_id`</span> (<span class="hljs-string">`deptId`</span>)<span class="hljs-comment">#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'华山'</span>,<span class="hljs-string">'华山'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'丐帮'</span>,<span class="hljs-string">'洛阳'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'峨眉'</span>,<span class="hljs-string">'峨眉山'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'武当'</span>,<span class="hljs-string">'武当山'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'明教'</span>,<span class="hljs-string">'光明顶'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'少林'</span>,<span class="hljs-string">'少林寺'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'风清扬'</span>,<span class="hljs-number">90</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100001</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'岳不群'</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100002</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'令狐冲'</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100003</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'洪七公'</span>,<span class="hljs-number">70</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100004</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'乔峰'</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100005</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'灭绝师太'</span>,<span class="hljs-number">70</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100006</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'周芷若'</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100007</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'张三丰'</span>,<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100008</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'张无忌'</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">100009</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(<span class="hljs-keyword">NAME</span>,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'韦小宝'</span>,<span class="hljs-number">18</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">100010</span>);</code></pre><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><ul><li>笛卡尔积</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp;</code></pre><p>t_dept共20条记录，t_emp共6条记录。两表共同查询后共120条记录</p><ul><li>内连接</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153140.png" srcset="/img/loading.gif" alt=""></p><ul><li>左外连接</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153254.png" srcset="/img/loading.gif" alt=""></p><ul><li>右外连接</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png" srcset="/img/loading.gif" alt=""></p><ul><li>左外连接<strong>取左表的独有部分</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153909.png" srcset="/img/loading.gif" alt=""></p><ul><li>右外连接<strong>取右表的独有部分</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：判断字段是否为NULL时，<strong>不能使用’=’</strong></p><p>因为</p><pre><code class="hljs asciidoc"><span class="hljs-section">= NULL</span></code></pre><p>的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用</p><pre><code class="hljs pgsql"><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span></code></pre><p>来进行判空</p><ul><li>全外连接</li></ul><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png" srcset="/img/loading.gif" alt=""></p><ul><li>查询两表独有内容</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h1><h2 id="1、什么是索引"><a href="#1、什么是索引" class="headerlink" title="1、什么是索引"></a>1、什么是索引</h2><ul><li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。可以得到索引的本质： <strong>索引是数据结构</strong>。</p><p>可以简单理解为：<strong>排好序的快速查找数据结构</strong></p></li></ul><ul><li>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814173647.png" srcset="/img/loading.gif" alt=""></p><ul><li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录 </li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li></ul><h2 id="2、索引的优缺点"><a href="#2、索引的优缺点" class="headerlink" title="2、索引的优缺点"></a>2、索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li></ul><h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> table_name(<span class="hljs-keyword">column</span>);</code></pre></li><li><p>删除</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> table_name;</code></pre></li><li><p>查看</p><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> table_name;</code></pre></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单值索引</p><ul><li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>语法：</p><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> AUTO_INCREMENT,customer_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>), PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>), <span class="hljs-keyword">KEY</span> (customer_name) <span class="hljs-comment">--单值索引</span>);<span class="hljs-comment">--单独创建单值索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_customer_name <span class="hljs-keyword">ON</span> customer(customer_name);</code></pre></li></ul></li><li><p>唯一索引</p><ul><li><p>定义：索引列的值必须唯一，但允许有空值</p></li><li><p>语法：</p><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> AUTO_INCREMENT,customer_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>), PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>), <span class="hljs-keyword">KEY</span> (customer_name), <span class="hljs-comment">--单值索引</span><span class="hljs-keyword">UNIQUE</span> (customer_no) <span class="hljs-comment">--唯一索引</span>);<span class="hljs-comment">--单独创建唯一索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> idx_customer_no <span class="hljs-keyword">ON</span> customer(customer_no);</code></pre></li></ul></li><li><p>主键索引</p><ul><li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为聚簇索引</p></li><li><p>语法：</p><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> AUTO_INCREMENT,customer_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>), PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>) <span class="hljs-comment">--主键索引</span>);<span class="hljs-comment">--单独创建主键索引</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">ADD</span> PRIMARY <span class="hljs-keyword">KEY</span> customer(customer_no);<span class="hljs-comment">--删除主键索引</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">DROP</span> PRIMARY <span class="hljs-keyword">KEY</span>;<span class="hljs-comment">--修改建主键索引</span>必须先删除掉(<span class="hljs-keyword">drop</span>)原索引，再新建(<span class="hljs-keyword">add</span>)索引</code></pre></li></ul></li><li><p>复合索引</p><ul><li><p>定义：即一个索引包含多个列</p></li><li><p>语法：</p><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> AUTO_INCREMENT,customer_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>), PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>), <span class="hljs-keyword">KEY</span> (customer_name), <span class="hljs-comment">--单值索引</span><span class="hljs-keyword">UNIQUE</span> (customer_no), <span class="hljs-comment">--唯一索引</span><span class="hljs-keyword">KEY</span> (customer_no,customer_name) <span class="hljs-comment">--复合索引</span>);<span class="hljs-comment">--单独创建复合索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_no_name <span class="hljs-keyword">ON</span> customer(customer_no,customer_name);</code></pre></li></ul></li></ul><h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p>树的内容参照<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#B%E6%A0%91%E3%80%81B-%E5%92%8CB-%E6%A0%91">JAVA数据结构 B树、B+树和B*树</a></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153029.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153043.png" srcset="/img/loading.gif" alt=""></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong></li><li>在 B树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B树多，树高比 B树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li></ul><p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低<ul><li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li></ul></li><li>B+树的查询效率更加稳定<ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul></li></ul><h3 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822173605.png" srcset="/img/loading.gif" alt=""></p><p>MySQL在创建表时，会根据主键来创建主键索引（如果没有主键，会用一个隐藏值来作为主键）。主键索引所构建的B+树，表中所有的记录都存放在了树的最后一层。<strong>且与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822185520.png" srcset="/img/loading.gif" alt=""></p><p>创建复合索引时，会将作为<strong>复合索引字段的值</strong>进行排序并放在B+树的最后一层中，同时还会将其<strong>对应的主键值</strong>放在其后。如：</p><table><thead><tr><th>a（主键）</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>1</td><td>1</td><td>a</td></tr></tbody></table><p>其中字段a为主键，字段bcd共同作为复合索引，此时存放在最后一层的数据就是：111（复合索引） 2（主键索引）</p><p>根据这个特点，可以看出复合索引具有以下使用方法</p><ul><li><p>最佳左前缀：使用复合索引的顺序必须和创建的<strong>顺序一致</strong></p></li><li><p>覆盖索引的同时，可以带上主键字段，如</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a, b, c, d <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p>因为<strong>主键字段和复合索引一起存放在了复合索引说产生的B+树的最后一层</strong>。如果需要a字段，无需进行全表扫描</p></li><li><p>如果进行范围查找，可能会进行全表扫描，这取决于处在范围内记录的多少</p><ul><li><p><strong>记录多</strong>，从复合索引映射到主键索引的次数过多，成本过高，<strong>会直接进行全表扫描</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">1</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175336.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>记录少</strong>，先<strong>使用复合索引</strong>，然后映射到全表中的对应记录上</p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">80</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175403.png" srcset="/img/loading.gif" alt=""></p></li><li><p>但是使用<strong>覆盖索引</strong>，无论记录多少，都会用到索引</p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">1</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175611.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>不带WHERE也可以通过复合索引查找到主键+复合索引的记录</p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>, age, <span class="hljs-keyword">name</span>, deptId <span class="hljs-keyword">FROM</span> t_emp ;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175746.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="5、索引的使用场景"><a href="#5、索引的使用场景" class="headerlink" title="5、索引的使用场景"></a>5、索引的使用场景</h2><h3 id="适合索引的场景"><a href="#适合索引的场景" class="headerlink" title="适合索引的场景"></a>适合索引的场景</h3><ul><li>主键自动建立唯一索引</li><li>频繁作为<strong>查询条件</strong>的字段应该创建索引 </li><li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引 </li><li>单键/组合索引的选择问题，<strong>组合索引性价比更高</strong></li><li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度 </li><li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li></ul><h3 id="不适合索引的场景"><a href="#不适合索引的场景" class="headerlink" title="不适合索引的场景"></a>不适合索引的场景</h3><ul><li>表<strong>记录太少</strong>（有无索引差别不大）</li><li>经常<strong>增删改</strong>的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li></ul><h1 id="四、Explain-性能分析"><a href="#四、Explain-性能分析" class="headerlink" title="四、Explain 性能分析"></a>四、Explain 性能分析</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。<strong>分析</strong>你的查询语句或是表结构的<strong>性能瓶颈</strong></p><h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><pre><code class="hljs sql"><span class="hljs-comment">--EXPLAIN + SQL语句，如：</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person;</code></pre><p><strong>Explain 执行后返回的信息：</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815171636.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、表头字段介绍"><a href="#3、表头字段介绍" class="headerlink" title="3、表头字段介绍"></a>3、表头字段介绍</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,<span class="hljs-keyword">content</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-literal">NULL</span> , PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,<span class="hljs-keyword">content</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-literal">NULL</span> , PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t3(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,<span class="hljs-keyword">content</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-literal">NULL</span> , PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t4(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,<span class="hljs-keyword">content</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-literal">NULL</span> , PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1(<span class="hljs-keyword">content</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">CONCAT</span>(<span class="hljs-string">'t1_'</span>,<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span>+<span class="hljs-keyword">RAND</span>()*<span class="hljs-number">1000</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2(<span class="hljs-keyword">content</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">CONCAT</span>(<span class="hljs-string">'t2_'</span>,<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span>+<span class="hljs-keyword">RAND</span>()*<span class="hljs-number">1000</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t3(<span class="hljs-keyword">content</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">CONCAT</span>(<span class="hljs-string">'t3_'</span>,<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span>+<span class="hljs-keyword">RAND</span>()*<span class="hljs-number">1000</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t4(<span class="hljs-keyword">content</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">CONCAT</span>(<span class="hljs-string">'t4_'</span>,<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span>+<span class="hljs-keyword">RAND</span>()*<span class="hljs-number">1000</span>)));</code></pre><h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><ul><li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1, t2, t3 <span class="hljs-keyword">WHERE</span> t1.id = t2.id <span class="hljs-keyword">AND</span> t2.id = t3.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815173157.png" srcset="/img/loading.gif" alt=""></p><p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p></li></ul><ul><li><p><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> t2.id <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> t2.id = (<span class="hljs-keyword">SELECT</span> t1.id <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> t1.id = (<span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3));</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174216.png" srcset="/img/loading.gif" alt=""></p><p>查询时，表的加载<strong>顺序为t3, t1, t2</strong> </p></li></ul><ul><li><p><strong>id相同又不同</strong>： 执行顺序为 </p><ul><li>id不同时，值较大的先执行</li><li>id相同时，从上至下执行</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3) s1, t2 <span class="hljs-keyword">WHERE</span> s1.id = t2.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174740.png" srcset="/img/loading.gif" alt=""></p><p>查询时，表的<strong>加载顺序为t3, t2, 虚表dervied2</strong></p><ul><li>其中dervied<strong>2</strong> 的 2，为 id = 2</li></ul></li></ul><h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a>select_type：查询操作类型</h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p><table><thead><tr><th>select_type 属性</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td></tr><tr><td>DEPEDENT SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td><strong>无法使用缓存</strong>的子查询</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表<strong>获取结果</strong>的SELECT</td></tr></tbody></table><ul><li>SUBQUERY  和 DEPEDENT SUBQUERY<ul><li>都是 WHERE 后面的条件，SUBQUERY 是单个值（=），DEPEDENT SUBQUERY 是一组值（IN）</li></ul></li></ul><ul><li>UNCACHEABLE SUBQUERY<ul><li>当使用了<strong>@@来引用系统变量</strong>的时候，不会使用缓存</li></ul></li></ul><ul><li><p>UNION 和  UNION RESULT  </p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816135453.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a>table：表的来源</h3><p>table表示这个数据是基于哪张表的</p><h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">all</span><span class="hljs-comment">--常见的顺序为</span><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">all</span></code></pre><p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p><table><thead><tr><th>类型名</th><th>含义</th></tr></thead><tbody><tr><td>SYSTEM</td><td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td></tr><tr><td>CONST</td><td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td></tr><tr><td>EQ_REF</td><td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td></tr><tr><td>REF</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td></tr><tr><td>RANGE</td><td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td></tr><tr><td>INDEX</td><td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td></tr><tr><td>ALL</td><td>Full Table Scan，将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li><p>REF</p><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，且用到了' = '</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">3</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165420.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li><p>RANGE</p><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，用到了 BETWEEN...AND... , IN , &gt; , &lt; 等范围查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId &gt; <span class="hljs-number">3</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816213631.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li><p>INDEX</p><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，查找了整张表时，用到了索引</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> deptId <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165651.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li><p>ALL</p><pre><code class="hljs sql"><span class="hljs-comment">--其中name为非索引</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165722.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a>possible_key：可能用到的索引</h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一 定被查询实际使用</strong></p><h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816172950.png" srcset="/img/loading.gif" alt=""></p><p>MySQL推测可能用到主键索引和idx_dept_id索引，实际上用到的是主键索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p><p>有以下两种解释</p><ul><li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li><li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li></ul><p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p><pre><code class="hljs sql"><span class="hljs-comment">--其中id和deptId都为索引</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>, deptId <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173253.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173228.png" srcset="/img/loading.gif" alt=""></p><h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a>key_len：索引使用字节数</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p><p><strong>ken_len 越长，说明索引使用的越充分</strong></p><h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a>ref：显示被使用的索引的具体信息</h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId = t_dept.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816194305.png" srcset="/img/loading.gif" alt=""></p><h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a>rows：被查询的行数</h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p><p><strong>验证</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--先删除索引</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_dept_id <span class="hljs-keyword">ON</span> t_emp;<span class="hljs-comment">--查找</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId = t_dept.id;<span class="hljs-comment">--再创建索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_dept_id <span class="hljs-keyword">ON</span> t_emp(deptId);<span class="hljs-comment">--查找</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId = t_dept.id;</code></pre><p><strong>结果如下</strong></p><ul><li><p>未使用索引时，一共需要查询26行</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195241.png" srcset="/img/loading.gif" alt=""></p></li><li><p>使用索引后，一共需要查询6行</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195401.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a>Extra：额外重要信息</h3><p>其他的额外<strong>重要</strong>的信息</p><ul><li><p><strong>Using filesort</strong>：使用外部索引排序（未使用用户创建的索引）</p><ul><li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li><li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li></ul><p><strong>演示</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--创建符合索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<span class="hljs-comment">--进行查询操作，通过 age 字段进行排序（未按照复合索引顺序进行排序查询）</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<span class="hljs-comment">--进行查询操作，通过 empno 或者 empno + age 字段进行排序（按照复合索引顺序进行排序查询）</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno, age;</code></pre><p><strong>结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205145.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205226.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205112.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li><p><strong>Using temporary</strong></p><ul><li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li><li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li></ul><p><strong>演示</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--进行查询操作， 通过 age 字段进行分组（未按照复合索引顺序进行排序查询）</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<span class="hljs-comment">----进行查询操作，通过 empno 或者 empno + age 字段进行分组（按照复合索引顺序进行排序查询）</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno, age;</code></pre><p><strong>结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210843.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210908.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>  <strong>重要结论</strong></p><p>  如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>，否则会使得性能大幅下降</p><ul><li><p><strong>Using index</strong></p><ul><li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，详见<a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">key：实际用到的索引——覆盖索引</a>，避免访问了表的数据行，<strong>效率不错</strong>！ </li><li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li><li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li></ul><p><strong>演示</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--查询 age 字段，使用了WHERE</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt;<span class="hljs-number">100000</span>;<span class="hljs-comment">--查询 empno 和 age 字段，未使用WHERE</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno, age <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-comment">--查询 empno 和 name 字段 （name字段不是索引）</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno, <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><strong>结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212055.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212129.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212243.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li><p>Using where</p><ul><li>表明使用了 where 过滤</li></ul></li><li><p>Using join buffer</p><ul><li>使用了连接缓存</li></ul></li><li><p>impossible where</p><ul><li>where 子句的值总是 false，不能用来获取任何元组</li></ul></li><li><p>select tables optimized away</p><ul><li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li></ul></li></ul><h1 id="五、单表查询优化"><a href="#五、单表查询优化" class="headerlink" title="五、单表查询优化"></a>五、单表查询优化</h1><h2 id="1、全值匹配很快捷"><a href="#1、全值匹配很快捷" class="headerlink" title="1、全值匹配很快捷"></a>1、全值匹配很快捷</h2><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--建立符合索引（age, deptId, name）</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_ade <span class="hljs-keyword">ON</span> t_emp(age, deptId, <span class="hljs-keyword">NAME</span>);<span class="hljs-comment">--查找</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;<span class="hljs-comment">--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span> <span class="hljs-keyword">AND</span> age = <span class="hljs-number">90</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164200.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164241.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png" srcset="/img/loading.gif" alt=""></p><p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p><p><strong>结论：全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p><h2 id="2、最佳左前缀法则"><a href="#2、最佳左前缀法则" class="headerlink" title="2、最佳左前缀法则"></a>2、最佳左前缀法则</h2><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--先删除之前创建的单值索引</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_dept_id <span class="hljs-keyword">ON</span> t_emp; <span class="hljs-comment">--查询，未按照最佳左前缀法则</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">1</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;<span class="hljs-comment">--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span>  age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;<span class="hljs-comment">--查询，完全按照最佳左前缀法则</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164932.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164948.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817165100.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png" srcset="/img/loading.gif" alt=""></p><p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p><p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong></p><p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p><h2 id="3、索引列上不计算"><a href="#3、索引列上不计算" class="headerlink" title="3、索引列上不计算"></a>3、索引列上不计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--直接查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'风清扬'</span>;<span class="hljs-comment">--使用MySQL函数查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(age,<span class="hljs-number">2</span>) = <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170139.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170522.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p><p><strong>结论：等号左边无计算</strong></p><h2 id="4、范围之后全失效"><a href="#4、范围之后全失效" class="headerlink" title="4、范围之后全失效"></a>4、范围之后全失效</h2><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--范围查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'风清扬'</span>;<span class="hljs-comment">--未使用范围查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'风清扬'</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171833.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817172159.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171903.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p><p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p><p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p><h2 id="5、覆盖索引多使用"><a href="#5、覆盖索引多使用" class="headerlink" title="5、覆盖索引多使用"></a>5、覆盖索引多使用</h2><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--查询所有字段</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">--查询索引字段</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173338.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173314.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p><h2 id="6、使用不等会失效"><a href="#6、使用不等会失效" class="headerlink" title="6、使用不等会失效"></a>6、使用不等会失效</h2><p>在使用<strong>不等于(!= 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--SQL语句中有不等于</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age != <span class="hljs-number">90</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &lt;&gt; <span class="hljs-number">90</span>;<span class="hljs-comment">--SQL语句中没有不等于</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180448.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180505.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180521.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论：尽量不要使用不等于</strong></p><h2 id="7、使用NULL值要小心"><a href="#7、使用NULL值要小心" class="headerlink" title="7、使用NULL值要小心"></a>7、使用NULL值要小心</h2><p>在使用</p><pre><code class="hljs sql">IS NULL或者IS NOT NULL</code></pre><p>时，可能会导致索引失效</p><p>但是如果<strong>允许字段为空</strong>，则</p><ul><li>IS NULL 不会导致索引失效</li><li>IS NOT NULL 会导致索引失效</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181044.png" srcset="/img/loading.gif" alt=""></p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181116.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181137.png" srcset="/img/loading.gif" alt=""></p><h2 id="8、模糊查询加右边"><a href="#8、模糊查询加右边" class="headerlink" title="8、模糊查询加右边"></a>8、模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--创建单值索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_name <span class="hljs-keyword">ON</span> t_emp(<span class="hljs-keyword">NAME</span>);<span class="hljs-comment">--进行模糊查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%风'</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'风%'</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%风%'</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183401.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png" srcset="/img/loading.gif" alt=""></p><p>可以看出，对索引使用模糊查询时，<strong>只有当百分号在右边，索引为单值索引且模糊查询语句在最右边时，索引才会生效</strong></p><p>其他情况均失效了</p><p><strong>但是</strong>有时必须使用其他类型的模糊查询，这时就需要用<strong>覆盖索引</strong>来解决索引失效的问题</p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%风'</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'风%'</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NAME</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%风%'</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183801.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p><h2 id="9、字符串加单引号"><a href="#9、字符串加单引号" class="headerlink" title="9、字符串加单引号"></a>9、字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p><p><strong>用于查询的表</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817203952.png" srcset="/img/loading.gif" alt=""></p><p><strong>其中card_id字段为varchar类型，且设置了单值索引</strong></p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--使用了单引号</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id = <span class="hljs-string">'1'</span>;<span class="hljs-comment">--未使用单引号，发生自动类型转换</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id = <span class="hljs-number">1</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204047.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204027.png" srcset="/img/loading.gif" alt=""></p><h2 id="10、尽量不用or查询"><a href="#10、尽量不用or查询" class="headerlink" title="10、尽量不用or查询"></a>10、尽量不用or查询</h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--使用or进行查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'风清扬'</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204307.png" srcset="/img/loading.gif" alt=""></p><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全职匹配我最爱，最左前缀要遵守</p><p>带头大哥不能死，中间兄弟不能断</p><p>索引列上少计算，范围之后全失效</p><p>LIKE 百分写最右，覆盖索引不写*</p><p>不等空值还有 OR，索引影响要注意</p><p> VARCHAR 引号不可丢，SQL 优化有诀窍</p><h1 id="六、关联查询优化"><a href="#六、关联查询优化" class="headerlink" title="六、关联查询优化"></a>六、关联查询优化</h1><p><strong>建表语句</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`class`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">`card`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`book`</span> (<span class="hljs-string">`bookid`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">`card`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">UNSIGNED</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`bookid`</span>));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">class</span>(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span> + (<span class="hljs-keyword">RAND</span>() * <span class="hljs-number">20</span>)));</code></pre><h2 id="1、LEFT-JOIN优化"><a href="#1、LEFT-JOIN优化" class="headerlink" title="1、LEFT JOIN优化"></a>1、LEFT JOIN优化</h2><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--未建立索引时的左外连接查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card = book.card;<span class="hljs-comment">--左表（class）建立索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_class_card <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>(card);<span class="hljs-comment">--再次执行查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card = book.card;<span class="hljs-comment">--去掉左表索引</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_class_card <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>;<span class="hljs-comment">--右表建立索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_book_card <span class="hljs-keyword">ON</span> book(card);<span class="hljs-comment">--再次执行查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card = book.card;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170458.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170402.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170547.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论</strong></p><ul><li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li><li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li></ul><h2 id="2、INNER-JOIN优化"><a href="#2、INNER-JOIN优化" class="headerlink" title="2、INNER JOIN优化"></a>2、INNER JOIN优化</h2><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card = book.card;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">ON</span> book.card = class.card;<span class="hljs-comment">--删除book表中的几条记录</span><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> bookid&lt;<span class="hljs-number">10</span>;<span class="hljs-comment">--再次查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card = book.card;<span class="hljs-comment">--删除book表card字段索引，给class表的card字段添加索引</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_book_card <span class="hljs-keyword">ON</span> book;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_class_card <span class="hljs-keyword">ON</span> <span class="hljs-keyword">class</span>(card);<span class="hljs-comment">--再次查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card = book.card;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171341.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171538.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171625.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p><p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p><h2 id="3、RIGHT-JOIN优化"><a href="#3、RIGHT-JOIN优化" class="headerlink" title="3、RIGHT JOIN优化"></a>3、RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p><h1 id="七、排序分组优化"><a href="#七、排序分组优化" class="headerlink" title="七、排序分组优化"></a>七、排序分组优化</h1><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p><p><strong>索引信息</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819160428.png" srcset="/img/loading.gif" alt=""></p><h2 id="1、ORDER-BY-优化"><a href="#1、ORDER-BY-优化" class="headerlink" title="1、ORDER BY 优化"></a>1、ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--不满足索引覆盖时进行排序查询</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<span class="hljs-comment">--按照复合索引顺序进行排序</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId, <span class="hljs-keyword">name</span>;<span class="hljs-comment">--不按照复合索引顺序进行排序（无 age 字段），发生Using filesort</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-keyword">name</span>;<span class="hljs-comment">--不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-keyword">name</span>, age;<span class="hljs-comment">--排序时部分(age)升序，部分(deptId)降序，发生Using filesort</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>, deptId <span class="hljs-keyword">DESC</span>;<span class="hljs-comment">--排序时都为降序</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>, deptId <span class="hljs-keyword">DESC</span>;<span class="hljs-comment">--排序时，在前面的字段为常量时（非范围）</span><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-keyword">name</span>;<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId&gt;<span class="hljs-number">10000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, <span class="hljs-keyword">name</span>;</code></pre><p><strong>对应结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162506.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162314.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200907210532.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162429.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162901.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164020.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164317.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论</strong>：</p><p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p><ul><li><p>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></p></li><li><p>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></p></li><li><p>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</p></li><li><p>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></p></li></ul><h3 id="MySQL的排序算法"><a href="#MySQL的排序算法" class="headerlink" title="MySQL的排序算法"></a>MySQL的排序算法</h3><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p><ul><li><strong>双路排序</strong><ul><li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li><li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li></ul></li><li><strong>单路排序</strong><ul><li>从磁盘读取查询需要的所有列，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li><li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I/O。也就是<strong>本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失</strong></li></ul></li><li><strong>优化Using filesort</strong><ul><li>增大 sort_butter_size 参数的设置<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li></ul></li><li>增大 max_length_for_sort_data 参数的设置<ul><li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li><li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I/O 活动和低的处理器使用率。（1024-8192 之间调整）</li></ul></li><li>减少 select 后面的查询的字段<ul><li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164341.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、GROUP-BY-优化"><a href="#2、GROUP-BY-优化" class="headerlink" title="2、GROUP BY 优化"></a>2、GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p><h1 id="八、截取查询分析"><a href="#八、截取查询分析" class="headerlink" title="八、截取查询分析"></a>八、截取查询分析</h1><h2 id="1、慢日志查询"><a href="#1、慢日志查询" class="headerlink" title="1、慢日志查询"></a>1、慢日志查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p><p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘%slow_query_log%’</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF</td></tr><tr><td>set global slow_query_log=1</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time=1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p><h2 id="2、批量数据脚本"><a href="#2、批量数据脚本" class="headerlink" title="2、批量数据脚本"></a>2、批量数据脚本</h2><h3 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h3><pre><code class="hljs sql"><span class="hljs-comment">--dept 部门表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`dept`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">`deptName`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">`address`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, ceo <span class="hljs-built_in">INT</span> <span class="hljs-literal">NULL</span> , PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;<span class="hljs-comment">-- emp 员工表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`emp`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">`empno`</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> , <span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">`age`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">`deptId`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>, PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)<span class="hljs-comment">#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。 否则会报错</p><pre><code class="hljs sql"><span class="hljs-comment">--查询</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'log_bin_trust_function_creators'</span>;<span class="hljs-comment">--设置</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_bin_trust_function_creators=<span class="hljs-number">1</span>;</code></pre><h3 id="编写随机函数"><a href="#编写随机函数" class="headerlink" title="编写随机函数"></a>编写随机函数</h3><h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a><strong>随机产生字符串</strong></h4><pre><code class="hljs sql"><span class="hljs-comment">--DELIMITER 是用于改变结束的标志的，一般以分号结尾，但这里改为了以 $$ 结尾</span>DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-built_in">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">255</span>)<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> chars_str <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span>;<span class="hljs-keyword">DECLARE</span> return_str <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span>;<span class="hljs-keyword">DECLARE</span> i <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;WHILE i &lt; n DO<span class="hljs-keyword">SET</span> return_str =<span class="hljs-keyword">CONCAT</span>(return_str,<span class="hljs-keyword">SUBSTRING</span>(chars_str,<span class="hljs-keyword">FLOOR</span>(<span class="hljs-number">1</span>+<span class="hljs-keyword">RAND</span>()*<span class="hljs-number">52</span>),<span class="hljs-number">1</span>));<span class="hljs-keyword">SET</span> i = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span>;RETURN return_str;<span class="hljs-keyword">END</span> $$</code></pre><p>如果要<strong>删除函数</strong>，则执行：</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> rand_string;</code></pre><h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><pre><code class="hljs sql">DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_num (from_num <span class="hljs-built_in">INT</span> ,to_num <span class="hljs-built_in">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>)<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> i <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">SET</span> i = <span class="hljs-keyword">FLOOR</span>(from_num +<span class="hljs-keyword">RAND</span>()*(to_num -from_num+<span class="hljs-number">1</span>)) ;RETURN i;<span class="hljs-keyword">END</span>$$</code></pre><p>如果要<strong>删除函数</strong>，则执行：</p><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> rand_num;</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><h4 id="创建往-emp-表中插入数据的存储过程"><a href="#创建往-emp-表中插入数据的存储过程" class="headerlink" title="创建往 emp 表中插入数据的存储过程"></a>创建往 emp 表中插入数据的存储过程</h4><pre><code class="hljs sql">DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp( <span class="hljs-keyword">START</span> <span class="hljs-built_in">INT</span> , max_num <span class="hljs-built_in">INT</span> )<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> i <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-comment">#set autocommit =0 把 autocommit 设置成 0</span><span class="hljs-keyword">SET</span> autocommit = <span class="hljs-number">0</span>;REPEAT<span class="hljs-keyword">SET</span> i = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (empno, <span class="hljs-keyword">NAME</span> ,age ,deptid ) <span class="hljs-keyword">VALUES</span> ((<span class="hljs-keyword">START</span>+i) ,rand_string(<span class="hljs-number">6</span>) , rand_num(<span class="hljs-number">30</span>,<span class="hljs-number">50</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>));UNTIL i = max_num<span class="hljs-keyword">END</span> <span class="hljs-keyword">REPEAT</span>;<span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">END</span>$$<span class="hljs-comment">--删除</span><span class="hljs-comment">-- DELIMITER ;</span><span class="hljs-comment">-- drop PROCEDURE insert_emp;</span></code></pre><h4 id="创建往-dept-表中插入数据的存储过程"><a href="#创建往-dept-表中插入数据的存储过程" class="headerlink" title="创建往 dept 表中插入数据的存储过程"></a>创建往 dept 表中插入数据的存储过程</h4><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 dept 表添加随机数据</span>DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">`insert_dept`</span>( max_num <span class="hljs-built_in">INT</span> )<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> i <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">SET</span> autocommit = <span class="hljs-number">0</span>;REPEAT<span class="hljs-keyword">SET</span> i = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept ( deptname,address,ceo ) <span class="hljs-keyword">VALUES</span> (rand_string(<span class="hljs-number">8</span>),rand_string(<span class="hljs-number">10</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>));UNTIL i = max_num<span class="hljs-keyword">END</span> <span class="hljs-keyword">REPEAT</span>;<span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">END</span>$$<span class="hljs-comment">--删除</span><span class="hljs-comment">-- DELIMITER ;</span><span class="hljs-comment">-- drop PROCEDURE insert_dept;</span></code></pre><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><h4 id="添加数据到部门表"><a href="#添加数据到部门表" class="headerlink" title="添加数据到部门表"></a>添加数据到部门表</h4><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 dept 表添加 1 万条数据</span>DELIMITER ;<span class="hljs-keyword">CALL</span> insert_dept(<span class="hljs-number">10000</span>);</code></pre><h4 id="添加数据到员工表"><a href="#添加数据到员工表" class="headerlink" title="添加数据到员工表"></a>添加数据到员工表</h4><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 emp 表添加 50 万条数据</span>DELIMITER ;<span class="hljs-keyword">CALL</span> insert_emp(<span class="hljs-number">100000</span>,<span class="hljs-number">500000</span>);</code></pre><h3 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h3><h4 id="删除索引的存储过程"><a href="#删除索引的存储过程" class="headerlink" title="删除索引的存储过程"></a>删除索引的存储过程</h4><pre><code class="hljs sql">DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">`proc_drop_index`</span>(dbname <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>),tablename <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>))<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> done <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">DECLARE</span> ct <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">DECLARE</span> _index <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span>;<span class="hljs-keyword">DECLARE</span> _cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> index_name <span class="hljs-keyword">FROM</span> information_schema.STATISTICS <span class="hljs-keyword">WHERE</span>table_schema=dbname <span class="hljs-keyword">AND</span> table_name=tablename <span class="hljs-keyword">AND</span> seq_in_index=<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> index_name &lt;&gt;<span class="hljs-string">'PRIMARY'</span> ;<span class="hljs-keyword">DECLARE</span> CONTINUE <span class="hljs-keyword">HANDLER</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">FOUND</span> <span class="hljs-keyword">set</span> done=<span class="hljs-number">2</span> ;OPEN _cur;FETCH _cur INTO _index;WHILE _index&lt;&gt;'' DO<span class="hljs-keyword">SET</span> @<span class="hljs-keyword">str</span> = <span class="hljs-keyword">CONCAT</span>(<span class="hljs-string">"drop index "</span>,_index,<span class="hljs-string">" on "</span>,tablename );<span class="hljs-keyword">PREPARE</span> sql_str <span class="hljs-keyword">FROM</span> @<span class="hljs-keyword">str</span> ;<span class="hljs-keyword">EXECUTE</span> sql_str;<span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> sql_str;<span class="hljs-keyword">SET</span> _index=<span class="hljs-string">''</span>;FETCH _cur INTO _index;<span class="hljs-keyword">END</span> <span class="hljs-keyword">WHILE</span>;CLOSE _cur;<span class="hljs-keyword">END</span>$$</code></pre><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> proc_drop_index(<span class="hljs-string">"dbname"</span>,<span class="hljs-string">"tablename"</span>);</code></pre><h1 id="九、MySQL锁机制"><a href="#九、MySQL锁机制" class="headerlink" title="九、MySQL锁机制"></a>九、MySQL锁机制</h1><h2 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h2><p><strong>MylSAM引擎使用表锁，并且不支持事务</strong></p><p><strong>SQL语句</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--展示表是否加锁</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span>;<span class="hljs-comment">--加锁 read (读锁) write (写锁)</span><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> table1 <span class="hljs-keyword">read</span>(write), table2 <span class="hljs-keyword">read</span>(write)...<span class="hljs-comment">--全部解锁</span><span class="hljs-keyword">UNLOCK</span> <span class="hljs-keyword">TABLES</span>;</code></pre><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><ul><li><p>主机A给表加上<strong>表锁（读锁）</strong>以后</p><ul><li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，<strong>会修改失败</strong></li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加锁并查询状态</p><pre><code class="hljs sql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> dept <span class="hljs-keyword">READ</span>;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151441.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><strong>读取</strong></p><ul><li><p>两个客户端分别读取dept表的信息，都能读出来</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre></li><li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152614.png" srcset="/img/loading.gif" alt=""></p></li><li><p>其他客户端读取度其他表信息，读取成功</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152714.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151654.png" srcset="/img/loading.gif" alt=""></p></li><li><p>客户端B对表中内容进行修改，进入阻塞状态</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151737.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>从客户端A解锁后，客户端B修改成功</p><pre><code class="hljs sql"><span class="hljs-keyword">UNLOCK</span> <span class="hljs-keyword">TABLES</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151818.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p><ul><li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，知道读锁被释放</strong></li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，修改成功</li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加上写锁并查看</p><pre><code class="hljs sql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> dept WRITE;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153259.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><strong>读取</strong></p><ul><li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153403.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153437.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>其他表读取该表信息，进入阻塞状态</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153517.png" srcset="/img/loading.gif" alt=""></p></li><li><p>释放后，读取成功</p><pre><code class="hljs SQL"><span class="hljs-keyword">UNLOCK</span> <span class="hljs-keyword">TABLES</span>;</code></pre></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A修改<strong>该表</strong>内容，修改成功</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153637.png" srcset="/img/loading.gif" alt=""></p></li><li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153710.png" srcset="/img/loading.gif" alt=""></p></li><li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p><h2 id="2、行锁"><a href="#2、行锁" class="headerlink" title="2、行锁"></a>2、行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong>，事务相关可参考 <a href="https://nyimac.gitee.io/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><strong>MySQL基础</strong></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>如果两个客户端<strong>对同一条记录进行修改</strong></p><ul><li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li><li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li></ul><p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p><p><strong>修改同一条记录</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--关闭自动提交</span><span class="hljs-keyword">SET</span> autocommit = <span class="hljs-number">0</span>;<span class="hljs-comment">--客户端A、B查询id=2的记录</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端A进行修改操作（将年龄改为了80），但未提交</span><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age = <span class="hljs-number">80</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端A进行查询</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端B进行查询</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端B进行修改（客户端A未提交）</span><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端A提交</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment">--客户端B提交</span><span class="hljs-keyword">COMMIT</span>;</code></pre><p><strong>对应结果</strong></p><p>客户端A查询结果</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png" srcset="/img/loading.gif" alt=""></p><p>客户端B查询结果</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png" srcset="/img/loading.gif" alt=""></p><p>客户端A修改后A查询</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163847.png" srcset="/img/loading.gif" alt=""></p><p>客户端A修改后B查询</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png" srcset="/img/loading.gif" alt=""></p><p>客户端A修改，未提交，此时B进行修改，<strong>被阻塞</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163957.png" srcset="/img/loading.gif" alt=""></p><p>客户端A提交后，B修改成功</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820164036.png" srcset="/img/loading.gif" alt=""></p><p><strong>修改不同记录</strong></p><pre><code class="hljs sql"><span class="hljs-comment">--客户端A对id=2的年龄进行修改</span><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age = <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端B对id=3的年龄进行修改</span><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age = <span class="hljs-number">30</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">3</span>;<span class="hljs-comment">--客户端A，B分别提交</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">COMMIT</span>;</code></pre><p>因为InnoDB使用行锁，对于不同行的操作，不会出现阻塞现象</p><h3 id="索引失效-1"><a href="#索引失效-1" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，<strong>行锁变表锁</strong></p><p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p><p>所以要<strong>避免索引失效</strong></p><h3 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p><p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)</strong>” ，<strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><pre><code class="hljs sql"><span class="hljs-comment">--查询表记录，此处没有id=2的记录</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-comment">--客户端A进行范围查询，但是范围内没有id=2的记录</span><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> deptId = <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">id</span> &lt; <span class="hljs-number">6</span>;<span class="hljs-comment">--客户端B进行插入数据，插入一条id=2的记录</span><span class="hljs-keyword">INSERT</span> t_emp <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'岳不群'</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100002</span>); <span class="hljs-comment">--客户端A提交</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment">--客户端B提交</span><span class="hljs-keyword">COMMIT</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170126.png" srcset="/img/loading.gif" alt=""></p><p><strong>客户端B进入阻塞状态</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170617.png" srcset="/img/loading.gif" alt=""></p><p>提交后，插入成功</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170654.png" srcset="/img/loading.gif" alt=""></p><p><strong>结论</strong>：可以看到表中本来<strong>没有id=2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p><h3 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a>锁住指定的一行</h3><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<span class="hljs-comment">--锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<span class="hljs-comment">--进行修改操作</span><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'风车车'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">--提交</span><span class="hljs-keyword">COMMIT</span>;</code></pre><p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p><h1 id="十、复制"><a href="#十、复制" class="headerlink" title="十、复制"></a>十、复制</h1><h2 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133613.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li><li><strong>从服务器</strong>可以使用 <a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E5%BC%95%E6%93%8E%E5%B1%82">MyISAM</a>，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133739.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础学习"><a href="#MySQL基础学习" class="headerlink" title="MySQL基础学习"></a>MySQL基础学习</h1><h1 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h1><h2 id="1、创建数据库和表"><a href="#1、创建数据库和表" class="headerlink" title="1、创建数据库和表"></a>1、创建数据库和表</h2><p>创建数据库语句</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">database</span>;</code></pre><p>展示所有数据库</p><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">DATABASES</span>;</code></pre><p>使用指定数据库</p><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> <span class="hljs-keyword">database</span>;</code></pre><p>创建表</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(    s_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生学号'</span>,    s_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生姓名 不能为空'</span>,    s_sex <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生性别'</span>,    s_birthday DATETIME <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生生日'</span>,    s_class <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生所在的班级'</span>);</code></pre><p>展示表</p><pre><code class="hljs sql"><span class="hljs-keyword">DESCRIBE</span> <span class="hljs-keyword">table</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200807154719.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、对表的操作"><a href="#2、对表的操作" class="headerlink" title="2、对表的操作"></a>2、对表的操作</h2><h3 id="查看操作"><a href="#查看操作" class="headerlink" title="查看操作"></a>查看操作</h3><p>查看表中的记录</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span>;</code></pre><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">''</span>, <span class="hljs-string">''</span>...);</code></pre><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> cow = <span class="hljs-string">''</span>;</code></pre><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">SET</span> cow1 = <span class="hljs-string">''</span> <span class="hljs-keyword">WHERE</span> cow2 = <span class="hljs-string">''</span>;</code></pre><h1 id="二、约束"><a href="#二、约束" class="headerlink" title="二、约束"></a>二、约束</h1><h2 id="1、主键"><a href="#1、主键" class="headerlink" title="1、主键"></a>1、主键</h2><p>能够唯一确定表中的一条记录。我们通过给某个字段添加该约束，就可以使得该字段不重复且不为空。</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user2 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),    PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>));</code></pre><p>此处字段id和name一同作为主键，联合主键要求每个字段<strong>加起来不同即可</strong>（无需每个字段都不同）</p><h3 id="建表后添加主键"><a href="#建表后添加主键" class="headerlink" title="建表后添加主键"></a>建表后添加主键</h3><pre><code class="hljs sql">ALERT TABLE user2 ADD PRIMARY KEY (id);</code></pre><p>或者通过<strong>修改字段</strong>的方式来添加主键</p><pre><code class="hljs sql">ALERT TABLE user2 MODIFY id INT PRIMARY KEY;</code></pre><h3 id="建表后删除主键"><a href="#建表后删除主键" class="headerlink" title="建表后删除主键"></a>建表后删除主键</h3><pre><code class="hljs sql">ALERT TABLE user2 <span class="hljs-keyword">DROP</span>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>);</code></pre><h2 id="2、自增约束"><a href="#2、自增约束" class="headerlink" title="2、自增约束"></a>2、自增约束</h2><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user3 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREAMENT,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user3 (<span class="hljs-keyword">name</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'name'</span>); //插入成功，自动生成了id</code></pre><p>自增约束一般<strong>与主键搭配使用</strong></p><h2 id="3、唯一约束"><a href="#3、唯一约束" class="headerlink" title="3、唯一约束"></a>3、唯一约束</h2><p>约束修饰的字段不可以重复</p><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREAMENT <span class="hljs-keyword">UNIQUE</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre><p>或者</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREAMENT,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">UNIQUE</span>(<span class="hljs-keyword">id</span>, <span class="hljs-keyword">name</span>));</code></pre><h2 id="4、非空约束"><a href="#4、非空约束" class="headerlink" title="4、非空约束"></a>4、非空约束</h2><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),);</code></pre><h2 id="5、默认约束"><a href="#5、默认约束" class="headerlink" title="5、默认约束"></a>5、默认约束</h2><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),);</code></pre><p>如果我们插入字段时没有传值，就会<strong>使用默认值</strong></p><h2 id="6、外键约束"><a href="#6、外键约束" class="headerlink" title="6、外键约束"></a>6、外键约束</h2><p>主表</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">master</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre><p>从表</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pet(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),master_id <span class="hljs-built_in">int</span>,<span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(master_id) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">master</span>(<span class="hljs-keyword">id</span>));</code></pre><ul><li>主表中没有的数据，在副表中是不可以使用的</li><li>主表中的数据被副标引用时，是不可以删除的</li></ul><h1 id="三、数据库的三大范式"><a href="#三、数据库的三大范式" class="headerlink" title="三、数据库的三大范式"></a>三、数据库的三大范式</h1><h2 id="1、第一范式"><a href="#1、第一范式" class="headerlink" title="1、第一范式"></a>1、第一范式</h2><p><strong>字段还可以拆分的，就不满足第一范式</strong></p><p>比如地址如果写为</p><pre><code class="hljs plain">地址：四川省成都市高新区天府一街</code></pre><p>就是可以被拆分的</p><p>如果字段写为</p><pre><code class="hljs plain">省份：四川省城市：成都市区域：高新区街名：天府一街</code></pre><p>就是不可拆分的</p><p>建表如下</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCRAEMENT,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),province <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),city <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),area <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),street: <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre><p>就是<strong>符合第一范式</strong>的，但<strong>并不是拆分的越详细越好</strong></p><h2 id="2、第二范式"><a href="#2、第二范式" class="headerlink" title="2、第二范式"></a>2、第二范式</h2><ul><li><p>满足第一范式的条件下，第二范式要求：<strong>除主键外的每一列，都必须完全依赖于主键</strong></p></li><li><p>如果出现不完全依赖，则只可能发生在<strong>联合主键</strong>的情况下</p></li></ul><p><strong>不满足第二范式的例子</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(product_id <span class="hljs-built_in">INT</span>,customer_id <span class="hljs-built_in">INT</span>,product_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),customer_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),    PRIMARY <span class="hljs-keyword">KEY</span>(product_id, customer_id));</code></pre><p>此处product_name只依赖于product_id，customer_name只依赖于customer_id，是完全依赖</p><p><strong>满足第二范式的例子</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,product_id <span class="hljs-built_in">INT</span>,customer_id <span class="hljs-built_in">INT</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre><h2 id="3、第三范式"><a href="#3、第三范式" class="headerlink" title="3、第三范式"></a>3、第三范式</h2><ul><li>满足第二范式，除主键外的其他列之间不能有传递依赖关系</li></ul><p><strong>不满足第三范式的例子</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,product_id <span class="hljs-built_in">INT</span>,customer_id <span class="hljs-built_in">INT</span>,customer_phone <span class="hljs-built_in">INT</span>);</code></pre><p>此处customer_phone又依赖于customer_id，存在传递依赖关系，不满足第三范式</p><p><strong>满足第三范式的例子</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,product_id <span class="hljs-built_in">INT</span>,customer_id <span class="hljs-built_in">INT</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),    phone <span class="hljs-built_in">INT</span>);</code></pre><h1 id="四、查询练习"><a href="#四、查询练习" class="headerlink" title="四、查询练习"></a>四、查询练习</h1><p>建表语句及插入语句</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(    s_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生学号'</span>,    s_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生姓名 不能为空'</span>,    s_sex <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生性别'</span>,    s_birthday DATETIME <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生生日'</span>,    s_class <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'学生所在的班级'</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> teacher(    t_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师编号'</span>,    t_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师姓名'</span>,    t_sex <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师性别'</span>,    t_birthday DATETIME <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师生日'</span>,    t_rof <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师职称'</span>,    t_depart <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师所在的部门'</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> course(    c_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'课程号'</span>,    c_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'课程名称'</span>,    t_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'教师编号 外键关联teacher表'</span>,    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(t_no) <span class="hljs-keyword">references</span> teacher(t_no));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> score (    s_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'成绩表的编号 依赖学生学号'</span>,        c_no <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span><span class="hljs-string">'课程号 依赖于课程表中的c_id'</span>,    sc_degree <span class="hljs-built_in">decimal</span>,    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(s_no) <span class="hljs-keyword">references</span> student(s_no),    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(c_no) <span class="hljs-keyword">references</span> course(c_no),    PRIMARY <span class="hljs-keyword">KEY</span>(s_no,c_no));</code></pre><pre><code class="hljs sql"><span class="hljs-comment">--学生表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'101'</span>,<span class="hljs-string">'曾华'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1977-09-01'</span>,<span class="hljs-string">'95033'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'102'</span>,<span class="hljs-string">'匡明'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1975-10-02'</span>,<span class="hljs-string">'95031'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'103'</span>,<span class="hljs-string">'王丽'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-string">'1976-01-23'</span>,<span class="hljs-string">'95033'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'104'</span>,<span class="hljs-string">'李军'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1976-02-20'</span>,<span class="hljs-string">'95033'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'105'</span>,<span class="hljs-string">'王芳'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-string">'1975-02-10'</span>,<span class="hljs-string">'95031'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'106'</span>,<span class="hljs-string">'陆军'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1974-06-03'</span>,<span class="hljs-string">'95031'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'107'</span>,<span class="hljs-string">'王尼玛'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1976-02-20'</span>,<span class="hljs-string">'95033'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'108'</span>,<span class="hljs-string">'张全蛋'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1975-02-10'</span>,<span class="hljs-string">'95031'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'109'</span>,<span class="hljs-string">'赵铁柱'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1974-06-03'</span>,<span class="hljs-string">'95031'</span>);<span class="hljs-comment">--教师表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'804'</span>,<span class="hljs-string">'李诚'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1958-12-02'</span>,<span class="hljs-string">'副教授'</span>,<span class="hljs-string">'计算机系'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'856'</span>,<span class="hljs-string">'张旭'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1969-03-12'</span>,<span class="hljs-string">'讲师'</span>,<span class="hljs-string">'电子工程系'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'825'</span>,<span class="hljs-string">'王萍'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-string">'1972-05-05'</span>,<span class="hljs-string">'助教'</span>,<span class="hljs-string">'计算机系'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'831'</span>,<span class="hljs-string">'刘冰'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-string">'1977-08-14'</span>,<span class="hljs-string">'助教'</span>,<span class="hljs-string">'电子工程系'</span>);<span class="hljs-comment">--添加课程表</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3-105'</span>,<span class="hljs-string">'计算机导论'</span>,<span class="hljs-string">'825'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3-245'</span>,<span class="hljs-string">'操作系统'</span>,<span class="hljs-string">'804'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'6-166'</span>,<span class="hljs-string">'数字电路'</span>,<span class="hljs-string">'856'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'9-888'</span>,<span class="hljs-string">'高等数学'</span>,<span class="hljs-string">'831'</span>);<span class="hljs-comment">--添加成绩表</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'103'</span>,<span class="hljs-string">'3-245'</span>,<span class="hljs-string">'86'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'105'</span>,<span class="hljs-string">'3-245'</span>,<span class="hljs-string">'75'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'109'</span>,<span class="hljs-string">'3-245'</span>,<span class="hljs-string">'68'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'103'</span>,<span class="hljs-string">'3-105'</span>,<span class="hljs-string">'92'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'105'</span>,<span class="hljs-string">'3-105'</span>,<span class="hljs-string">'88'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'109'</span>,<span class="hljs-string">'3-105'</span>,<span class="hljs-string">'76'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'103'</span>,<span class="hljs-string">'6-166'</span>,<span class="hljs-string">'85'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'105'</span>,<span class="hljs-string">'6-166'</span>,<span class="hljs-string">'79'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'109'</span>,<span class="hljs-string">'6-166'</span>,<span class="hljs-string">'81'</span>);</code></pre><ul><li>查询student表中所有记录的s_name,s_sex和s_class列</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no,s_name,s_class <span class="hljs-keyword">FROM</span>  student;</code></pre><ul><li>查询教师所有的单位但是不重复的t_depart列</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>(t_depart) <span class="hljs-keyword">FROM</span> teacher;</code></pre><ul><li>查询score表中成绩在60-80之间所有的记录(sc_degree)</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">80</span>;<span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> sc_degree &lt; <span class="hljs-number">80</span>;</code></pre><ul><li>查询score表中成绩为85, 86, 或者88的记录(sc_degree)</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-keyword">IN</span>(<span class="hljs-number">85</span>, <span class="hljs-number">86</span>, <span class="hljs-number">88</span>);</code></pre><ul><li>查询student表中’95031’班或者性别为’女’的同学记录</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class = <span class="hljs-string">'95031'</span> <span class="hljs-keyword">OR</span> s_sex = <span class="hljs-string">'女'</span>;</code></pre><ul><li>以sc_degree降序查询score表中所有的记录</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre><ul><li>查询’95031’班的学生人数</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class = <span class="hljs-string">'95031'</span>;</code></pre><ul><li>查询score表中的最高分数的学生号和课程号</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, c_no <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree = (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(sc_degree) <span class="hljs-keyword">FROM</span> score);</code></pre><ul><li>查询每门课的平均成绩</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-keyword">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_no;</code></pre><ul><li>查询score表中至少有2名学生选修的,并且以3开头的课程的平均分</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-keyword">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_no <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(c_no) &gt;=<span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c_no <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'3%'</span>;</code></pre><ul><li>查询所有的学生 s_name , c_no, sc_degree列</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, c_no, sc_degree <span class="hljs-keyword">FROM</span> student, score <span class="hljs-keyword">WHERE</span> student.s_no = score.s_no;</code></pre><ul><li>查询所有学生的s_no, c_name, sc_degree列</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, c_name, sc_degree <span class="hljs-keyword">FROM</span> student, score, course <span class="hljs-keyword">WHERE</span> student.s_no = score.s_no <span class="hljs-keyword">AND</span> score.c_no = course.c_no;</code></pre><ul><li>查询所有的学生 s_name , c_name, sc_degree列</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, c_name, sc_degree <span class="hljs-keyword">FROM</span> student, score, course <span class="hljs-keyword">WHERE</span> student.s_no = score.s_no <span class="hljs-keyword">AND</span> score.c_no = course.c_no;</code></pre><ul><li>查询班级是’95031’班学生每门课的平均分</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-keyword">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> s_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> s_no <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class = <span class="hljs-string">'95031'</span>) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>(c_no);<span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-keyword">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">ON</span> s.s_no = sc.s_no <span class="hljs-keyword">WHERE</span> s_class = <span class="hljs-string">'95031'</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_no;<span class="hljs-comment">--查询内容包含课程名（c_name）</span><span class="hljs-keyword">SELECT</span> c.c_no, c.c_name, <span class="hljs-keyword">AVG</span>(sc.sc_degree) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, course <span class="hljs-keyword">AS</span> c, score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">WHERE</span> s.s_no = sc.s_no <span class="hljs-keyword">AND</span> sc.c_no = c.c_no <span class="hljs-keyword">AND</span> s.s_class = <span class="hljs-string">'95031'</span>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.c_no;</code></pre><ul><li>查询选修”3-105”课程的成绩高于’109’号同学’3-105’成绩 的所有同学的记录</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">WHERE</span> sc.sc_degree &gt; (<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> s_no = <span class="hljs-string">'109'</span> <span class="hljs-keyword">AND</span> c_no = <span class="hljs-string">'3-105'</span>) <span class="hljs-keyword">AND</span> sc.c_no = <span class="hljs-string">'3-105'</span> <span class="hljs-keyword">AND</span> s.s_no = sc.s_no;</code></pre><ul><li>查询所有与学号为108.101的同学同年出生的所有学生的s_no,s_name和s_birthday</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(s_birthday) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(s_birthday) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_no <span class="hljs-keyword">IN</span> (<span class="hljs-string">'101'</span>, <span class="hljs-string">'108'</span>));</code></pre><ul><li>查询 张旭 教师任课的学生的成绩</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name, sc.sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> sc, student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">WHERE</span> c_no = (<span class="hljs-keyword">SELECT</span> c_no <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">WHERE</span> t_no = (<span class="hljs-keyword">SELECT</span> t_no <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_name = <span class="hljs-string">'张旭'</span>)) <span class="hljs-keyword">AND</span> s.s_no = sc.s_no;</code></pre><ul><li>查询95033班和95031班全体学生的记录</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class <span class="hljs-keyword">IN</span> (<span class="hljs-string">'95033'</span>, <span class="hljs-string">'95031'</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s_class;</code></pre><ul><li>查询存在85分以上成绩的c_name和对应的老师</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t_name, c_name <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">AS</span> c, teacher <span class="hljs-keyword">AS</span> t <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> c_no <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree &gt; <span class="hljs-number">85</span>) <span class="hljs-keyword">AND</span> c.t_no = t.t_no;</code></pre><ul><li>查出所有’计算机系’ 教师所教课程的教师信息、课程信息及学生信息</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  * <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">AS</span> t, course <span class="hljs-keyword">AS</span> c, student <span class="hljs-keyword">AS</span> s, score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">WHERE</span> s.s_no = sc.s_no <span class="hljs-keyword">AND</span> c.t_no = t.t_no <span class="hljs-keyword">AND</span> sc.c_no = c.c_no <span class="hljs-keyword">AND</span> t.t_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_no <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart = <span class="hljs-string">'计算机系'</span>);</code></pre><ul><li>查询’计算机系’与’电子工程系’ 不同职称的教师的name和rof</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart = <span class="hljs-string">'计算机系'</span> <span class="hljs-keyword">AND</span> t_rof <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_rof <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart = <span class="hljs-string">'电子工程系'</span>)<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart = <span class="hljs-string">'电子工程系'</span> <span class="hljs-keyword">AND</span> t_rof <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_rof <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart = <span class="hljs-string">'计算机系'</span>);</code></pre><ul><li>查询选修编号为”3-105”课程且成绩<strong>至少</strong>高于选修编号为’3-245’同学的c_no,s_no和sc_degree,并且按照sc_degree从高到地次序排序</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no = <span class="hljs-string">'3-105'</span> <span class="hljs-keyword">AND</span> sc_degree &gt; <span class="hljs-keyword">ANY</span>(<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no = <span class="hljs-string">'3-245'</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre><ul><li>查询选修编号为”3-105”且成绩高于选修编号为”3-245”课程的同学c_no.s_no和sc_degree</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no = <span class="hljs-string">'3-105'</span> <span class="hljs-keyword">AND</span> sc_degree &gt; <span class="hljs-keyword">ALL</span>(<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no = <span class="hljs-string">'3-245'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre><ul><li>查出学生的信息,课程名称,分数(s_name c_name,sc_degree)</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name, c.c_name, sc.sc_degree <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, course <span class="hljs-keyword">AS</span> c, score <span class="hljs-keyword">AS</span> sc<span class="hljs-keyword">WHERE</span> s.s_no = sc.s_no<span class="hljs-keyword">AND</span> c.c_no = sc.c_no<span class="hljs-keyword">AND</span> sc.sc_degree &gt; <span class="hljs-keyword">ALL</span>(<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no = <span class="hljs-string">'3-245'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre><p>总结: </p><ul><li>ANY 和 ALL<ul><li>ANY:表示任何一个就行了,如;数组A中的值比数组B中任何一个都要大,那么只要A和B中最小的比较就行了</li><li>ALL:表示所有都要比较,如:数组A中的值比数组B中所有的数都要大,那么A要和B中最大的值比较才行</li></ul></li></ul><ul><li>查询所有教师和同学的 name ,sex, birthday</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, s_sex, s_birthday <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> t_name, t_sex, t_birthday <span class="hljs-keyword">FROM</span> teacher;</code></pre><ul><li>查询所有’女’教师和’女’学生的name,sex,birthday</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, s_sex, s_birthday <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex = <span class="hljs-string">'女'</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> t_name, t_sex, t_birthday <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_sex = <span class="hljs-string">'女'</span>;</code></pre><ul><li>查询成绩比该课程平均成绩低的同学的成绩表</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">WHERE</span> sc_degree &lt; (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">WHERE</span> a.c_no = b.c_no);</code></pre><ul><li>查询成绩比该课程平均成绩低的同学的成绩表，并显示出学生name,课程name以及分数</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name <span class="hljs-keyword">AS</span> 学生姓名, c.c_name <span class="hljs-keyword">AS</span> 课程名, a.sc_degree <span class="hljs-keyword">AS</span> 成绩  <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> a, student <span class="hljs-keyword">AS</span> s, course <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">WHERE</span> sc_degree &lt; (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">WHERE</span> a.c_no = b.c_no)<span class="hljs-keyword">AND</span> s.s_no = a.s_no<span class="hljs-keyword">AND</span> c.c_no = a.c_no;</code></pre><ul><li>查询所有任课教师的t_name 和 t_depart(要在分数表中可以查得到)</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_no <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> c_no <span class="hljs-keyword">FROM</span> score));</code></pre><ul><li>查出至少有2名男生的班号</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_class <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex = <span class="hljs-string">'男'</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_class <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(s_no) &gt; <span class="hljs-number">1</span>;</code></pre><ul><li>查询student 表中 不姓”王”的同学的记录</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'王%'</span>;</code></pre><ul><li>查询student 中每个学生的姓名和年龄(当前时间 - 出生年份)</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name <span class="hljs-keyword">AS</span> 姓名, (<span class="hljs-keyword">YEAR</span>(<span class="hljs-keyword">NOW</span>())-<span class="hljs-keyword">YEAR</span>(s_birthday)) <span class="hljs-keyword">AS</span> 年龄 <span class="hljs-keyword">FROM</span> student;</code></pre><ul><li>查询student中最大和最小的 s_birthday的值</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(s_birthday), <span class="hljs-keyword">MIN</span>(s_birthday) <span class="hljs-keyword">FROM</span> student;</code></pre><ul><li>以班级号和年龄从大到小的顺序查询student表中的全部记录</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s_class <span class="hljs-keyword">DESC</span>, (<span class="hljs-keyword">YEAR</span>(<span class="hljs-keyword">NOW</span>()) - <span class="hljs-keyword">YEAR</span>(s_birthday)) <span class="hljs-keyword">DESC</span>;</code></pre><ul><li>查询”男”教师 及其所上的课</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t.t_name, c.c_name <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">AS</span> t, course <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">WHERE</span> t.t_sex = <span class="hljs-string">'男'</span>  <span class="hljs-keyword">AND</span> t.t_no = c.t_no;</code></pre><ul><li>查询最高分同学的s_no c_no 和 sc_degree;</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_no = (<span class="hljs-keyword">SELECT</span> s_no <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree  = (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(sc_degree) <span class="hljs-keyword">FROM</span> score));</code></pre><ul><li>查询和”李军”同性别的所有同学的s_name</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex =  (<span class="hljs-keyword">SELECT</span> s_sex <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name = <span class="hljs-string">'李军'</span>);</code></pre><ul><li>查询和”李军”同性别并且同班的所有同学的s_name</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex =  (<span class="hljs-keyword">SELECT</span> s_sex <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name = <span class="hljs-string">'李军'</span>)<span class="hljs-keyword">AND</span> s_class = (<span class="hljs-keyword">SELECT</span> s_class <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name = <span class="hljs-string">'李军'</span>);</code></pre><ul><li>查询所有选修’计算机导论’课程的’男’同学的成绩表，并显示出s_name,c_name</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name, c.c_name, sc.sc_degree <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, score <span class="hljs-keyword">AS</span> sc, course <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">WHERE</span> s.s_no = sc.s_no <span class="hljs-keyword">AND</span> c.c_no = sc.c_no <span class="hljs-keyword">AND</span> c.c_name = <span class="hljs-string">'计算机导论'</span><span class="hljs-keyword">AND</span> s.s_sex = <span class="hljs-string">'男'</span>;</code></pre><h1 id="五、连接查询"><a href="#五、连接查询" class="headerlink" title="五、连接查询"></a>五、连接查询</h1><p>建表语句</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),card_id <span class="hljs-built_in">INT</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> card (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> card <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'饭卡'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> card <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'建行卡'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> card <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>, <span class="hljs-string">'工商卡'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> card <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>, <span class="hljs-string">'农行卡'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> card <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">5</span>, <span class="hljs-string">'邮政卡'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-number">3</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>, <span class="hljs-string">'王五'</span>, <span class="hljs-number">6</span>);</code></pre><p><strong>没有创建外键时，可以使用内外查询将两个表的内容合并在一起查询</strong></p><h2 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h2><pre><code class="hljs SQL">INNER JOIN ... ON ...</code></pre><p>举例：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> card  <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">ON</span> p.card_id = c.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810195054.png" srcset="/img/loading.gif" alt=""></p><p><strong>内联查询：两张表通过某个字段合并起来，查询出相关数据</strong></p><h2 id="2、外连接"><a href="#2、外连接" class="headerlink" title="2、外连接"></a>2、外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><pre><code class="hljs sql">LEFT JOIN ... ON ...或LEFT OUTER JOIN ... ON ...</code></pre><p>举例：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> card <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">ON</span> p.card_id = c.id;或者<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> card <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">ON</span> p.card_id = c.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810195219.png" srcset="/img/loading.gif" alt=""></p><p><strong>左外连接：</strong></p><ul><li><p>会把左表里的所有数据都取出来</p></li><li><p>对于右表，如果有数据就取出，如果没有就为空</p></li></ul><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><pre><code class="hljs lasso">RIGHT <span class="hljs-keyword">JOIN</span> <span class="hljs-params">...</span> <span class="hljs-keyword">ON</span> <span class="hljs-params">...</span>或RIGHT OUTER <span class="hljs-keyword">JOIN</span> <span class="hljs-params">...</span> <span class="hljs-keyword">ON</span> <span class="hljs-params">...</span></code></pre><p>举例：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> card <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">ON</span> p.card_id = c.id;或<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> card <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">ON</span> p.card_id = c.id;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810195526.png" srcset="/img/loading.gif" alt=""></p><p><strong>右外连接</strong></p><ul><li>会把右表中的所有数据都取出来</li><li>对于左表，如果有数据就取出，如果没有就为空</li></ul><h2 id="3、三种连接的图解"><a href="#3、三种连接的图解" class="headerlink" title="3、三种连接的图解"></a>3、三种连接的图解</h2><p><strong>内连接</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810200025.png" srcset="/img/loading.gif" alt=""></p><p><strong>左连接</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810200040.png" srcset="/img/loading.gif" alt=""></p><p><strong>右连接</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810200104.png" srcset="/img/loading.gif" alt=""></p><h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><p>事务是一个最小的不可分割的单元，事务能够保证一个业务的完整性</p><p>多条sql语句<strong>要么同时成功，要么同时失败</strong>，这时就要用到事务</p><h2 id="1、自动提交、手动提交和回滚"><a href="#1、自动提交、手动提交和回滚" class="headerlink" title="1、自动提交、手动提交和回滚"></a>1、自动提交、手动提交和回滚</h2><p>通过</p><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;</code></pre><p>指令可以回滚，但需要关闭自动提交</p><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> autocommit = <span class="hljs-number">0</span>查看自动提交状态<span class="hljs-keyword">SELECT</span> @@autocommit;</code></pre><p>但如果在进行操作之后，执行</p><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;</code></pre><p>则无法再进行回滚（持久化）</p><h2 id="2、手动开启事务"><a href="#2、手动开启事务" class="headerlink" title="2、手动开启事务"></a>2、手动开启事务</h2><p>通过</p><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;或者<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</code></pre><p>可以手动开启事务</p><p><strong>插入数据前</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810204606.png" srcset="/img/loading.gif" alt=""></p><p><strong>插入数据后</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">'老六'</span>, <span class="hljs-number">7</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">'老七'</span>, <span class="hljs-number">9</span>);或者<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">'老六'</span>, <span class="hljs-number">7</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">'老七'</span>, <span class="hljs-number">9</span>);</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810204849.png" srcset="/img/loading.gif" alt=""></p><p><strong>回滚后</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810204930.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、四大特征-ACID"><a href="#3、四大特征-ACID" class="headerlink" title="3、四大特征 ACID"></a>3、四大特征 ACID</h2><ul><li>原子性：事务是最小的单位，<strong>不可再分</strong></li><li>一致性：同一事务中的sql语句<strong>要么同时成功，要么同时失败</strong></li><li>隔离性：事务1和事务2之间具有隔离性</li><li>持久性：事物<strong>一旦结束</strong>（commit），就<strong>不可返回</strong>（rollback）</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul><li>事务的隔离级别<ul><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可以重复读 repeatable read</li><li>串行化 serializable</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200811132934.png" srcset="/img/loading.gif" alt=""></p><ul><li>事务的并发问题<ul><li>脏读：事务A读取了事务B更新的数据，然后<strong>B回滚操作</strong>，那么<strong>A读取到的数据是脏数据</strong></li><li>不可重复读：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了<strong>更新并提交</strong>，<strong>导致事务A多次读取同一数据时，结果不一致</strong></li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读</li></ul></li></ul><p><strong>总结</strong>：不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p><p>​            解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><ul><li>查看数据库的隔离级别</li></ul><pre><code class="hljs sql">版本 5.x<span class="hljs-keyword">SELECT</span> @@global.tx_isolation;版本 8.0<span class="hljs-keyword">SELECT</span> @@global.transaction_isolation;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200811132716.png" srcset="/img/loading.gif" alt=""></p><ul><li>修改数据库的隔离级别</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> committed;</code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2020/07/03/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/07/03/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本博客是根据<a href="https://www.bilibili.com/video/BV1yE411Z7AP" target="_blank" rel="noopener"><strong>解密JVM【黑马程序员出品】</strong></a>教学视频学习时，所做的笔记</p><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></p></li><li><p>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</p></li><li><p>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></p></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;method1();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = a + b;<span class="hljs-keyword">return</span> c;&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" srcset="/img/loading.gif" alt=""></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong>    通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong>  通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" srcset="/img/loading.gif" alt=""></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" srcset="/img/loading.gif" alt=""></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><pre><code class="hljs taggerscript">F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\b</span>in&gt;javac F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.java</code></pre><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><pre><code class="hljs taggerscript">javap -v F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.class</code></pre></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" srcset="/img/loading.gif" alt=""></p></li><li><p>常量池</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" srcset="/img/loading.gif" alt=""></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，<strong>#号的内容需要在常量池中查找</strong>）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是<em>.class文件中的，当该*</em>类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址变为真实地址**</li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>; String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;&#125;&#125;</code></pre><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><span class="hljs-number">2</span>: astore_1<span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><span class="hljs-number">5</span>: astore_2<span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><span class="hljs-number">8</span>: astore_3<span class="hljs-number">9</span>: <span class="hljs-keyword">return</span></code></pre><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>;String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">//拼接字符串对象来创建新的字符串</span>String ab2 = a+b; &#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs angelscript"> Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span>         <span class="hljs-number">2</span>: astore_1         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span>         <span class="hljs-number">5</span>: astore_2         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>         <span class="hljs-number">8</span>: astore_3         <span class="hljs-number">9</span>: new           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>        <span class="hljs-number">12</span>: dup        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span>ing;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span></code></pre><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><pre><code class="hljs java">String ab = <span class="hljs-string">"ab"</span>;String ab2 = a+b;<span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span>System.out.println(ab == ab2);</code></pre><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>;String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;String ab2 = a+b;<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span>String ab3 = <span class="hljs-string">"a"</span> + <span class="hljs-string">"b"</span>;&#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs angelscript">   Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span>         <span class="hljs-number">2</span>: astore_1         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span>         <span class="hljs-number">5</span>: astore_2         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>         <span class="hljs-number">8</span>: astore_3         <span class="hljs-number">9</span>: new           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>        <span class="hljs-number">12</span>: dup        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span>ing;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);<span class="hljs-comment">//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象</span>String st2 = str.intern();<span class="hljs-comment">//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回</span>String str3 = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true</span>System.out.println(str == st2);System.out.println(str == str3);&#125;&#125;</code></pre><p><strong>例2</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中</span>String str3 = <span class="hljs-string">"ab"</span>;        <span class="hljs-comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);        <span class="hljs-comment">//此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"</span>String str2 = str.intern();        <span class="hljs-comment">//false</span>System.out.println(str == str2);        <span class="hljs-comment">//false</span>System.out.println(str == str3);        <span class="hljs-comment">//true</span>System.out.println(str2 == str3);&#125;&#125;</code></pre><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=xxxx</code></pre><p>​    </p></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" srcset="/img/loading.gif" alt=""></p><p><strong>使用了DirectBuffer</strong> </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" srcset="/img/loading.gif" alt=""></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;</code></pre><p>DirectByteBuffer类</p><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span>       <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    <span class="hljs-keyword">int</span> ps = Bits.pageSize();    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));    Bits.reserveMemory(size, cap);    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;    <span class="hljs-keyword">try</span> &#123;        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        <span class="hljs-keyword">throw</span> x;    &#125;    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;        <span class="hljs-comment">// Round up to page boundary</span>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        address = base;    &#125;    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span>    att = <span class="hljs-keyword">null</span>;&#125;</code></pre><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();                       &#125;                       System.exit(<span class="hljs-number">1</span>);                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                   &#125;               &#125;);           &#125;</code></pre><p>对应对象的run方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// Paranoia</span>        <span class="hljs-keyword">return</span>;    &#125;    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span>    address = <span class="hljs-number">0</span>;    Bits.unreserveMemory(size, capacity);&#125;</code></pre><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" srcset="/img/loading.gif" alt=""></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" srcset="/img/loading.gif" alt=""></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);&#125;&#125;</code></pre><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span>list.remove(poll);<span class="hljs-comment">//移动到引用队列中的下一个元素</span>poll = queue.poll();&#125;&#125;&#125;</code></pre><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li><p>软引用和弱引用<strong>可以配合</strong>引用队列</p><ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li><p>虚引用和终结器引用<strong>必须配合</strong>引用队列</p><ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" srcset="/img/loading.gif" alt=""></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" srcset="/img/loading.gif" alt=""></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" srcset="/img/loading.gif" alt=""></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" srcset="/img/loading.gif" alt=""></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" srcset="/img/loading.gif" alt=""></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" srcset="/img/loading.gif" alt=""></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" srcset="/img/loading.gif" alt=""></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" srcset="/img/loading.gif" alt=""></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" srcset="/img/loading.gif" alt=""></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" srcset="/img/loading.gif" alt=""></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel  Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li><p>多线程</p></li><li><p>堆内存较大，多核CPU</p></li><li><p>尽可能让单次STW时间变短（尽量不影响其他线程运行）</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" srcset="/img/loading.gif" alt=""></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p> CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" srcset="/img/loading.gif" alt=""></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" srcset="/img/loading.gif" alt=""></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" srcset="/img/loading.gif" alt=""></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园    S：幸存区    O：老年代</p><ul><li>会STW</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" srcset="/img/loading.gif" alt=""></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" srcset="/img/loading.gif" alt=""></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p> 会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx    用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" srcset="/img/loading.gif" alt=""></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>卡表与Remembered Set</p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li><p>在引用变更时通过post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads  更新 Remembered Set</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" srcset="/img/loading.gif" alt=""></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的  灰色：正在处理中的 白色：还未处理的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" srcset="/img/loading.gif" alt=""></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" srcset="/img/loading.gif" alt=""></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" srcset="/img/loading.gif" alt=""></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><pre><code class="hljs taggerscript">"F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\j</span>ava" -XX:+PrintFlagsFinal -version | findstr "GC"</code></pre><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li><p>内存</p></li><li><p>锁竞争</p></li><li><p>CPU占用</p></li><li><p>IO</p></li><li><p>GC</p></li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li><p>CMS G1 ZGC</p></li><li><p>ParallelGC</p></li><li><p>Zing</p></li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题 </p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li><p>新生代内存越大越好么？</p><ul><li><p>不是</p><ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li><p>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</p></li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:...\XXX.java</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" srcset="/img/loading.gif" alt=""></p><p>以下是字节码文件</p><pre><code class="hljs angelscript"><span class="hljs-number">0000000</span> ca fe ba be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">23</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">09</span> <span class="hljs-number">0000020</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">17</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">18</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>a <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">07</span> <span class="hljs-number">0000040</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>c <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">3</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <span class="hljs-number">0000060</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">43</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">4</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">65</span> <span class="hljs-number">4</span>e <span class="hljs-number">0000100</span> <span class="hljs-number">75</span> <span class="hljs-number">6</span>d <span class="hljs-number">62</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span>c <span class="hljs-number">6f</span> <span class="hljs-number">63</span> <span class="hljs-number">0000120</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">56</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">0000140</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">4</span>c <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">63</span> <span class="hljs-number">0000160</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">0000200</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">0000220</span> <span class="hljs-number">28</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">0000240</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">0000260</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">0000300</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">50</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <span class="hljs-number">0000320</span> <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">53</span> <span class="hljs-number">6f</span> <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">46</span> <span class="hljs-number">0000340</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span><span class="hljs-number">0000360</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">1</span>e <span class="hljs-number">0000400</span> <span class="hljs-number">00</span> <span class="hljs-number">1f</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">0000420</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">22</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">0000440</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">0000460</span> <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">0000500</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">4f</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>a <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0000520</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">79</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>d <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">6f</span> <span class="hljs-number">0000540</span> <span class="hljs-number">75</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">0000560</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">0000600</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">0000620</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">70</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">0000640</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">0000660</span> <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">0000700</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">0000720</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">2</span>a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">0000740</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0000760</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">0001000</span> <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0001020</span> <span class="hljs-number">09</span> b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">0001040</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">0001060</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0001100</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">00</span> <span class="hljs-number">0001120</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">14</span></code></pre><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><pre><code class="hljs properties"><span class="hljs-attr">u4</span>  <span class="hljs-string">magic</span><span class="hljs-attr">u2</span> <span class="hljs-string">            minor_version;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            major_version;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            constant_pool_count;    </span><span class="hljs-attr">cp_info</span> <span class="hljs-string">       constant_pool[constant_pool_count-1];    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            access_flags;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            this_class;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            super_class;   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            interfaces_count;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            interfaces[interfaces_count];   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            fields_count;    </span><span class="hljs-attr">field_info</span> <span class="hljs-string">    fields[fields_count];   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            methods_count;    </span><span class="hljs-attr">method_info</span> <span class="hljs-string">   methods[methods_count];    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            attributes_count;    </span><span class="hljs-attr">attribute_info</span> <span class="hljs-string">attributes[attributes_count];</span></code></pre><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic </p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2             minor_version;    </p><p>u2             major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09 </p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考 </p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><pre><code class="hljs taggerscript">javap -v F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.class</code></pre><pre><code class="hljs lasso">F:\Thread_study&gt;javap <span class="hljs-params">-v</span> F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified <span class="hljs-number">2020</span><span class="hljs-number">-6</span><span class="hljs-number">-6</span>; size <span class="hljs-number">434</span> <span class="hljs-built_in">bytes</span>  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from <span class="hljs-string">"Demo1.java"</span><span class="hljs-keyword">public</span> class com.nyima.JVM.day5.Demo1  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         <span class="hljs-comment">// java/lang/Object."&lt;init&gt;":()V</span>   #2 = Fieldref           #16.#17        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #3 = <span class="hljs-built_in">String</span>             #18            <span class="hljs-comment">// hello world</span>   #4 = Methodref          #19.#20        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span>   #5 = Class              #21            <span class="hljs-comment">// com/nyima/JVM/day5/Demo1</span>   #6 = Class              #22            <span class="hljs-comment">// java/lang/Object</span>   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          <span class="hljs-comment">// "&lt;init&gt;":()V</span>  #16 = Class              #23            <span class="hljs-comment">// java/lang/System</span>  #17 = NameAndType        #24:#25        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #18 = Utf8               hello world  #19 = Class              #26            <span class="hljs-comment">// java/io/PrintStream</span>  #20 = NameAndType        #27:#28        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span>  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/<span class="hljs-built_in">String</span>;)V&#123;  <span class="hljs-keyword">public</span> com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #1                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>  <span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(java.lang.<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span>);    descriptor: (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: getstatic     #2                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">3</span>: ldc           #3                  <span class="hljs-comment">// String hello world</span>         <span class="hljs-number">5</span>: invokevirtual #4                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span>&#125;</code></pre><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> c = a + b;        System.out.println(c);       &#125; &#125;</code></pre><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" srcset="/img/loading.gif" alt=""></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" srcset="/img/loading.gif" alt=""></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong> </p><ul><li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4 个字节），类似的指令还有 <ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈 </li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的 </p><pre><code class="hljs java">a = <span class="hljs-number">10</span></code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" srcset="/img/loading.gif" alt=""></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" srcset="/img/loading.gif" alt=""></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" srcset="/img/loading.gif" alt=""></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" srcset="/img/loading.gif" alt=""></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" srcset="/img/loading.gif" alt=""></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" srcset="/img/loading.gif" alt=""></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法 </p><p>生成新的栈帧（分配 locals、stack等） </p><p>传递参数，执行新栈帧中的字节码</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" srcset="/img/loading.gif" alt=""></p><p>执行完毕，弹出栈帧 </p><p>清除 main 操作数栈内容</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" srcset="/img/loading.gif" alt=""></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;x = x++;i++;&#125;System.out.println(x); <span class="hljs-comment">//接过为0</span>&#125;&#125;</code></pre><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>        <span class="hljs-number">0</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">1</span>: istore_1<span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>        <span class="hljs-number">2</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">3</span>: istore_2<span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0</span>        <span class="hljs-number">4</span>: iload_1<span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span><span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>       <span class="hljs-number">10</span>: iload_2<span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>       <span class="hljs-number">14</span>: istore_2<span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">24</span>: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">30</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(i); <span class="hljs-comment">//结果为30</span>&#125;&#125;</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><pre><code class="hljs angelscript">stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>         <span class="hljs-number">7</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">10</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">12</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-keyword">private</span> String a = <span class="hljs-string">"s1"</span>;&#123;b = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;&#123;a = <span class="hljs-string">"s2"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">this</span>.a = a;<span class="hljs-keyword">this</span>.b = b;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">"s3"</span>, <span class="hljs-number">30</span>);System.out.println(d.a);System.out.println(d.b);&#125;&#125;</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>        <span class="hljs-number">0</span>: aload_0        <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>        <span class="hljs-number">4</span>: aload_0        <span class="hljs-number">5</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String s1</span>        <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-number">10</span>: aload_0       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">16</span>: aload_0       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>       <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">22</span>: aload_0       <span class="hljs-number">23</span>: ldc           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// String s2</span>       <span class="hljs-number">25</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-comment">//原始构造方法在最后执行</span>       <span class="hljs-number">28</span>: aload_0       <span class="hljs-number">29</span>: aload_1       <span class="hljs-number">30</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-number">33</span>: aload_0       <span class="hljs-number">34</span>: iload_2       <span class="hljs-number">35</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span></code></pre><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();demo5.test1();demo5.test2();demo5.test3();Demo5.test4();&#125;&#125;</code></pre><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><pre><code class="hljs angelscript">Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: new           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day5/Demo5 </span>         <span class="hljs-number">3</span>: dup         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method "&lt;init&gt;":()V</span>         <span class="hljs-number">7</span>: astore_1         <span class="hljs-number">8</span>: aload_1         <span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method test1:()V</span>        <span class="hljs-number">12</span>: aload_1        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method test2:()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method test3:()V</span>        <span class="hljs-number">20</span>: invokestatic  #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method test4:()V</span>        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈 </li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量 </li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定 </li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 </li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;i = <span class="hljs-number">20</span>;&#125;&#125;&#125;</code></pre><p>对应字节码指令</p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//多出来一个异常表</span>     Exception table:        <span class="hljs-keyword">from</span>    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception</code></pre><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号 </li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;i = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;i = <span class="hljs-number">30</span>;&#125;&#125;&#125;</code></pre><p>对应的字节码</p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span>       <span class="hljs-number">15</span>: astore_2       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">18</span>: istore_1       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span>     Exception table:        <span class="hljs-keyword">from</span>    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception</code></pre><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;i = <span class="hljs-number">20</span>;&#125; <span class="hljs-keyword">finally</span> &#123;i = <span class="hljs-number">30</span>;&#125;&#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-comment">//try块</span>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-comment">//try块执行完后，会执行finally    </span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">7</span>: istore_1        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//catch块     </span>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">//异常信息放入局部变量表的2号槽位</span>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">14</span>: istore_1       <span class="hljs-comment">//catch块执行完后，会执行finally        </span>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">17</span>: istore_1       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span>       <span class="hljs-number">21</span>: astore_3       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">24</span>: istore_1       <span class="hljs-number">25</span>: aload_3       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">//抛出异常</span>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any</code></pre><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程 </p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = Demo3.test();        <span class="hljs-comment">//结果为20</span>System.out.println(i);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> i;&#125; <span class="hljs-keyword">finally</span> &#123;i = <span class="hljs-number">20</span>;<span class="hljs-keyword">return</span> i;&#125;&#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0        <span class="hljs-number">3</span>: iload_0        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0        <span class="hljs-number">8</span>: iload_0        <span class="hljs-number">9</span>: ireturn<span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span>       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: iload_0       <span class="hljs-number">15</span>: ireturn<span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span>     Exception table:        from    to  target type            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准 </li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子 </li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> i = Demo3.test();      <span class="hljs-comment">//最终结果为20</span>      System.out.println(i);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">try</span> &#123;         i = <span class="hljs-number">10</span>;         <span class="hljs-comment">//这里应该会抛出异常</span>         i = i/<span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span> i;      &#125; <span class="hljs-keyword">finally</span> &#123;         i = <span class="hljs-number">20</span>;         <span class="hljs-keyword">return</span> i;      &#125;   &#125;&#125;</code></pre><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = Demo4.test();System.out.println(i);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> i;&#125; <span class="hljs-keyword">finally</span> &#123;i = <span class="hljs-number">20</span>;&#125;&#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">//赋值给i 10</span>        <span class="hljs-number">3</span>: iload_0<span class="hljs-comment">//加载到操作数栈顶</span>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">//加载到局部变量表的1号位置</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">//赋值给i 20</span>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">//加载局部变量表1号位置的数10到操作数栈</span>        <span class="hljs-number">9</span>: ireturn <span class="hljs-comment">//返回操作数栈顶元素 10</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: aload_2 <span class="hljs-comment">//加载异常</span>       <span class="hljs-number">15</span>: athrow <span class="hljs-comment">//抛出异常</span>     Exception table:        from    to  target type            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;Lock lock = <span class="hljs-keyword">new</span> Lock();<span class="hljs-keyword">synchronized</span> (lock) &#123;System.out.println(i);&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span>        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock."&lt;init&gt;":()V       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span>       <span class="hljs-comment">//锁住后代码块中的操作    </span>       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">18</span>: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span>       <span class="hljs-number">22</span>: aload_3           <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span>       <span class="hljs-comment">//异常操作    </span>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>       <span class="hljs-number">29</span>: aload_3       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span>       <span class="hljs-number">33</span>: athrow       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span>     Exception table:        from    to  target type           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any</code></pre><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 <em>.class 字节码的过程中，</em></em>自动生成<strong>和</strong>转换**的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。 </p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;&#125;</code></pre><p>经过编译期优化后</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V</span>      <span class="hljs-keyword">super</span>();   &#125;&#125;</code></pre><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Integer x = <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> y = x;   &#125;&#125;</code></pre><p>转换过程如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span>      <span class="hljs-keyword">int</span> y = x.intValue();   &#125;&#125;</code></pre><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      list.add(<span class="hljs-number">10</span>);      Integer x = list.get(<span class="hljs-number">0</span>);   &#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>       0: new           #2                  // class java/util/ArrayList       <span class="hljs-number">3</span>: dup       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V       <span class="hljs-number">7</span>: astore_1       <span class="hljs-number">8</span>: aload_1       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      <span class="hljs-number">19</span>: pop      <span class="hljs-number">20</span>: aload_1      <span class="hljs-number">21</span>: iconst_0      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span>      27: checkcast     #7                  // class java/lang/Integer      <span class="hljs-number">30</span>: astore_2      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span></code></pre><p>所以调用get函数取值时，有一个类型转换的操作</p><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);</code></pre><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();</code></pre><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span>      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>);   &#125;&#125;</code></pre><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>&#125;);   &#125;&#125;</code></pre><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;System.out.println(x);&#125;&#125;&#125;</code></pre><p>编译器会帮我们转换为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;<span class="hljs-keyword">int</span> x = arr[i];System.out.println(x);&#125;&#125;&#125;</code></pre><p><strong>如果是集合使用foreach</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-keyword">for</span> (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;</code></pre><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-comment">//获得该集合的迭代器</span>      Iterator&lt;Integer&gt; iterator = list.iterator();      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;</code></pre><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">"hello"</span>;      <span class="hljs-keyword">switch</span> (str) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-string">"hello"</span> :            System.out.println(<span class="hljs-string">"h"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-string">"world"</span> :            System.out.println(<span class="hljs-string">"w"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre><p>在编译器中执行的操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;         &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">"hello"</span>;      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;         <span class="hljs-comment">//hello的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">"hello"</span>)) &#123;               x = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-comment">//world的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">"world"</span>)) &#123;               x = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">//用第二个switch在进行输出判断</span>      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            System.out.println(<span class="hljs-string">"h"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">"w"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-keyword">switch</span> (sex) &#123;         <span class="hljs-keyword">case</span> MALE:            System.out.println(<span class="hljs-string">"man"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> FEMALE:            System.out.println(<span class="hljs-string">"woman"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</code></pre><p>编译器中执行的代码如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-comment">/**     </span><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];      <span class="hljs-keyword">static</span> &#123;         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">"man"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            System.out.println(<span class="hljs-string">"woman"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</code></pre><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><pre><code class="hljs java"><span class="hljs-keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</code></pre><p>转换后的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;      <span class="hljs-comment">//对应枚举类中的元素</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;       <span class="hljs-keyword">static</span> &#123;           <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span>    MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">"MALE"</span>, <span class="hljs-number">0</span>);            FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">"FEMALE"</span>, <span class="hljs-number">1</span>);           $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;    &#125;    <span class="hljs-comment">//调用父类中的方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;             <span class="hljs-keyword">super</span>(name, ordinal);        &#125;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;          <span class="hljs-keyword">return</span> $VALUES.clone();      &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123;         <span class="hljs-keyword">return</span> Enum.valueOf(Sex<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)</span>;      &#125;    &#125;</code></pre><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">"running..."</span>);         &#125;      &#125;;   &#125;&#125;</code></pre><p>转换后的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();   &#125;&#125;<span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"running..."</span>);   &#125;&#125;</code></pre><p>如果匿名内部类中引用了<strong>局部变量</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;</code></pre><p>转化后代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-comment">//多创建了一个变量</span>   <span class="hljs-keyword">int</span> val$x;   <span class="hljs-comment">//变为了有参构造器</span>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;      <span class="hljs-keyword">this</span>.val$x = x;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(val$x);   &#125;&#125;</code></pre><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有： <ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 </li><li>_super 即父类</li><li>_ﬁelds 即成员变量 </li><li>_methods 即方法 </li><li>_constants 即常量池 </li><li>_class_loader 即类加载器 </li><li>_vtable 虚方法表 </li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载，<strong>先加载父类</strong> </li><li>加载和链接可能是<strong>交替运行</strong>的</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" srcset="/img/loading.gif" alt=""></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong> </li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span></code></pre><ul><li>打开HSDB</li></ul><pre><code class="hljs crystal">java -cp <span class="hljs-symbol">F:</span>\JAVA\JDK8.<span class="hljs-number">0</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">sa</span>-<span class="hljs-title">jdi</span>.<span class="hljs-title">jar</span> <span class="hljs-title">sun</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">hotspot</span>.<span class="hljs-title">HSDB</span></span></code></pre><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" srcset="/img/loading.gif" alt=""></p><ul><li>定位需要的进程</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" srcset="/img/loading.gif" alt=""></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;      ClassLoader loader = Demo1<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;      <span class="hljs-comment">//只加载不解析</span>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">"com.nyima.JVM.day8.C"</span>);      <span class="hljs-comment">//用于阻塞主线程</span>      System.in.read();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;   D d = <span class="hljs-keyword">new</span> D();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;</code></pre><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" srcset="/img/loading.gif" alt=""></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" srcset="/img/loading.gif" alt=""></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" srcset="/img/loading.gif" alt=""></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化 </li><li>首次访问这个类的静态变量或静态方法时 </li><li>子类初始化，如果父类还没初始化，会引发 </li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName </li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span>        Class&lt;?&gt; c = findLoadedClass(name);        <span class="hljs-comment">//如果没有被加载过</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">long</span> t0 = System.nanoTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//看是否被启动类加载器加载过</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                <span class="hljs-comment">// from the non-null parent class loader</span>                <span class="hljs-comment">//捕获异常，但不做任何处理</span>            &#125;            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();                c = findClass(name);                <span class="hljs-comment">// 记录时间</span>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        <span class="hljs-keyword">if</span> (resolve) &#123;            resolveClass(c);        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件 </li><li>通过接口来使用实现，希望解耦时，常用在框架设计 </li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法 <ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类 </li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代</p><ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</p><ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的</p><ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling） </li><li>2层：使用  C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 </li><li>是将字节码解释为针对所有平台都通用的机器码 </li></ul></li><li>即时编译器 <ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译 </li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-comment">// to do something  </span>&#125;</code></pre><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong> </p><p> 如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; <span class="hljs-comment">//这里调用了add2方法</span>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;          <span class="hljs-keyword">return</span> x1 + x2;      &#125;</code></pre><p>方法调用被替换后</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;      <span class="hljs-comment">//被替换为了方法本身</span>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;      &#125;</code></pre><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"foo..."</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;      Method foo = Demo3.class.getMethod("foo");      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;         foo.invoke(<span class="hljs-keyword">null</span>);      &#125;   &#125;&#125;</code></pre><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><span class="hljs-function">       InvocationTargetException</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (!override) &#123;        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        &#125;    &#125;    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;        ma = acquireMethodAccessor();    &#125;    <span class="hljs-keyword">return</span> ma.invoke(obj, args);&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" srcset="/img/loading.gif" alt=""></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> NativeMethodAccessorImpl extends MethodAccessorImpl &#123;    <span class="hljs-keyword">private</span> final Method <span class="hljs-keyword">method</span>;    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> numInvocations;    <span class="hljs-constructor">NativeMethodAccessorImpl(Method <span class="hljs-params">var1</span>)</span> &#123;        this.<span class="hljs-keyword">method</span> = var1;    &#125;<span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span>    public Object invoke(Object var1, Object<span class="hljs-literal">[]</span> var2) throws IllegalArgumentException, InvocationTargetException &#123;        <span class="hljs-keyword">if</span> (++this.numInvocations &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectionFactory</span>.</span></span>inflation<span class="hljs-constructor">Threshold()</span><span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectUtil</span>.</span></span>is<span class="hljs-constructor">VMAnonymousClass(<span class="hljs-params">this</span>.<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>)) &#123;            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MethodAccessorGenerator()</span>).generate<span class="hljs-constructor">Method(<span class="hljs-params">this</span>.<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Name()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ParameterTypes()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ReturnType()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ExceptionTypes()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Modifiers()</span>);            this.parent.set<span class="hljs-constructor">Delegate(<span class="hljs-params">var3</span>)</span>;        &#125;        return invoke0(this.<span class="hljs-keyword">method</span>, var1, var2);    &#125;    void set<span class="hljs-constructor">Parent(DelegatingMethodAccessorImpl <span class="hljs-params">var1</span>)</span> &#123;        this.parent = var1;    &#125;    <span class="hljs-keyword">private</span> static native Object invoke0(Method var0, Object var1, Object<span class="hljs-literal">[]</span> var2);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;</code></pre><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" srcset="/img/loading.gif" alt=""></p><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>内存模型内容详见 <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98">JAVA并发 第四章</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java数据结构与算法</title>
    <link href="/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java数据结构与算法"><a href="#Java数据结构与算法" class="headerlink" title="Java数据结构与算法"></a>Java数据结构与算法</h1><p>该博客是根据<a href="https://www.bilibili.com/video/BV1B4411H76f?from=search&seid=14863448557523728830" target="_blank" rel="noopener">Java -韩顺平 图解Java 数据结构 和 算法-尚硅谷</a>学习时，所做的笔记</p><h1 id="一、稀疏数组和队列"><a href="#一、稀疏数组和队列" class="headerlink" title="一、稀疏数组和队列"></a>一、稀疏数组和队列</h1><h2 id="1、稀疏数组"><a href="#1、稀疏数组" class="headerlink" title="1、稀疏数组"></a>1、稀疏数组</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用<strong>稀疏数组</strong>来保存该数组。</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><ul><li>记录数组<strong>一共有几行几列</strong>，有多少个<strong>不同的值</strong></li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200610224442.png" srcset="/img/loading.gif" alt=""></p><p>如图，把一个6X7的二维数组变为了一个9X3的稀疏数组。其中</p><ul><li>第一行保存的是原二维数组的行、列以及非0值的个数</li><li>第二到九行保存的是每个非0值所在的位置及其数值</li></ul><h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><p>二维数组转稀疏数组</p><ul><li>遍历二维数组，得到二维数组中有效值的个数sum</li><li>创建稀疏数组，有sum+1行，3列（固定）</li><li>将二维数组中的有效值存入稀疏数组中</li></ul><p>稀疏数组转二维数组</p><ul><li>先读取稀疏数组的第一行（保存二维数组的行列信息），还原二维数组</li><li>读取稀疏数组的其他行，将值赋给二维数组的对应位置上的数</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建一个二维数组</span>      <span class="hljs-keyword">int</span>[][] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];      <span class="hljs-comment">//向二维数组里放值</span>      arr1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;      arr1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;      arr1[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">3</span>;      <span class="hljs-comment">//打印二维数组</span>      System.out.println(<span class="hljs-string">"遍历二维数组"</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1[<span class="hljs-number">0</span>].length; j++) &#123;            System.out.print(arr1[i][j] + <span class="hljs-string">"   "</span>);         &#125;         System.out.println();      &#125;      <span class="hljs-comment">//二位数组-----&gt;稀疏数组</span>      <span class="hljs-comment">//遍历二维数组中有效值的个数,用sum来记录</span>      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (arr1[i][j] != <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//二维数组中元素不为0即为有效值</span>               sum++;            &#125;         &#125;      &#125;      <span class="hljs-comment">//创建稀疏数组</span>      <span class="hljs-comment">//行数为sum+1，第一行用于保存二维数组的行列及有效值个数，列数固定为3</span>      <span class="hljs-keyword">int</span>[][] sparseArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];      <span class="hljs-comment">//存入二维数组的行列及有效值个数</span>      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = arr1.length;      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = arr1[<span class="hljs-number">0</span>].length;      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;      <span class="hljs-comment">//再次遍历二维数组，将有效值存入稀疏数组</span>      <span class="hljs-comment">//用于保存稀疏数组的行数</span>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (arr1[i][j] != <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//将值存入稀疏数组</span>               sparseArr[count][<span class="hljs-number">0</span>] = i;               sparseArr[count][<span class="hljs-number">1</span>] = j;               sparseArr[count][<span class="hljs-number">2</span>] = arr1[i][j];               count++;            &#125;         &#125;      &#125;      <span class="hljs-comment">//打印稀疏数组</span>      System.out.println(<span class="hljs-string">"遍历稀疏数组"</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sparseArr.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sparseArr[<span class="hljs-number">0</span>].length; j++) &#123;            System.out.print(sparseArr[i][j] + <span class="hljs-string">"   "</span>);         &#125;         System.out.println();      &#125;      <span class="hljs-comment">//稀疏数组------&gt;二维数组</span>      <span class="hljs-comment">//先得到二位数组的行列数</span>      <span class="hljs-keyword">int</span> row = sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];      <span class="hljs-keyword">int</span> col = sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];      <span class="hljs-keyword">int</span>[][] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row][col];      <span class="hljs-comment">//遍历稀疏数组，同时给二维数组赋值</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; sparseArr.length; i++) &#123;         row = sparseArr[i][<span class="hljs-number">0</span>];         col = sparseArr[i][<span class="hljs-number">1</span>];         <span class="hljs-comment">//该位置上对应的值</span>         <span class="hljs-keyword">int</span> val = sparseArr[i][<span class="hljs-number">2</span>];         arr2[row][col] = val;      &#125;      <span class="hljs-comment">//打印二维数组</span>      System.out.println(<span class="hljs-string">"遍历还原后的二维数组"</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr2.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr2[<span class="hljs-number">0</span>].length; j++) &#123;            System.out.print(arr2[i][j] + <span class="hljs-string">"   "</span>);         &#125;         System.out.println();      &#125;   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">遍历二维数组<span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">2</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   遍历稀疏数组<span class="hljs-number">11</span>   <span class="hljs-number">11</span>   <span class="hljs-number">3</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span>   <span class="hljs-number">4</span>   <span class="hljs-number">3</span>   遍历还原后的二维数组<span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">2</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span></code></pre><h2 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li></ul><h3 id="模拟思路"><a href="#模拟思路" class="headerlink" title="模拟思路"></a>模拟思路</h3><ul><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量</p></li><li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614170043.png" srcset="/img/loading.gif" alt=""></p><h4 id="入队出队操作模拟"><a href="#入队出队操作模拟" class="headerlink" title="入队出队操作模拟"></a>入队出队操作模拟</h4><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：</p><ul><li><p>将尾指针往后移：rear+1 , 当 <strong>front == rear</strong> 时，队列为空</p></li><li><p>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。<strong>rear == maxSize - 1</strong>时，队列满</p></li></ul><p><strong>注意</strong>：front指向的是队列首元素的<strong>前一个位置</strong></p><p><strong>实现代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ArrayQueue queue = <span class="hljs-keyword">new</span> ArrayQueue(<span class="hljs-number">5</span>);      queue.addNum(<span class="hljs-number">1</span>);      queue.addNum(<span class="hljs-number">2</span>);      queue.addNum(<span class="hljs-number">3</span>);      queue.addNum(<span class="hljs-number">4</span>);      queue.addNum(<span class="hljs-number">5</span>);      System.out.println(queue.getNum());      queue.showQueue();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;   <span class="hljs-comment">//队列的大小</span>   <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-comment">//用数组来实现队列</span>   <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-comment">//指向队列首元素的前一个位置</span>   <span class="hljs-keyword">int</span> front;   <span class="hljs-comment">//指向队列的尾元素</span>   <span class="hljs-keyword">int</span> rear;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;      <span class="hljs-keyword">this</span>.maxSize = maxSize;      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];      <span class="hljs-comment">//front指向队列首元素的前一个位置</span>      front = -<span class="hljs-number">1</span>;      rear = -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> rear == maxSize - <span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> front == rear;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isFull()) &#123;         System.out.println(<span class="hljs-string">"队列已满，无法在进行入队操作"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//队尾标记后移，指向要放入的元素的位置</span>      rear++;      arr[rear] = num;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法出队"</span>);      &#125;      <span class="hljs-comment">//队首标记后移，指向队首元素</span>      System.out.print(<span class="hljs-string">"出队元素是："</span>);      front++;      <span class="hljs-keyword">return</span> arr[front];   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQueue</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法遍历"</span>);      &#125;      System.out.println(<span class="hljs-string">"遍历队列"</span>);      <span class="hljs-comment">//从front+1开始读取元素</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start = front+<span class="hljs-number">1</span>; start&lt;=rear; start++) &#123;         System.out.println(arr[start]);      &#125;   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">出队元素是：<span class="hljs-number">1</span>遍历队列<span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span></code></pre><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>思路：</p><ul><li>front变量指向<strong>队首元素</strong>，初值为0</li><li>rear变量指向队尾元素的<strong>下一个元素</strong>，初值为0。规定空出一个位置</li><li>队列为空的判定条件：front == rear</li><li>队列为满的判定条件：(rear + 1) % maxSize == front</li><li>队列中有效元素的个数：(rear - front + maxSize) % maxSize</li><li>入队和出队时，都需要让标记<strong>对maxSize取模</strong></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ArrayAroundQueue aroundQueue = <span class="hljs-keyword">new</span> ArrayAroundQueue(<span class="hljs-number">5</span>);      aroundQueue.addNum(<span class="hljs-number">1</span>);      aroundQueue.addNum(<span class="hljs-number">2</span>);      aroundQueue.addNum(<span class="hljs-number">3</span>);      aroundQueue.addNum(<span class="hljs-number">4</span>);      aroundQueue.showQueue();      System.out.println(aroundQueue.getNum());      System.out.println(aroundQueue.getNum());      aroundQueue.addNum(<span class="hljs-number">5</span>);      aroundQueue.addNum(<span class="hljs-number">6</span>);      aroundQueue.showQueue();      aroundQueue.getHead();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayAroundQueue</span> </span>&#123;   <span class="hljs-comment">//队列的大小</span>   <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-comment">//用数组来实现队列</span>   <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-comment">//指向队列首元素的前一个位置</span>   <span class="hljs-keyword">int</span> front;   <span class="hljs-comment">//指向队列的尾元素</span>   <span class="hljs-keyword">int</span> rear;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayAroundQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;      <span class="hljs-keyword">this</span>.maxSize = maxSize;      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];      <span class="hljs-comment">//front指向队列首元素的前一个位置</span>      front = <span class="hljs-number">0</span>;      rear = <span class="hljs-number">0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> (rear+<span class="hljs-number">1</span>)%maxSize == front;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> front == rear;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isFull()) &#123;         System.out.println(<span class="hljs-string">"队列已满，无法在进行入队操作"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//先放入元素，在后移队尾标记</span>      arr[rear] = num;      rear = (rear+<span class="hljs-number">1</span>)%maxSize;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法出队"</span>);      &#125;      <span class="hljs-comment">//队首标记后移，指向队首元素</span>      System.out.print(<span class="hljs-string">"出队元素是："</span>);      <span class="hljs-keyword">int</span> num = arr[front];      front = (front+<span class="hljs-number">1</span>)%maxSize;      <span class="hljs-keyword">return</span> num;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQueue</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法遍历"</span>);      &#125;      System.out.println(<span class="hljs-string">"遍历队列"</span>);      <span class="hljs-comment">//当front + 1 == rear时停止遍历</span>      <span class="hljs-keyword">int</span> start = front;      <span class="hljs-keyword">while</span>(start != rear) &#123;         System.out.println(arr[start]);         <span class="hljs-comment">//移动到下一个元素</span>         start = (start+<span class="hljs-number">1</span>)%maxSize;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空"</span>);      &#125;      System.out.println(<span class="hljs-string">"队首元素为："</span>+arr[front]);   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java">遍历队列<span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span>出队元素是：<span class="hljs-number">1</span>出队元素是：<span class="hljs-number">2</span>遍历队列<span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span><span class="hljs-number">6</span>队首元素为：<span class="hljs-number">3</span></code></pre><h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="1、单向链表"><a href="#1、单向链表" class="headerlink" title="1、单向链表"></a>1、单向链表</h2><h3 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h3><p>链表在内存中的存储</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617221622.png" srcset="/img/loading.gif" alt=""></p><p><strong>特点</strong></p><ul><li>链表是以节点的方式来存储,<strong>是链式存储</strong></li><li>每个节点包含 data 域 和 next 域。next域用来指向下一个节点</li><li>链表的各个节点不一定是连续存储的</li><li>链表分<strong>带头节点的链表</strong>和<strong>没有头节点的链表</strong>，根据实际的需求来确定</li></ul><p>带头结点的<strong>逻辑示意图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617221632.png" srcset="/img/loading.gif" alt=""></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>创建（添加）</strong></p><ul><li>先创建一个Head头节点，表示单链表的头</li><li>后面我们每添加一个节点，就放在链表的最后</li></ul><p><strong>遍历</strong></p><ul><li>通过一个辅助变量，来遍历整个链表</li></ul><p><strong>有序插入</strong></p><ul><li>先遍历链表，找到应该插入的位置</li><li>要插入的节点的next指向插入位置的后一个节点</li><li>插入位置的前一个节点的next指向要插入节点<ul><li>插入前要判断是否在队尾插入</li></ul></li></ul><p><strong>根据某个属性节点修改值</strong></p><ul><li>先遍历节点，找到修改的位置<ul><li>如果未找到修改节点，则不修改</li></ul></li></ul><p><strong>删除某个节点</strong></p><ul><li>先遍历节点，找到要删除节点的前一个节点</li><li>进行删除操作</li></ul><p><strong>求倒数第n个节点的信息</strong></p><ul><li>遍历链表，求出链表的<strong>有效长度</strong>length（不算头结点）</li><li>遍历链表到第length-n的节点</li></ul><p><strong>翻转链表</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616112143.png" srcset="/img/loading.gif" alt=""></p><ul><li>创建一个新的头结点，作为新链表的头</li><li>从头遍历旧链表，将遍历到的节点插入新链表的头结点之后</li><li>注意需要用到<strong>两个暂存节点</strong><ul><li>一个用来保存正在遍历的节点</li><li>一个用来保存正在遍历节点的下一个节点</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142843.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142931.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142248.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142415.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617221646.png" srcset="/img/loading.gif" alt=""></p><p><strong>逆序打印</strong></p><ul><li>遍历链表，将遍历到的节点入栈</li><li>遍历完后，进行出栈操作，同时打印出栈元素</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;LinkedList linkedList = <span class="hljs-keyword">new</span> LinkedList();linkedList.traverseNode();System.out.println();<span class="hljs-comment">//创建学生节点，并插入链表</span>StudentNode student1 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>);StudentNode student3 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">3</span>, <span class="hljs-string">"Lulu"</span>);linkedList.addNode(student1);linkedList.addNode(student3);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//按id大小插入</span>System.out.println(<span class="hljs-string">"有序插入"</span>);StudentNode student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">0</span>, <span class="hljs-string">"Wenwen"</span>);linkedList.addByOrder(student2);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//按id修改学生信息</span>System.out.println(<span class="hljs-string">"修改学生信息"</span>);student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Hulu"</span>);linkedList.changeNode(student2);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//根据id删除学生信息</span>System.out.println(<span class="hljs-string">"删除学生信息"</span>);student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Hulu"</span>);linkedList.deleteNode(student2);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//获得倒数第几个节点</span>System.out.println(<span class="hljs-string">"获得倒数节点"</span>);System.out.println(linkedList.getStuByRec(<span class="hljs-number">2</span>));System.out.println();<span class="hljs-comment">//翻转链表</span>System.out.println(<span class="hljs-string">"翻转链表"</span>);LinkedList newLinkedList = linkedList.reverseList();newLinkedList.traverseNode();System.out.println();<span class="hljs-comment">//倒叙遍历链表</span>System.out.println(<span class="hljs-string">"倒序遍历链表"</span>);newLinkedList.reverseTraverse();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建链表</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;<span class="hljs-comment">//头节点，防止被修改，设置为私有的</span><span class="hljs-keyword">private</span> StudentNode head = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 要添加的节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(StudentNode node)</span> </span>&#123;<span class="hljs-comment">//因为头节点不能被修改，所以创建一个辅助节点</span>StudentNode temp = head;<span class="hljs-comment">//找到最后一个节点</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//temp是尾节点就停止循环</span><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//不是尾结点就向后移动</span>temp = temp.next;&#125;<span class="hljs-comment">//现在temp是尾节点了，再次插入</span>temp.next = node;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 遍历链表</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverseNode</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"开始遍历链表"</span>);<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);&#125;<span class="hljs-comment">//创建辅助节点</span>StudentNode temp = head.next;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//遍历完成就停止循环</span><span class="hljs-keyword">if</span>(temp == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">break</span>;&#125;System.out.println(temp);temp = temp.next;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按id顺序插入节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addByOrder</span><span class="hljs-params">(StudentNode node)</span> </span>&#123;<span class="hljs-comment">//如果没有首节点，就直接插入</span><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;head.next = node;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//辅助节点，用于找到插入位置和插入操作</span>StudentNode temp = head;<span class="hljs-comment">//节点的下一个节点存在，且它的id小于要插入节点的id，就继续下移</span><span class="hljs-keyword">while</span> (temp.next!=<span class="hljs-keyword">null</span> &amp;&amp; temp.next.id &lt; node.id) &#123;temp = temp.next;&#125;<span class="hljs-comment">//如果temp的下一个节点存在，则执行该操作</span><span class="hljs-comment">//且插入操作，顺序不能换</span><span class="hljs-keyword">if</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;node.next = temp.next;&#125;temp.next = node; &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据id来修改节点信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 修改信息的节点</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNode</span><span class="hljs-params">(StudentNode node)</span> </span>&#123;<span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空，请先加入该学生信息"</span>);<span class="hljs-keyword">return</span>;&#125;StudentNode temp = head;<span class="hljs-comment">//遍历链表，找到要修改的节点</span><span class="hljs-keyword">while</span> (temp.next!= <span class="hljs-keyword">null</span> &amp;&amp; temp.id != node.id) &#123;temp = temp.next;&#125;<span class="hljs-comment">//如果temp已经是最后一个节点，判断id是否相等</span><span class="hljs-keyword">if</span>(temp.id != node.id) &#123;System.out.println(<span class="hljs-string">"未找到该学生的信息，请先创建该学生的信息"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//修改学生信息</span>temp.name = node.name;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据id删除节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 要删除的节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(StudentNode node)</span> </span>&#123; <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);<span class="hljs-keyword">return</span>;&#125; StudentNode temp = head.next; <span class="hljs-comment">//遍历链表，找到要删除的节点</span> <span class="hljs-keyword">if</span>(temp.next!=<span class="hljs-keyword">null</span> &amp;&amp; temp.next.id!=node.id) &#123; temp = temp.next;&#125; <span class="hljs-comment">//判断最后一个节点的是否要删除的节点</span> <span class="hljs-keyword">if</span>(temp.next.id != node.id) &#123;System.out.println(<span class="hljs-string">"请先插入该学生信息"</span>);<span class="hljs-keyword">return</span>;&#125; <span class="hljs-comment">//删除该节点</span> temp.next = temp.next.next;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 得到倒数的节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 倒数第几个数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> StudentNode <span class="hljs-title">getStuByRec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空!"</span>);&#125;StudentNode temp = head.next;<span class="hljs-comment">//用户记录链表长度，因为head.next不为空，此时已经有一个节点了</span><span class="hljs-comment">//所以length初始化为1</span><span class="hljs-keyword">int</span> length = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;temp = temp.next;length++;&#125;<span class="hljs-keyword">if</span>(length &lt; index) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"链表越界"</span>);&#125;temp = head.next;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;length-index; i++) &#123;temp = temp.next;&#125;<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 翻转链表</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 反转后的链表</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> LinkedList <span class="hljs-title">reverseList</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//链表为空或者只有一个节点，无需翻转</span><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"无需翻转"</span>);&#125;LinkedList newLinkedList = <span class="hljs-keyword">new</span> LinkedList();<span class="hljs-comment">//给新链表创建新的头结点</span>newLinkedList.head = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>);<span class="hljs-comment">//用于保存正在遍历的节点</span>StudentNode temp = head.next;<span class="hljs-comment">//用于保存正在遍历节点的下一个节点</span>StudentNode nextNode = temp.next;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//插入新链表</span>temp.next = newLinkedList.head.next;newLinkedList.head.next = temp;<span class="hljs-comment">//移动到下一个节点</span>temp = nextNode;nextNode = nextNode.next;<span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//插入最后一个节点</span>temp.next = newLinkedList.head.next;newLinkedList.head.next = temp;head.next = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">return</span> newLinkedList;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseTraverse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);&#125;StudentNode temp = head.next;<span class="hljs-comment">//创建栈，用于存放遍历到的节点</span>Stack&lt;StudentNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>) &#123;stack.push(temp);temp = temp.next;&#125;<span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;System.out.println(stack.pop());&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 定义节点</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentNode</span> </span>&#123;<span class="hljs-keyword">int</span> id;String name;<span class="hljs-comment">//用于保存下一个节点的地址</span>StudentNode next;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"StudentNode&#123;"</span> +<span class="hljs-string">"id="</span> + id +<span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p>结果</p><pre><code class="hljs java">开始遍历链表链表为空开始遍历链表StudentNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'Nyima'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;有序插入开始遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'Nyima'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;修改学生信息开始遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'Hulu'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;删除学生信息开始遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;获得倒数节点StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;翻转链表开始遍历链表StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;倒序遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;</code></pre><h2 id="2、双向链表"><a href="#2、双向链表" class="headerlink" title="2、双向链表"></a>2、双向链表</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616170404.png" srcset="/img/loading.gif" alt=""></p><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>遍历</strong></p><ul><li>和单向链表的遍历相同，需要一个辅助节点来保存当前正在遍历的节点</li></ul><p><strong>添加</strong></p><ul><li>双向链表多出了一个frnot，所以在添加时，要让新增节点的front指向链表尾节点</li></ul><p><strong>修改</strong></p><ul><li>和单向链表的修改相同</li></ul><p><strong>删除</strong></p><ul><li>使用temp来保存要删除的节点</li><li>temp.pre.next指向temp.next</li><li>temp.next指向temp.pre</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      BidirectionalList bidirectionalList = <span class="hljs-keyword">new</span> BidirectionalList();      bidirectionalList.addNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>));      bidirectionalList.addNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">2</span>, <span class="hljs-string">"Lulu"</span>));      bidirectionalList.traverseNode();      System.out.println();      System.out.println(<span class="hljs-string">"修改节点信息"</span>);      bidirectionalList.changeNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">2</span>, <span class="hljs-string">"Wenwen"</span>));      bidirectionalList.traverseNode();      System.out.println();      <span class="hljs-comment">//删除节点</span>      System.out.println(<span class="hljs-string">"删除节点"</span>);      bidirectionalList.deleteNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>));      bidirectionalList.traverseNode();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalList</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PersonNode head = <span class="hljs-keyword">new</span> PersonNode(-<span class="hljs-number">1</span>, <span class="hljs-string">""</span>);   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断双向链表是否为空</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 判空结果</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> head.next == <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 添加将诶点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 要被添加的节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(PersonNode node)</span> </span>&#123;      PersonNode temp = head;      <span class="hljs-keyword">if</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;      &#125;      <span class="hljs-comment">//插入在最后一个节点的后面</span>      temp.next = node;      node.front = temp;   &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverseNode</span><span class="hljs-params">()</span> </span>&#123;       System.out.println(<span class="hljs-string">"遍历链表"</span>);      <span class="hljs-keyword">if</span> (isEmpty()) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      PersonNode temp = head.next;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>) &#123;         System.out.println(temp);         temp = temp.next;      &#125;    &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 修改节点信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 要修改的节点</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNode</span><span class="hljs-params">(PersonNode node)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      PersonNode temp = head.next;      <span class="hljs-comment">//用于判定是否做了修改</span>      <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span>(temp.id == node.id) &#123;            <span class="hljs-comment">//匹配到节点，替换节点</span>            temp.front.next = node;            node.next = temp.next;            flag = <span class="hljs-keyword">true</span>;         &#125;         temp = temp.next;      &#125;      <span class="hljs-keyword">if</span>(!flag) &#123;         System.out.println(<span class="hljs-string">"未匹配到改人信息"</span>);      &#125;    &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 要删除的节点</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(PersonNode node)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty())&#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      PersonNode temp = head.next;      <span class="hljs-comment">//查看是否删除成功</span>       <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span>(temp.id == node.id) &#123;            temp.front.next = temp.next;            temp.next = <span class="hljs-keyword">null</span>;            flag = <span class="hljs-keyword">true</span>;         &#125;         temp = temp.next;      &#125;      <span class="hljs-keyword">if</span>(!flag) &#123;         System.out.println(<span class="hljs-string">"未找到该节点"</span>);      &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNode</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   <span class="hljs-comment">//指向下一个节点</span>   PersonNode next;   <span class="hljs-comment">//指向前一个节点</span>   PersonNode front;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"PersonNode&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;</code></pre><p><strong>输出</strong></p><pre><code class="hljs routeros">遍历链表PersonNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Nyima'</span>&#125;PersonNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Lulu'</span>&#125;修改节点信息遍历链表PersonNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Nyima'</span>&#125;PersonNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Wenwen'</span>&#125;删除节点遍历链表PersonNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Wenwen'</span>&#125;</code></pre><h2 id="3、循环链表"><a href="#3、循环链表" class="headerlink" title="3、循环链表"></a>3、循环链表</h2><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>单链表的尾节点指向首节点，即可构成循环链表</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616190405.png" srcset="/img/loading.gif" alt=""></p><h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><p>N个人围成一圈，从第S个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉，求出被杀顺序</p><ul><li>例如N=6，M=5，S=1，被杀掉的顺序是：6，4，5，2，1，3</li></ul><p><strong>大致思路</strong></p><ul><li><p>遍历链表找到指定位置的节点</p></li><li><p>用一个front保存指定节点的前一个节点，方便删除</p></li><li><p>当count==time时，删除此时正在遍历的节点，放入数组中，<strong>并将count的值初始化</strong></p></li><li><p>用一个变量loopTime记录已经出圈了几个人，<strong>当其等于length时则是最后一个节点</strong>，直接放入数组并返回数即可</p></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;CircularList circularList = <span class="hljs-keyword">new</span> CircularList();AttenderNode node1 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">1</span>);AttenderNode node2 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">2</span>);AttenderNode node3 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">3</span>);AttenderNode node4 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">4</span>);circularList.addNode(node1);circularList.addNode(node2);circularList.addNode(node3);circularList.addNode(node4);System.out.println(<span class="hljs-string">"约瑟夫环"</span>);AttenderNode[] arr = circularList.killAttender(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<span class="hljs-keyword">for</span>(AttenderNode node : arr) &#123;System.out.println(node);&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularList</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AttenderNode head = <span class="hljs-keyword">new</span> AttenderNode(-<span class="hljs-number">1</span>);AttenderNode temp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(AttenderNode node)</span> </span>&#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;head.next = node;<span class="hljs-keyword">return</span>;&#125;temp = head.next;<span class="hljs-comment">//只有一个节点，还没成环</span><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;temp.next = node;node.next = head.next;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">while</span> (temp.next != head.next) &#123;temp = temp.next;&#125;<span class="hljs-comment">//temp现在为尾节点</span>temp.next = node;<span class="hljs-comment">//node现在为尾节点，将其next指向首节点</span>node.next = head.next;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getListLength</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//判断是否只有一个节点</span><span class="hljs-keyword">if</span>(head.next.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//节点个数初始为2</span><span class="hljs-keyword">int</span> length = <span class="hljs-number">2</span>;AttenderNode first = head.next;AttenderNode temp = first.next;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//循环了一轮</span><span class="hljs-keyword">if</span>(temp.next.id == first.id) &#123;<span class="hljs-keyword">return</span> length;&#125;temp = temp.next;length++;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除指定位置节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> time 次数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> start 开始节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> AttenderNode[] killAttender(<span class="hljs-keyword">int</span> time, <span class="hljs-keyword">int</span> start) &#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;temp = head.next;<span class="hljs-keyword">int</span> length = getListLength();<span class="hljs-comment">//存放退出队列的节点</span>AttenderNode[] arr = <span class="hljs-keyword">new</span> AttenderNode[length];<span class="hljs-comment">//从start开始计数</span><span class="hljs-keyword">if</span>(start &gt; length) &#123;System.out.println(<span class="hljs-string">"超出链表范围"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;AttenderNode startNode = temp;<span class="hljs-keyword">int</span> count;<span class="hljs-comment">//如果只有一个节点，直接返回</span><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;arr[<span class="hljs-number">0</span>] = temp;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">//找到开始节点位置</span><span class="hljs-keyword">for</span>(count = <span class="hljs-number">1</span>; count&lt;start; count++) &#123;startNode = startNode.next;&#125;<span class="hljs-comment">//找到start的前一个节点，方便删除操作</span>AttenderNode front = startNode.next;<span class="hljs-keyword">while</span>(front.next != startNode) &#123;front = front.next;&#125;<span class="hljs-comment">//开始选出节点出链表</span>temp = startNode;<span class="hljs-comment">//记录循环次数</span><span class="hljs-keyword">int</span> loopTime = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(count=<span class="hljs-number">1</span>; count&lt;=time; count++) &#123;<span class="hljs-keyword">if</span>(loopTime == length) &#123;<span class="hljs-comment">//放入最后一个节点</span>arr[index] = temp;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">if</span>(count == time) &#123;arr[index] = temp;front.next = temp.next;index++;loopTime++;<span class="hljs-comment">//初始化，因为在循环开始时还会+1，所以这里初始化为0</span>count = <span class="hljs-number">0</span>;&#125;temp =front.next;&#125;<span class="hljs-keyword">return</span> arr;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AttenderNode</span> </span>&#123;<span class="hljs-keyword">int</span> id;AttenderNode next;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"KillerNode&#123;"</span> +<span class="hljs-string">"id="</span> + id +<span class="hljs-string">'&#125;'</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AttenderNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">约瑟夫环KillerNode&#123;<span class="hljs-attribute">id</span>=4&#125;KillerNode&#123;<span class="hljs-attribute">id</span>=1&#125;KillerNode&#123;<span class="hljs-attribute">id</span>=2&#125;KillerNode&#123;<span class="hljs-attribute">id</span>=3&#125;</code></pre><h2 id="4、跳跃表"><a href="#4、跳跃表" class="headerlink" title="4、跳跃表"></a>4、跳跃表</h2><p>详见<a href="https://nyimac.gitee.io/2020/11/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8"><strong>Redis设计与实现——跳跃表</strong></a></p><h1 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><ul><li>栈是一个<strong>先入后出</strong>的有序列表</li><li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的<strong>同一端进行</strong>的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈底</li><li>最先放入的元素在栈底，且最后出栈。最后放入的元素在栈顶，且最先出栈</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617090532.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h2><ul><li>子程序递归调用。如JVM中的虚拟机栈</li><li>表达式转换（中缀转后缀）与求值</li><li>二叉树的遍历</li><li>图的深度优先遍历</li></ul><h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><h3 id="用数组实现"><a href="#用数组实现" class="headerlink" title="用数组实现"></a>用数组实现</h3><p><strong>思路</strong></p><ul><li>定义top表示栈顶，初始值为-1</li><li>入栈的操作，先让top++，再放入数组</li><li>出栈操作，先取出元素，在让top–</li><li>top == -1时，栈空</li><li>top == maxSize-1时，栈满</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ArrayStack stack = <span class="hljs-keyword">new</span> ArrayStack(<span class="hljs-number">5</span>);      <span class="hljs-comment">//压栈</span>      stack.push(<span class="hljs-number">1</span>);      stack.push(<span class="hljs-number">2</span>);      stack.push(<span class="hljs-number">3</span>);      stack.push(<span class="hljs-number">4</span>);      stack.push(<span class="hljs-number">5</span>);      <span class="hljs-comment">//出栈</span>      System.out.println(stack.pop());   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-keyword">int</span>[] stack;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;      <span class="hljs-keyword">this</span>.maxSize = maxSize;      stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-keyword">this</span>.maxSize];      top = -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> top == maxSize-<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isFull()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StackOverflowError(<span class="hljs-string">"栈满"</span>);      &#125;      <span class="hljs-comment">//压栈</span>      top++;      stack[top] = i;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();      &#125;      <span class="hljs-keyword">int</span> retNum = stack[top];      top--;      <span class="hljs-keyword">return</span> retNum;   &#125;&#125;</code></pre><h2 id="4、应用"><a href="#4、应用" class="headerlink" title="4、应用"></a>4、应用</h2><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p><strong>思路</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617103635.png" srcset="/img/loading.gif" alt=""></p><ul><li>准备一个索引index来帮助我们遍历表达式</li><li>如果index位置上的元素是一个数字，就直接入栈</li><li>如果index位置上的元素是一个符号<ul><li>如果符号栈为空，直接入栈</li><li>如果符号栈不为空<ul><li>index位置上的符号的优先级小于或等于栈顶符号的优先级，则弹出两个数栈中的元素和符号栈中的一个符号，并且进行计算。将运算结果放入数栈中，并将index位置上的符号压入符号栈</li><li>index位置上的符号的优先级大于符号栈栈顶符号的优先级，则将该符号压入符号栈</li></ul></li></ul></li><li>当表达式遍历完毕后，就弹出数栈中的2个数字和符号栈中的1个符号进行运算，并将运行结果入栈</li><li>最终数栈中只有一个值，这个值便是运算结果</li><li>注意：<ul><li>读取的是字符，所以存入数字前需要减去0的ASCII码</li><li>如果数字是多位数，需要一直读，读到下一位不是数字为止，然后将读到的字符进行拼接，然后一起压入数栈</li></ul></li></ul><p><strong>代码</strong></p><p>存在的问题：因为栈是用的整型数组，所以计算除法的时候，无法转化成double</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String formula = <span class="hljs-string">"12+3*15+3/3"</span>;<span class="hljs-comment">//索引，用来读取字符串中的元素</span><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//保存读取到的数字和符号</span><span class="hljs-keyword">int</span> number1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> number2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> thisChar = <span class="hljs-string">' '</span>;<span class="hljs-comment">//用于拼接数字</span>StringBuilder spliceNumber = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-comment">//数栈和符号栈</span>ArrayStack2 numberStack = <span class="hljs-keyword">new</span> ArrayStack2(<span class="hljs-number">10</span>);ArrayStack2 operationStack = <span class="hljs-keyword">new</span> ArrayStack2(<span class="hljs-number">10</span>);<span class="hljs-comment">//保存运算结果</span><span class="hljs-keyword">int</span> result;<span class="hljs-comment">//开始读取字符串中的元素</span><span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; formula.length(); index++) &#123;thisChar = formula.charAt(index);<span class="hljs-keyword">if</span> (operationStack.isOperation(thisChar)) &#123;<span class="hljs-keyword">if</span>(operationStack.comparePriority(thisChar)) &#123;operationStack.push(thisChar);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> popChar = operationStack.pop();number2 = numberStack.pop();number1 = numberStack.pop();<span class="hljs-comment">//获得运算结果</span>result = operationStack.calculation(number1, number2, popChar);operationStack.push(thisChar);numberStack.push(result);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果是数字，就一直读取</span><span class="hljs-keyword">while</span>(thisChar&gt;=<span class="hljs-string">'0'</span> &amp;&amp; thisChar&lt;=<span class="hljs-string">'9'</span>) &#123;<span class="hljs-comment">//可能该数字为多位数，所以不能只存入一位数字</span>spliceNumber.append(thisChar - <span class="hljs-string">'0'</span>);System.out.println(<span class="hljs-string">"拼接字符换 "</span> + spliceNumber);index++;<span class="hljs-comment">//如果已经读了最后一个数字了，就停下来</span><span class="hljs-keyword">if</span>(index &gt;= formula.length()) &#123;<span class="hljs-keyword">break</span>;&#125;thisChar = formula.charAt(index);&#125;<span class="hljs-keyword">int</span> number = Integer.parseInt(spliceNumber.toString());numberStack.push(number);<span class="hljs-comment">//初始化spliceNumber</span>spliceNumber = <span class="hljs-keyword">new</span> StringBuilder();index--;&#125;&#125;<span class="hljs-keyword">while</span>(!operationStack.isEmpty()) &#123;<span class="hljs-keyword">int</span> popChar = operationStack.pop();number2 = numberStack.pop();number1 = numberStack.pop();<span class="hljs-comment">//获得运算结果</span>result = operationStack.calculation(number1, number2, popChar);numberStack.push(result);&#125;System.out.println(numberStack.pop());&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack2</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxSize;<span class="hljs-keyword">int</span>[] stack;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<span class="hljs-keyword">this</span>.maxSize = maxSize;stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];top = -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> top == maxSize - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">if</span> (isFull()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StackOverflowError(<span class="hljs-string">"栈满"</span>);&#125;<span class="hljs-comment">//压栈</span>top++;stack[top] = i;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (isEmpty()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();&#125;<span class="hljs-keyword">int</span> retNum = stack[top];top--;<span class="hljs-keyword">return</span> retNum;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> thiChar : stack) &#123;System.out.println(thiChar);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断符号的优先级</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 传入运算符</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回优先级</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">if</span> (operation == <span class="hljs-string">'*'</span> || operation == <span class="hljs-string">'/'</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operation == <span class="hljs-string">'+'</span> || operation == <span class="hljs-string">'-'</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operation &gt;= <span class="hljs-string">'0'</span> &amp;&amp; operation &lt;= <span class="hljs-string">'9'</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 比较栈顶元素和传入字符的优先级大小</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 传入字符</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true则是传入字符优先级大于栈顶字符，false反之</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">comparePriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">if</span> (isEmpty()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">int</span> priority1 = getPriority(operation);  <span class="hljs-keyword">int</span> priority2 = getPriority(stack[top]);<span class="hljs-keyword">return</span> priority1 &gt; priority2;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断该位置是不是一个符号</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 该位置的符号</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 判断结果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOperation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">return</span> operation == <span class="hljs-string">'*'</span> || operation == <span class="hljs-string">'/'</span> || operation == <span class="hljs-string">'-'</span> || operation == <span class="hljs-string">'+'</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number1   第一个运算的数字</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number2   第二个运算的数字</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 运算符</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number1, <span class="hljs-keyword">int</span> number2, <span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">switch</span> (operation) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:<span class="hljs-keyword">return</span> number1+number2;<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:<span class="hljs-keyword">return</span> number1-number2;<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:<span class="hljs-keyword">return</span> number1*number2;<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<span class="hljs-keyword">return</span> number1/number2;<span class="hljs-keyword">default</span>:System.out.println(operation);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"符号读取错误！"</span>);&#125;&#125;&#125;</code></pre><p>结果</p><pre><code class="hljs angelscript"><span class="hljs-number">58</span></code></pre><h2 id="5、中缀转后缀"><a href="#5、中缀转后缀" class="headerlink" title="5、中缀转后缀"></a>5、中缀转后缀</h2><p><strong>后缀表达式</strong>运算方法</p><ul><li><p>从左向右读取表达式</p><ul><li>遇到数字就压入栈中</li><li>遇到运算符就弹出栈顶和次顶元素。用<strong>次顶元素 运算符 栈顶元素</strong>，并将运算结果压入栈中，直到栈为空，最终结果就是运算结果</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a><strong>设计</strong></h3><p><strong>中缀表达式转后缀表达式</strong></p><ul><li><strong>从左向右</strong>读取中缀表达式，并且创建<strong>栈s</strong>和<strong>队列q</strong></li><li>如果读到的元素的数字，就直接入队放入q中</li><li>如果读到的是<strong>运算符</strong>（运算符判定）<ul><li>如果s为空，则将该运算符压入s</li><li>如果s不为空<ul><li>如果该运算符为<strong>左括号</strong>，则直接压入s</li><li>如果该运算符为<strong>右括号</strong>，则将s中的元素依次出栈并入队到q中，<strong>直到遇见左括号为止</strong>（括号不放入q中）</li><li>如果该运算符的优先级<strong>高于</strong>s栈顶的运算符，则将该元素压入s</li><li>如果该运算符的优先级<strong>小于等于</strong>s栈顶的运算符，则弹出s栈顶的元素，并将其放入q中，该运算符重<strong>新判定</strong>入栈操作（运算符判定步骤）</li></ul></li></ul></li><li>如果中缀表达式已经读取完毕，则将s中的元素依次出栈，放入q中</li><li>q中的元素依次出队，该顺序即为后缀表达式</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/6/17 21:07</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-keyword">static</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-keyword">static</span> Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//中缀表达式，加上空格，方便取出</span>      String infixExpression = <span class="hljs-string">"1 + ( ( 2 + 3 ) * 4 ) - 5"</span>;      String[] expressionArr = infixExpression.split(<span class="hljs-string">" "</span>);      <span class="hljs-comment">//用来保存该运算符的类型</span>      <span class="hljs-keyword">int</span> type;      <span class="hljs-comment">//取出的字符串</span>      String element;      <span class="hljs-comment">//弹出栈的字符串</span>      String stackEle;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;expressionArr.length; i++) &#123;         element = expressionArr[i];         type = judgeOperator(element);         <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//数字，直接入队</span>            queue.add(element);         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">//左括号，直接压栈</span>            stack.push(element);         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">3</span>) &#123;            <span class="hljs-comment">//如果右括号，弹出栈顶元素，直到遇见左括号位置再停下来</span>            <span class="hljs-keyword">do</span> &#123;               stackEle = stack.pop();               <span class="hljs-keyword">if</span>(stackEle.equals(<span class="hljs-string">"("</span>)) &#123;                  <span class="hljs-keyword">break</span>;               &#125;               queue.add(stackEle);               <span class="hljs-comment">//弹出栈中的左括号</span>            &#125;<span class="hljs-keyword">while</span> (!stackEle.equals(<span class="hljs-string">"("</span>));         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;               <span class="hljs-comment">//如果栈为空，直接入栈</span>               stack.push(element);               <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> priority1 = getPriority(element);            <span class="hljs-comment">//获得栈顶元素，并判断其优先级</span>            stackEle = stack.peek();            <span class="hljs-keyword">int</span> priority2 = getPriority(stackEle);            <span class="hljs-keyword">if</span>(priority2 == <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//为左括号，运算符直接入栈</span>               stack.push(element);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(priority1 &gt; priority2) &#123;               <span class="hljs-comment">//该运算符优先级高于栈顶元素优先级，则入栈</span>               stack.push(element);            &#125;<span class="hljs-keyword">else</span> &#123;               stackEle = stack.pop();               queue.add(stackEle);               <span class="hljs-comment">//重新判断该运算符</span>               i--;            &#125;         &#125;      &#125;      <span class="hljs-comment">//把最后一个元素出栈并入队</span>      stackEle = stack.pop();      queue.add(stackEle);      <span class="hljs-comment">//保存队列长度，因为出队过程中队列的长度会被改变</span>      <span class="hljs-keyword">int</span> length = queue.size();      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         element = queue.remove();         System.out.print(element);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断该运算符是不是加减乘除</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> operation 运算符</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> true则该运算符为加减乘除</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">firstJudge</span><span class="hljs-params">(String operation)</span> </span>&#123;      <span class="hljs-keyword">return</span> operation.equals(<span class="hljs-string">"*"</span>) || operation.equals(<span class="hljs-string">"/"</span>) || operation.equals(<span class="hljs-string">"+"</span>) || operation.equals(<span class="hljs-string">"-"</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断该字符串的类型</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> operation 要判断的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 3-&gt;右括号 2-&gt;加减乘除运算符 1-&gt;左括号</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">judgeOperator</span><span class="hljs-params">(String operation)</span> </span>&#123;      <span class="hljs-keyword">if</span>(operation.equals(<span class="hljs-string">")"</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      &#125;      <span class="hljs-keyword">if</span>(firstJudge(operation)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(operation.equals(<span class="hljs-string">"("</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断运算符优先级</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> operator 要判断的运算符</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 2代表乘除，1代表加减，0代表左括号</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">(String operator)</span> </span>&#123;      <span class="hljs-keyword">if</span>(operator.equals(<span class="hljs-string">"*"</span>) || operator.equals(<span class="hljs-string">"/"</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operator.equals(<span class="hljs-string">"+"</span>) || operator.equals(<span class="hljs-string">"-"</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;   &#125;&#125;</code></pre><p>结果</p><pre><code class="hljs angelscript"><span class="hljs-number">123</span>+<span class="hljs-number">4</span>*+<span class="hljs-number">5</span>-</code></pre><h1 id="四、递归"><a href="#四、递归" class="headerlink" title="四、递归"></a>四、递归</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p> <strong>递归就是方法自己调用自己</strong>,每次调用时<strong>传入不同的变量</strong>.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。并且递归用到了<strong>虚拟机栈</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618210040.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、能解决的问题"><a href="#2、能解决的问题" class="headerlink" title="2、能解决的问题"></a>2、能解决的问题</h2><p><strong>数学问题</strong></p><ul><li>八皇后问题</li><li>汉诺塔</li><li>求阶乘</li><li>迷宫问题</li><li>球和篮子</li></ul><p><strong>各种排序算法</strong></p><h2 id="3、规则"><a href="#3、规则" class="headerlink" title="3、规则"></a>3、规则</h2><ul><li><p>方法的变量是独立的，不会相互影响的</p></li><li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据</p></li><li><p>递归<strong>必须向退出递归的条件逼近</strong>，否则就是无限递归，出现 StackOverflowError</p></li><li><p>当一个方法执行完毕，或者遇到 return，就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或</p><p> 者返回时，该方法也就执行完毕</p></li></ul><h2 id="4、迷宫问题"><a href="#4、迷宫问题" class="headerlink" title="4、迷宫问题"></a>4、迷宫问题</h2><p><strong>思路</strong></p><ul><li>用一个二维矩阵代表地图<ul><li>1代表边界</li><li>0代表未做过该地点</li><li>2代表走过且能走得通</li><li>3代表走过但走不通</li></ul></li><li>设置起点和终点以及每个地点的<strong>行走策略</strong><ul><li>行走策略指<strong>在该点所走的方向的顺序</strong>，如 右-&gt;下-&gt;左-&gt;上（调用寻找路径的方法，使用递归）</li></ul></li><li>每次行走时假设该点能够走通，然后按照策略去判断，如果所有策略判断后都走不通，则<strong>该点走不通</strong></li></ul><p><strong>图解</strong></p><p>初始地图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618223850.png" srcset="/img/loading.gif" alt=""></p><p><strong>行走路径</strong></p><p>策略：右下左上</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618224021.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//得到地图</span>      <span class="hljs-keyword">int</span> length = <span class="hljs-number">7</span>;      <span class="hljs-keyword">int</span> width = <span class="hljs-number">6</span>;      <span class="hljs-keyword">int</span>[][] map = getMap(length, width);      <span class="hljs-comment">//设置一些障碍</span>      map[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;      map[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;      <span class="hljs-comment">//打印地图</span>      System.out.println(<span class="hljs-string">"地图如下"</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;width; j++) &#123;            System.out.print(map[i][j]+<span class="hljs-string">" "</span>);         &#125;         System.out.println();      &#125;      <span class="hljs-comment">//走迷宫</span>      getWay(map, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">//行走路径</span>      System.out.println(<span class="hljs-string">"行走路径"</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;width; j++) &#123;            System.out.print(map[i][j]+<span class="hljs-string">" "</span>);         &#125;         System.out.println();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 创建地图</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> length 地图的长</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> width 地图的宽</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 创建好的地图</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getMap(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> width) &#123;      <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length][width];      <span class="hljs-comment">//先将第一行和最后一行设置为1（边界）</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;width; i++) &#123;         map[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;         map[length-<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;      &#125;      <span class="hljs-comment">//再将第一列和最后一列设置为1</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         map[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;         map[i][width-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">return</span> map;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 开始走迷宫</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> map 地图</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> i 起点横坐标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> j 七点纵坐标</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 能否走通，true能走通，false反之</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getWay</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] map, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;      <span class="hljs-keyword">int</span> length= map.length;      <span class="hljs-keyword">int</span> width = map[<span class="hljs-number">0</span>].length;      <span class="hljs-comment">//假设右下角为终点</span>      <span class="hljs-keyword">if</span>(map[length-<span class="hljs-number">2</span>][width-<span class="hljs-number">2</span>] == <span class="hljs-number">2</span>) &#123;         <span class="hljs-comment">//走通了，返回true</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span>(map[i][j] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//假设改路能走通</span>            map[i][j] = <span class="hljs-number">2</span>;            <span class="hljs-comment">//行走策略 右-&gt;下-&gt;左-&gt;上</span>            <span class="hljs-keyword">if</span>(getWay(map, i, j+<span class="hljs-number">1</span>)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getWay(map, i+<span class="hljs-number">1</span>, j)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getWay(map, i-<span class="hljs-number">1</span>, j)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getWay(map, i, j-<span class="hljs-number">1</span>)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-comment">//右下左上都走不通</span>            map[i][j] = <span class="hljs-number">3</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//改路已经被标记过了，不用再走了，直接返回false</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">地图如下<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> 行走路径<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre><h2 id="5、八皇后问题"><a href="#5、八皇后问题" class="headerlink" title="5、八皇后问题"></a>5、八皇后问题</h2><p>八皇后问题，是一个古老而著名的问题，是<strong>回溯算法</strong>的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在 8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都<strong>不能处于同一行、同一列或同一斜线上</strong>，问有多少种摆法(92)。</p><p><strong>思路</strong></p><ul><li><p>将第一个皇后放在第一行第一列</p></li><li><p>将第二个皇后放在第二行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止</p></li><li><p>将第三个皇后放在第三行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止，并<strong>以此类推</strong>，<strong>在摆放的过程中，有可能会改动前面所放的皇后的位置</strong></p></li><li><p>当得到一个正确的解时，就会回溯到上一行，由此来找出第一个皇后在第一行第一列的所有解</p></li><li><p>再将第一个皇后放到第一行第二列，并重复以上四个步骤</p></li><li><p><strong>注意</strong>：</p><ul><li>棋盘本身应该是用二维数组表示，但是因为皇后所在的行数是固定的，所以可以简化为用一个一维数组来表示。其中的值代表皇后所在的列</li><li>数组下标代表皇后所在行数，所以判断是否在同一行列斜线上时，只需要判断是否在同一列和同一斜线上即可<ul><li>是否同列判断：值是否相同</li><li>是否同一斜线：行号-行号是否等于列号-列号，且<strong>列号相减要取绝对值</strong></li></ul></li></ul></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 创建皇后所放位置的数组，数组的下标代表行号，数组中的值代表所在的列号</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span>  max = <span class="hljs-number">8</span>;   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max];   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Demo3 demo = <span class="hljs-keyword">new</span> Demo3();      <span class="hljs-comment">//放入第一个皇后，开始求后面的皇后</span>      demo.check(<span class="hljs-number">0</span>);      System.out.println(<span class="hljs-string">"一共有"</span>+sum+<span class="hljs-string">"种放法"</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 打印数组元素</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;         System.out.print(arr[i] + <span class="hljs-string">" "</span>);      &#125;      sum++;      System.out.println();   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断该位置的皇后与前面几个是否冲突</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> position 需要判断的皇后的位置</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> true代表冲突，false代表不冲突</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;position; i++) &#123;         <span class="hljs-comment">//如果两个皇后在同一列或者同一斜线，就冲突</span>         <span class="hljs-comment">//因为数组下标代表行数，所以不会存在皇后在同一行</span>         <span class="hljs-comment">//所在行数-所在行数 如果等于 所在列数-所在列数，则两个皇后在同一斜线上</span>         <span class="hljs-keyword">if</span>(arr[i] == arr[position] || (position-i) == Math.abs(arr[position]-arr[i])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 检查该皇后应放的位置</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> queen 要检查的皇后</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> queen)</span> </span>&#123;      <span class="hljs-keyword">if</span>(queen == max) &#123;         <span class="hljs-comment">//所有的皇后都放好了，打印并返回</span>         print();         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//把皇后放在每一列上，看哪些不会和之前的冲突</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;max; i++) &#123;         <span class="hljs-comment">//把第queen+1个皇后放在第i列</span>         arr[queen] = i;         <span class="hljs-keyword">if</span>(!judge(queen)) &#123;            <span class="hljs-comment">//不冲突，就去放下一个皇后</span>            check(queen+<span class="hljs-number">1</span>);         &#125;      &#125;   &#125;&#125;</code></pre><p>一共有92种放法，就不一一展示了</p><h1 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h1><h2 id="1、常见的排序算法"><a href="#1、常见的排序算法" class="headerlink" title="1、常见的排序算法"></a>1、常见的排序算法</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200619194904.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、算法的时间复杂度"><a href="#2、算法的时间复杂度" class="headerlink" title="2、算法的时间复杂度"></a>2、算法的时间复杂度</h2><h3 id="时间频度和时间复杂度"><a href="#时间频度和时间复杂度" class="headerlink" title="时间频度和时间复杂度"></a>时间频度和时间复杂度</h3><p><strong>时间频度T(n)</strong></p><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中<strong>语句的执行次数成正比例</strong>，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为T(n)。</p><p><strong>时间复杂度O(n)</strong></p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p><p>在T(n)=4n²-2n+2中，就有f(n)=n²，使得T（n)/f(n)的极限值为4，那么O(f(n))，也就是时间复杂度为O(n²)</p><ul><li><p>对于不是只有常数的时间复杂度<strong>忽略时间频度的系数、低次项常数</strong></p></li><li><p>对于只有常数的时间复杂度，将常数看为1</p></li></ul><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><h4 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h4><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i++;</code></pre><p>无论代码执行了多少行，只要没有循环等复杂的结构，时间复杂度都是O(1)</p><h4 id="对数阶O-log2n"><a href="#对数阶O-log2n" class="headerlink" title="对数阶O(log2n)"></a>对数阶O(log<sub>2</sub>n)</h4><pre><code class="hljs java"><span class="hljs-keyword">while</span>(i&lt;n) &#123;    i = i*<span class="hljs-number">2</span>;&#125;</code></pre><p>此处i并不是依次递增到n，而是每次都以倍数增长。假设循环了x次后i大于n。则2<sup>x</sup> = n，x=log<sub>2</sub>n</p><h4 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;i++;&#125;</code></pre><p>这其中，循环体中的代码会执行n+1次，时间复杂度为O(n)</p><h4 id="线性对数阶O-nlog2n"><a href="#线性对数阶O-nlog2n" class="headerlink" title="线性对数阶O(nlog2n)"></a>线性对数阶O(nlog<sub>2</sub>n)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;    j = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(j&lt;n) &#123;j = j*<span class="hljs-number">2</span>;&#125;&#125;</code></pre><p>此处外部为一个循环，循环了n次。内部也是一个循环，但内部f循环的时间复杂度是log<sub>2</sub>n</p><p>所以总体的时间复杂度为线性对数阶O(nlog<sub>2</sub>n)</p><h4 id="平方阶O-n2"><a href="#平方阶O-n2" class="headerlink" title="平方阶O(n2)"></a>平方阶O(n<sup>2</sup>)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++) &#123;<span class="hljs-comment">//循环体</span>&#125;&#125;</code></pre><h4 id="立方阶O-n3"><a href="#立方阶O-n3" class="headerlink" title="立方阶O(n3)"></a>立方阶O(n<sup>3</sup>)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k&lt;n; k++) &#123;<span class="hljs-comment">//循环体</span>&#125;&#125;&#125;</code></pre><p>可以看出平方阶、立方阶的复杂度主要是否循环嵌套了几层来决定的</p><h2 id="3、排序算法的时间复杂度"><a href="#3、排序算法的时间复杂度" class="headerlink" title="3、排序算法的时间复杂度"></a>3、排序算法的时间复杂度</h2><table><thead><tr><th>排序算法</th><th>平均时间</th><th>最差时间</th><th>稳定性</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>稳定</td><td>O(1)</td><td>n较小时好</td></tr><tr><td>交换排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(1)</td><td>n较小时好</td></tr><tr><td>选择排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(1)</td><td>n较小时好</td></tr><tr><td>插入排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>稳定</td><td>O(1)</td><td>大部分已有序时好</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>稳定</td><td>O(n)</td><td>二维数组（桶）、一维数组（桶中首元素的位置）</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(n<sup>s</sup>)(1&lt;s&lt;2)</td><td>不稳定</td><td>O(1)</td><td>s是所选分组</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(logn)</td><td>n较大时好</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(1)</td><td>n较大时好</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td><td>n较大时好</td></tr></tbody></table><h2 id="4、冒泡排序"><a href="#4、冒泡排序" class="headerlink" title="4、冒泡排序"></a>4、冒泡排序</h2><p><strong>算法步骤</strong></p><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，<strong>最后的元素会是最大的数</strong>。</p></li><li><p>针对所有的元素重复以上的步骤，<strong>除了最后一个</strong>。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li><li><p>一共进行了<strong>数组元素个数-1</strong>次大循环，且每次大循环中需要比较的元素越来越少。</p></li><li><p>优化：如果在某次大循环，发现没有发生交换，则证明已经有序。</p></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-comment">//定义一个标识，来记录这趟大循环是否发生了交换</span>         <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;         <span class="hljs-comment">//只需要比较前length-i个数</span>         <span class="hljs-comment">//每次排序会确定一个最大的元素</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;arr.length-i; j++) &#123;            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;               <span class="hljs-keyword">int</span> temp = arr[j];               arr[j] = arr[j+<span class="hljs-number">1</span>];               arr[j+<span class="hljs-number">1</span>] = temp;               <span class="hljs-comment">//发生了交换，标识改为false</span>               flag = <span class="hljs-keyword">false</span>;            &#125;         &#125;         <span class="hljs-comment">//如果这次循环没发生交换，直接停止循环</span>         <span class="hljs-keyword">if</span>(flag) &#123;            <span class="hljs-keyword">break</span>;         &#125;      &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;</code></pre><h2 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h2><p><strong>算法步骤</strong></p><ul><li><p>遍历整个数组，找到最小（大）的元素，放到数组的起始位置。</p></li><li><p>再遍历剩下的数组，找到剩下元素中的最小（大）元素，放到数组的第二个位置。</p></li><li><p>重复以上步骤，直到排序完成。</p></li><li><p>一共需要遍历数组元素个数-1次，当找到第二大（小）的元素时，可以停止。这时最后一个元素必是最大（小）元素。</p></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//从第0个元素开始比较，一共循环length-1次，最后一个无须进行排序</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length-<span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//保存最小元素的下标</span><span class="hljs-keyword">int</span> min = i;<span class="hljs-comment">//将该元素与剩下的元素比较，找出最小元素的下标</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;arr.length; j++) &#123;<span class="hljs-comment">//保存最小元素的下标</span><span class="hljs-keyword">if</span>(arr[j] &lt; arr[min]) &#123;min = j;&#125;&#125;<span class="hljs-comment">//交换元素</span><span class="hljs-comment">//如果不是arr[i]不是最小的元素，就交换</span><span class="hljs-keyword">if</span>(min != i) &#123;<span class="hljs-keyword">int</span> temp;temp = arr[i];arr[i] = arr[min];arr[min] = temp;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;System.out.println(i);&#125;&#125;&#125;</code></pre><h2 id="6、插入排序"><a href="#6、插入排序" class="headerlink" title="6、插入排序"></a>6、插入排序</h2><p><strong>算法步骤</strong></p><ul><li>将待排序序列第一个元素看做一个<strong>有序序列</strong>，把第二个元素到最后一个元素当成是<strong>未排序序列</strong>。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;;      <span class="hljs-comment">//从数组的第二个元素开始选择位置插入</span>      <span class="hljs-comment">//因为第一个元素已经放入了有序数组中</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-comment">//保存该位置上元素的值,后面移动元素可能会覆盖该位置上元素的值</span>         <span class="hljs-keyword">int</span> temp = arr[i];         <span class="hljs-comment">//变量j用于遍历前面的有序数组</span>         <span class="hljs-keyword">int</span> j = i;         <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; temp&lt;arr[j-<span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">//如果有序数组中的元素大于temp，则后移一个位置</span>            arr[j] = arr[j-<span class="hljs-number">1</span>];            j--;         &#125;         <span class="hljs-comment">//j选择所指位置就是待插入的位置</span>         <span class="hljs-keyword">if</span>(j != i) &#123;            arr[j] = temp;         &#125;      &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;</code></pre><h2 id="7、希尔排序"><a href="#7、希尔排序" class="headerlink" title="7、希尔排序"></a>7、希尔排序</h2><p><strong>回顾：插入排序存在的问题</strong></p><p>当最后一个元素为整个数组的最小元素时，需要将前面的有序数组中的每个元素都向后移一位，这样是非常花时间的。</p><p>所以有了希尔排序来帮我们将数组从无序变为整体有序再变为有序。</p><p><strong>算法步骤</strong></p><ul><li><p>选择一个增量序列t1（一般是数组长度/2），t2（一般是一个分组长度/2），……，tk，<strong>其中 ti &gt; tj</strong>, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ul><p><strong>示意图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621122846.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;      <span class="hljs-keyword">int</span> temp;      <span class="hljs-comment">//将数组分为gap组,每个组内部进行插入排序</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> gap = arr.length/<span class="hljs-number">2</span>; gap&gt;<span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;         <span class="hljs-comment">//i用来指向未排序数组的首个元素</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = gap; i&lt;arr.length; i++) &#123;            temp = arr[i];            <span class="hljs-keyword">int</span> j = i;            <span class="hljs-comment">//找到temp应该插入的位置,需要先判断数组是否越界</span>            <span class="hljs-keyword">while</span> (j-gap&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;arr[j-gap]) &#123;               arr[j] = arr[j-gap];               j -= gap;            &#125;            <span class="hljs-keyword">if</span>(j != i) &#123;               arr[j] = temp;            &#125;         &#125;      &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;</code></pre><h2 id="8、快速排序"><a href="#8、快速排序" class="headerlink" title="8、快速排序"></a>8、快速排序</h2><p><strong>算法步骤</strong></p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>&#125;;      QuickSort sort = <span class="hljs-keyword">new</span> QuickSort();      sort.quickSort(arr);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 快速排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length&lt;=<span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> left 左侧开始下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> right 右侧开始下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-comment">//如果分区元素小于等于一个，就返回</span>      <span class="hljs-keyword">if</span>(right &lt;= left) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//得到基数下标</span>      <span class="hljs-keyword">int</span> partition = partition(arr, left, right);      <span class="hljs-comment">//递归左右两个分区,因为每次是以左边的第一个数为基数，所以右边分区递归需要在partition的右侧开始</span>      quickSort(arr, left, partition);      quickSort(arr, partition+<span class="hljs-number">1</span>, right);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 返回基准下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> left 左侧开始下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> right 右侧开始下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 中间值的下标</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-comment">//以该分区最左边的数为基数</span>      <span class="hljs-keyword">int</span> pivot = arr[left];      <span class="hljs-keyword">while</span>(left &lt; right) &#123;         <span class="hljs-comment">//右边下标开始向左移动，找到小于基数的值时停止</span>         <span class="hljs-keyword">while</span>(right&gt;left &amp;&amp; arr[right] &gt;= pivot) &#123;            right--;         &#125;         <span class="hljs-comment">//交换数值，此时pivot保存了arr[left]的值，所以不会丢失</span>         arr[left] = arr[right];         <span class="hljs-comment">//左边下标开始移动，找到大于基数的值时停止</span>         <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;            left++;         &#125;         <span class="hljs-comment">//交换数值</span>         arr[right] = arr[left];         <span class="hljs-comment">//基数插入到合适的位置</span>         arr[left] = pivot;      &#125;      <span class="hljs-comment">//返回基数下标</span>      <span class="hljs-keyword">return</span> left;   &#125;&#125;</code></pre><h2 id="9、归并排序"><a href="#9、归并排序" class="headerlink" title="9、归并排序"></a>9、归并排序</h2><p><strong>算法步骤</strong></p><p>归并排序用到了<strong>分而治之</strong>的思想，其难点是<strong>治</strong></p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复上一步 直到<strong>某一指针达到序列尾</strong></li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621201843.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621201859.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621201925.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621202006.png" srcset="/img/loading.gif" alt=""></p><p><strong>此时第二个序列的指针已经到达末尾，则将第一个序列中剩下的元素全部放入和合并序列末尾</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621202124.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>&#125;;      MergeSort mergeSort = <span class="hljs-keyword">new</span> MergeSort(arr.length);      mergeSort.mergeSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr) &#123;         System.out.println(a);      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 临时数组，用于合并时用于存放元素</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">int</span>[] temp;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">()</span> </span>&#123;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;      temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 将分解的序列进行合并，合并的同时完成排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待合并的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> left 数组左边界</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> right 数组右边界</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-comment">//两个序列的分界点</span>      <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;      <span class="hljs-comment">//temp数组中插入的位置</span>      <span class="hljs-keyword">int</span> tempLeft = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> arrLeft = left;      <span class="hljs-comment">//第二个序列的首元素下标</span>      <span class="hljs-keyword">int</span> arrRight = mid+<span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span>(arrLeft&lt;=mid &amp;&amp; arrRight&lt;=right) &#123;         <span class="hljs-comment">//如果第一个序列的元素小于第二序列的元素，就将其放入temp中</span>         <span class="hljs-keyword">if</span>(arr[arrLeft] &lt;= arr[arrRight]) &#123;            temp[tempLeft] = arr[arrLeft];            arrLeft++;         &#125;<span class="hljs-keyword">else</span> &#123;            temp[tempLeft] = arr[arrRight];            arrRight++;         &#125;         tempLeft++;      &#125;      <span class="hljs-comment">//将不为空的序列中的元素依次放入temp中</span>      <span class="hljs-keyword">while</span> (arrLeft &lt;= mid) &#123;         temp[tempLeft] = arr[arrLeft];         tempLeft++;         arrLeft++;      &#125;      <span class="hljs-keyword">while</span> (arrRight &lt;= right) &#123;         temp[tempLeft] = arr[arrRight];         tempLeft++;         arrRight++;      &#125;      <span class="hljs-comment">//将临时数组中的元素放回数组arr中</span>      tempLeft = <span class="hljs-number">0</span>;      arrLeft = left;      <span class="hljs-keyword">while</span> (arrLeft &lt;= right) &#123;         arr[arrLeft] = temp[tempLeft];         arrLeft++;         tempLeft++;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span>(left &lt; right) &#123;         mergeSort(arr, left, mid);         mergeSort(arr, mid+<span class="hljs-number">1</span>, right);         merge(arr, left, right);      &#125;   &#125;&#125;</code></pre><h2 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h2><p><strong>算法步骤</strong></p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，<strong>数位较短的数前面补零</strong></li><li>从最低位开始，依次进行一次排序</li><li>从最低位排序一直到最高位（个位-&gt;十位-&gt;百位-&gt;…-&gt;最高位）排序完成以后, 数列就变成一个有序序列</li><li>需要我们获得最大数的位数<ul><li>可以通过将<strong>最大数变为String类型</strong>，再求得它的长度即可</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225309.png" srcset="/img/loading.gif" alt=""></p><p><strong>按照个位，放到对应的桶中</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225354.png" srcset="/img/loading.gif" alt=""></p><p><strong>依次取出，同一个桶中有多个元素的，先放入的先取出</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225456.png" srcset="/img/loading.gif" alt=""></p><p><strong>再按照十位，放到对应的桶中，个位数前面补0</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225609.png" srcset="/img/loading.gif" alt=""></p><p><strong>再依次取出桶中元素</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225802.png" srcset="/img/loading.gif" alt=""></p><p><strong>再按照百位，放到对应的桶中，个位数和十位数前面补0</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225742.png" srcset="/img/loading.gif" alt=""></p><p><strong>再依次取出桶中元素</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225802.png" srcset="/img/loading.gif" alt=""><strong>再按照千位，放到对应的桶中，个位数、十位数和百位数前面补0</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225900.png" srcset="/img/loading.gif" alt=""><strong>当所有的数都在0号桶时，依次取出元素，这时顺序即为排好后的顺序</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225954.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">43</span>, <span class="hljs-number">52</span>, <span class="hljs-number">1</span>, <span class="hljs-number">89</span>, <span class="hljs-number">190</span>&#125;;      CardinalitySort cardinalitySort = <span class="hljs-keyword">new</span> CardinalitySort();      cardinalitySort.sort(arr);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr) &#123;         System.out.println(a);      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardinalitySort</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 进行基数排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-comment">//创建一个二维数组，用于表示桶</span>      <span class="hljs-comment">//桶的个数固定为10个（个位是0~9），最大容量由数组的长度决定</span>      <span class="hljs-keyword">int</span> maxSize = arr.length;      <span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][maxSize];      <span class="hljs-comment">//用于记录每个桶中有多少个元素</span>      <span class="hljs-keyword">int</span>[] elementCounts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];      <span class="hljs-comment">//获得该数组中最大元素的位数</span>      <span class="hljs-keyword">int</span> maxDigits = getMaxDigits(arr);      <span class="hljs-comment">//将数组中的元素放入桶中, step是在求数组位数时，需要除以的倍数</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> time = <span class="hljs-number">1</span>, step = <span class="hljs-number">1</span>; time&lt;=maxDigits; time++, step *= <span class="hljs-number">10</span>) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;            <span class="hljs-comment">//取出所需的位数</span>            <span class="hljs-keyword">int</span> digits = arr[i] / step % <span class="hljs-number">10</span>;            <span class="hljs-comment">//放入到对应的桶中 [digits]代表桶的编号</span>            <span class="hljs-comment">//[elementCounts[digits]]代表放入该桶的位置</span>            bucket[digits][elementCounts[digits]] = arr[i];            <span class="hljs-comment">//桶中元素个数+1</span>            elementCounts[digits]++;         &#125;         <span class="hljs-comment">//将桶中的元素重新放回到数组中</span>         <span class="hljs-comment">//用于记录应该放入原数组的哪个位置</span>         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//从桶中按放入顺序依次取出元素，放入原数组</span>            <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;            <span class="hljs-comment">//桶中有元素才取出</span>            <span class="hljs-keyword">while</span> (elementCounts[i] &gt; <span class="hljs-number">0</span>) &#123;               arr[index] = bucket[i][position];               position++;               elementCounts[i]--;               index++;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 得到该数组中最大元素的位数</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待求数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 最大元素的位数</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-keyword">if</span>(arr[i] &gt; max) &#123;            max = arr[i];         &#125;      &#125;      <span class="hljs-comment">//将最大值转为字符串，它的长度就是它的位数</span>      <span class="hljs-keyword">int</span> digits = (max + <span class="hljs-string">""</span>).length();      <span class="hljs-keyword">return</span> digits;   &#125;&#125;</code></pre><h2 id="11、堆排序"><a href="#11、堆排序" class="headerlink" title="11、堆排序"></a>11、堆排序</h2><p><strong>基本介绍</strong></p><ul><li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 <strong>O(nlogn)</strong>，它也是不稳定排序</p></li><li><p>堆是具有以下性质的<strong>完全二叉树</strong>：</p><ul><li>每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong><ul><li>注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系</li></ul></li><li>每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></li></ul></li><li><p>一般升序排序采用大顶堆，降序排列使用小顶堆</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200727191935.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200727191922.png" srcset="/img/loading.gif" alt=""></p><p><strong>排序思路</strong></p><ul><li>堆是一种树结构，但是排序中会将堆进行<strong>顺序存储</strong>（变为数组结构）</li><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序</li></ul><p><strong>实现代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/7/27 16:19</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;      <span class="hljs-comment">//堆排序</span>      heapSort(arr);      System.out.println(<span class="hljs-string">"堆排序后结果"</span>);      System.out.println(Arrays.toString(arr));   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 堆排序（升序排序）</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序数组</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;         <span class="hljs-comment">//将数组调整为大顶堆，长度为未排序数组的长度</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>; j&gt;=<span class="hljs-number">0</span>; j--) &#123;            adjustHeap(arr, j, i+<span class="hljs-number">1</span>);         &#125;         <span class="hljs-comment">//调整后，数组首元素就为最大值，与为元素交换</span>         <span class="hljs-keyword">int</span> temp = arr[i];         arr[i] = arr[<span class="hljs-number">0</span>];         arr[<span class="hljs-number">0</span>] = temp;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 将无序数组进行调整，将其调整为大顶堆</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待调整的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> index 非叶子节点的索引</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> length 待调整数组的长度</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length)</span> </span>&#123;      <span class="hljs-comment">//保存非叶子节点的值，最后需要进行交换操作</span>      <span class="hljs-keyword">int</span> temp = arr[index];      <span class="hljs-comment">//进行调整操作</span>      <span class="hljs-comment">//index*2+1代表其左子树</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; i&lt;length; i = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//如果存在右子树，且右子树的值大于左子树，就让索引指向其右子树</span>         <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[i] &lt; arr[i+<span class="hljs-number">1</span>]) &#123;            i++;         &#125;         <span class="hljs-comment">//如果右子树的值大于该节点的值就交换，同时改变索引index的值</span>         <span class="hljs-keyword">if</span>(arr[i] &gt; arr[index]) &#123;            arr[index] = arr[i];            index = i;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-comment">//调整完成后，将temp放到最终调整后的位置</span>         arr[index] = temp;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">堆排序后结果[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]</code></pre><h1 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h1><h2 id="1、线性查找"><a href="#1、线性查找" class="headerlink" title="1、线性查找"></a>1、线性查找</h2><p>线性查找是一种非常简单的查找方式。查找思路是：从数组的一个元素出发，一个个地和要查找的值进行比较，如果发现有相同的元素就返回该元素的下标。反之返回-1（未找到）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>&#125;;      <span class="hljs-keyword">int</span> result = seqSearch(arr, <span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span>(result == -<span class="hljs-number">1</span>) &#123;         System.out.println(<span class="hljs-string">"数组中没有该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"该元素在数组的下标是："</span> + result);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 线性查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 查找的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 待查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 数字的索引</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-keyword">if</span>(arr[i] == num) &#123;            <span class="hljs-keyword">return</span> i;         &#125;      &#125;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;&#125;</code></pre><h2 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h2><p>进行二分查找的数组必须为<strong>有序数组</strong></p><ul><li>设置一个指向中间元素下标的变量mid，mid=(left + right)/2</li><li>让要查找的元素和数组mid下标的元素进行比较<ul><li>如果查找的元素大于arr[mid]，则left变为mid后面一个元素的下标</li><li>如果查找的元素小于arr[mid]，则right变为mid前一个元素的下标</li><li>如果查找的元素等于arr[mid]，则mid就是要查找元素所在的位置</li></ul></li><li>当left &gt; rigth时，说明元素不在该数组中</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//进行二分查找的数组必须是有序</span>      <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>&#125;;      <span class="hljs-keyword">int</span> result = binarySearch(arr, <span class="hljs-number">11</span>);      <span class="hljs-keyword">if</span>(result == -<span class="hljs-number">1</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"该元素的下标是："</span> + result);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 二分查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 要查找的有序数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 要查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 对应数字的下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = arr.length-<span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span>(left &lt;= right) &#123;         <span class="hljs-comment">//防止溢出</span>         <span class="hljs-keyword">int</span> mid = (right - left)/<span class="hljs-number">2</span> + left;         <span class="hljs-comment">//如果要查找的值大于中间位置的值，说明要查找的值在右边部分</span>         <span class="hljs-keyword">if</span>(arr[mid] &lt; num) &#123;            left = mid + <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; num) &#123;            <span class="hljs-comment">//如果要查找的值小于中间位置的值</span>            <span class="hljs-comment">//说明要查找的值在左边部分</span>            right = mid - <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//找到了该元素</span>            <span class="hljs-keyword">return</span> mid;         &#125;      &#125;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;&#125;</code></pre><p><strong>但是有可能要查找的元素有多个</strong>。这时就需要在找到一个元素后，不要立即返回，而是<strong>扫描其左边和右边的元素</strong>，将所有相同元素的下标保存到一个数组中，然后一起返回</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>&#125;;      <span class="hljs-comment">//进行二分查找的数组必须是有序</span>      Arrays.sort(arr);      List&lt;Integer&gt; result = binarySearch(arr, <span class="hljs-number">11</span>);      <span class="hljs-keyword">if</span>(result.size() == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">for</span>(Integer index : result) &#123;            System.out.println(index);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 二分查找（可以查找重复元素的下标）</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 要查找的有序数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 要查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 保存了所有该值元素所在的位置</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = arr.length-<span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> mid;      <span class="hljs-comment">//用户保存查找值下标</span>      List&lt;Integer&gt; positionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">while</span>(left &lt;= right) &#123;         mid = (left + right)/<span class="hljs-number">2</span>;         <span class="hljs-comment">//如果要查找的值大于中间位置的值，说明要查找的值在右边部分</span>         <span class="hljs-keyword">if</span>(arr[mid] &lt; num) &#123;            left = mid + <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; num) &#123;            <span class="hljs-comment">//如果要查找的值小于中间位置的值</span>            <span class="hljs-comment">//说明要查找的值在左边部分</span>            right = mid - <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//将下标存入到集合中</span>            positionList.add(mid);            <span class="hljs-comment">//用于遍历mid左边的相同元素</span>            <span class="hljs-keyword">int</span> leftIndex = mid - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(leftIndex &gt; <span class="hljs-number">0</span> &amp;&amp; arr[leftIndex] == num) &#123;               positionList.add(leftIndex);               leftIndex--;            &#125;            <span class="hljs-keyword">int</span> rightIndex = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(rightIndex &lt; right &amp;&amp; arr[rightIndex] == num) &#123;               positionList.add(rightIndex);               rightIndex++;            &#125;            <span class="hljs-keyword">return</span> positionList;         &#125;      &#125;      <span class="hljs-keyword">return</span> positionList;   &#125;&#125;</code></pre><h2 id="3、插值查找"><a href="#3、插值查找" class="headerlink" title="3、插值查找"></a>3、插值查找</h2><p>在二分查找中，如果我们 要找的元素位于数组的最前端或者最后段，这时的查找效率是很低的。所以在二分查找至上，引入了插值查找，也是一种<strong>基于有序数组</strong>的查找方式</p><p>插值查找与二分查找的区别是：插值查找使用了一种<strong>自适应</strong>算法，用这种算法来计算mid。</p><p>mid的值在两种查找算法中的求法：</p><ul><li>二分查找：mid = (left + right)/2</li><li>插值查找：<strong>mid = left + (right - left) * (num - arr[left]) / (arr[right] - arr[left])</strong><ul><li>其中num为要查找的那个值</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>&#125;;      <span class="hljs-comment">//进行二分查找的数组必须是有序</span>      Arrays.sort(arr);      List&lt;Integer&gt; result = insertSearch(arr, <span class="hljs-number">30</span>);      <span class="hljs-keyword">if</span>(result.size() == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">for</span>(Integer index : result) &#123;            System.out.println(index);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 插值查找查找（可以查找重复元素的下标）</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 要查找的有序数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 要查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 保存了所有该值元素所在的位置</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">insertSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      List&lt;Integer&gt; positionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> mid;      <span class="hljs-keyword">while</span>(left&lt;=right) &#123;         <span class="hljs-comment">//插值查找的自适应算法</span>         mid = left+(right-left)*(num-arr[left])/(arr[right]-arr[left]);         <span class="hljs-keyword">if</span>(arr[mid] &gt; num) &#123;            right = mid - <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &lt; num) &#123;            left = mid + <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//找到了该元素的位置</span>            positionList.add(mid);         &#125;         <span class="hljs-comment">//继续查找mid附近值相同的元素</span>         <span class="hljs-keyword">int</span> leftIndex = mid - <span class="hljs-number">1</span>;         <span class="hljs-keyword">while</span>(leftIndex &gt;=<span class="hljs-number">0</span> &amp;&amp; arr[leftIndex] == num) &#123;            positionList.add(leftIndex);            leftIndex++;         &#125;         <span class="hljs-keyword">int</span> rightIndex = mid + <span class="hljs-number">1</span>;         <span class="hljs-keyword">while</span> (rightIndex &lt;= right &amp;&amp; arr[rightIndex] == num) &#123;            positionList.add(rightIndex);            rightIndex++;         &#125;         <span class="hljs-keyword">return</span> positionList;      &#125;      <span class="hljs-keyword">return</span> positionList;   &#125;&#125;</code></pre><h1 id="七、哈希表"><a href="#七、哈希表" class="headerlink" title="七、哈希表"></a>七、哈希表</h1><h2 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h2><p>散列表（Hash table，也叫哈希表），是根据<strong>关键码值</strong>(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715134934.png" srcset="/img/loading.gif" alt=""></p><p>哈希表是一种将<strong>数组与链表相结合</strong>的数据结构</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建学生</span>      Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>);      Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"Lulu"</span>);      Student student6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-string">"WenWen"</span>);      HashTab hashTab = <span class="hljs-keyword">new</span> HashTab(<span class="hljs-number">5</span>);      hashTab.add(student1);      hashTab.add(student2);      hashTab.add(student6);      hashTab.traverse();      <span class="hljs-comment">//通过id查找学生信息</span>      hashTab.findStuById(<span class="hljs-number">6</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">int</span> id;    String name;   Student next;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;   <span class="hljs-keyword">private</span> Student head = <span class="hljs-keyword">new</span> Student(-<span class="hljs-number">1</span>, <span class="hljs-string">""</span>);   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 插入学生信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> student 插入学生的信息</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Student student)</span> </span>&#123;      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;         head.next = student;         <span class="hljs-keyword">return</span>;      &#125;      Student temp = head.next;      <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;      &#125;      temp.next = student;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 遍历链表</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student temp = head;      <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;         System.out.print(temp + <span class="hljs-string">" "</span>);      &#125;      <span class="hljs-comment">//换行</span>      System.out.println();   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 通过id查找学生信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 学生id</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findStuById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student temp = head;      <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;         <span class="hljs-keyword">if</span>(temp.id == id) &#123;            <span class="hljs-comment">//找到学生，打印学生信息</span>            System.out.println(<span class="hljs-string">"该学生信息："</span> + temp);            <span class="hljs-keyword">return</span>;         &#125;      &#125;      System.out.println(<span class="hljs-string">"未找到该学生信息"</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTab</span> </span>&#123;   <span class="hljs-keyword">private</span> LinkedList[] linkedLists;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashTab</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;      <span class="hljs-keyword">this</span>.size = size;      <span class="hljs-comment">//初始化散列表</span>      linkedLists = <span class="hljs-keyword">new</span> LinkedList[size];      <span class="hljs-comment">//初始化每个链表，不然会抛出空指针异常</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">this</span>.size; i++) &#123;         <span class="hljs-comment">//对每个链表进行初始化操作</span>         linkedLists[i] = <span class="hljs-keyword">new</span> LinkedList();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Student student)</span> </span>&#123;      <span class="hljs-keyword">int</span> hashId = getHash(student.id);      linkedLists[hashId].add(student);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;size; i++) &#123;         linkedLists[i].traverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findStuById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">int</span> hashId = getHash(id);      linkedLists[hashId].findStuById(id);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 散列函数，获得散列值</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 学生的id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 对应的散列值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">return</span> id % size;   &#125;&#125;</code></pre><h1 id="八、树结构"><a href="#八、树结构" class="headerlink" title="八、树结构"></a>八、树结构</h1><h2 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h2><h3 id="为什么需要树"><a href="#为什么需要树" class="headerlink" title="为什么需要树"></a>为什么需要树</h3><ul><li>数组的查找效率高，但是插入效率低。</li><li>链表的插入效率高，查找效率低。</li></ul><p>需要一种数据结构来平衡查找与插入效率，使得查找速度和插入速度都能得到提升，因此有了树这种数据结构。</p><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135230.png" srcset="/img/loading.gif" alt=""></p><h3 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h3><p>每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135439.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135455.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135512.png" srcset="/img/loading.gif" alt=""></p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>，并且结点总数= <strong>2<sup>n</sup> -1</strong> , n为层数，则我们称为满二叉树。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135734.png" srcset="/img/loading.gif" alt=""></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>或者<strong>倒数第二层</strong>，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135950.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135917.png" srcset="/img/loading.gif" alt=""></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><strong>先遍历父节点</strong>，再遍历左子节点，最后遍历右子节点</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先遍历左子节点，<strong>再遍历父节点</strong>，最后遍历右子节点</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先遍历左子节点，再遍历右子节点，最后<strong>遍历父节点</strong></p><p><strong>可以看出，前中后的区别在于父节点遍历的时机</strong></p><h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200725144409.png" srcset="/img/loading.gif" alt=""></p><p><strong>前序遍历结果</strong>：1、2、5、6、3</p><p><strong>中序遍历结果</strong>：5、2、6、1、3</p><p><strong>后序遍历结果</strong>：5、6、2、3、1</p><h4 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h4><p>此代码使用<strong>手动</strong>的方式创建二叉树，使用<strong>递归</strong>的方式遍历二叉树</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建二叉树</span>      BinaryTree binaryTree = <span class="hljs-keyword">new</span> BinaryTree();      <span class="hljs-comment">//手动创建节点，并放入二叉树中</span>      StuNode stu1 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);      StuNode stu2 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);      StuNode stu3 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">3</span>, <span class="hljs-string">"C"</span>);      StuNode stu4 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">4</span>, <span class="hljs-string">"D"</span>);      stu1.setLeft(stu2);      stu1.setRight(stu3);      stu3.setRight(stu4);      binaryTree.setRoot(stu1);      <span class="hljs-comment">//遍历二叉树</span>      binaryTree.preTraverse();      binaryTree.midTraverse();      binaryTree.lastTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 根节点</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> StuNode root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(StuNode root)</span> </span>&#123;      <span class="hljs-keyword">this</span>.root = root;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"前序遍历"</span>);         root.preTraverse();         System.out.println();      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"二叉树为空！"</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"中序遍历"</span>);         root.midTraverse();         System.out.println();      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"二叉树为空！"</span>);      &#125;  &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"后序遍历"</span>);         root.lastTraverse();         System.out.println();      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"二叉树为空！"</span>);      &#125;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 二叉树中的一个节点</span><span class="hljs-comment"> * 保存了学生信息和左右孩子信息</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StuNode</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   StuNode left;   StuNode right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StuNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StuNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(StuNode left)</span> </span>&#123;      <span class="hljs-keyword">this</span>.left = left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StuNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> right;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(StuNode right)</span> </span>&#123;      <span class="hljs-keyword">this</span>.right = right;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"StuNode&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//父节点的位置</span>      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 中序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.midTraverse();      &#125;      <span class="hljs-comment">//父节点的位置</span>      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.midTraverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.lastTraverse();      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.lastTraverse();      &#125;      <span class="hljs-comment">//父节点的位置</span>      System.out.println(<span class="hljs-keyword">this</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">前序遍历StuNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'A'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'B'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;中序遍历StuNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'B'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'A'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;后序遍历StuNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'B'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'A'</span>&#125;</code></pre><h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>使用迭代对二叉树进行遍历与递归类似，不过需要自己维护一个<strong>栈</strong>用于存放节点</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      TreeNode node1 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">1</span>);      TreeNode node2 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);      TreeNode node3 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);      node1.left = node2;      node1.right = node3;      List&lt;Integer&gt; integers = preTraverse(node1);      System.out.println(<span class="hljs-string">"前序遍历结果"</span>);      <span class="hljs-keyword">for</span> (Integer integer : integers) &#123;         System.out.print(integer);         System.out.print(<span class="hljs-string">" "</span>);      &#125;      System.out.println();      List&lt;Integer&gt; integers2 = midTraverse(node1);      System.out.println(<span class="hljs-string">"中遍历结果"</span>);      <span class="hljs-keyword">for</span> (Integer integer : integers2) &#123;         System.out.print(integer);         System.out.print(<span class="hljs-string">" "</span>);      &#125;      System.out.println();      List&lt;Integer&gt; integers3 = lastTraverse(node1);      System.out.println(<span class="hljs-string">"后遍历结果"</span>);      <span class="hljs-keyword">for</span> (Integer integer : integers3) &#123;         System.out.print(integer);         System.out.print(<span class="hljs-string">" "</span>);      &#125;      System.out.println();   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 使用迭代法对二叉树进行前序遍历</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> root 二叉树根节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 遍历后的集合</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">preTraverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;      <span class="hljs-comment">// 用于存放结果的集合</span>      List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> result;      &#125;      <span class="hljs-comment">// 栈，用于存放遍历的节点</span>      Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();      stack.push(root);      <span class="hljs-comment">// 遍历二叉树</span>      <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;         <span class="hljs-comment">// 栈顶元素出栈，并放入集合中</span>         root = stack.pop();         result.add(root.val);         <span class="hljs-comment">// 先遍历右子树，将其压栈</span>         <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.right);         &#125;         <span class="hljs-comment">// 遍历左子树,压栈</span>         <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.left);         &#125;      &#125;      <span class="hljs-keyword">return</span> result;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 使用迭代法对二叉树进行中序遍历</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> root 二叉树根节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 中序遍历结果集合</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">midTraverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;      List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> result;      &#125;      Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();      <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;         <span class="hljs-comment">// 节点压栈，并遍历其左子树</span>         <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;         &#125;         <span class="hljs-comment">// 栈顶元素出栈，放入结果集合</span>         root = stack.pop();         result.add(root.val);         <span class="hljs-comment">// 遍历该节点的右子树</span>         root = root.right;      &#125;      <span class="hljs-keyword">return</span> result;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 使用迭代法的后序遍历</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> root 二叉树根节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 后序遍历集合</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">lastTraverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;      List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> result;      &#125;      Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();      <span class="hljs-comment">// 保存放入集合的右子树，避免重复放入</span>      TreeNode pre = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;         <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;         &#125;         <span class="hljs-comment">// 获取栈顶元素</span>         root = stack.pop();         <span class="hljs-comment">// 如果该元素没有右子树，或者右子树已近被遍历过了，就放入集合</span>         <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span> || root.right == pre) &#123;            result.add(root.val);            pre = root;            root = <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 否则就继续遍历该节点的右子树</span>            stack.push(root);            root = root.right;         &#125;      &#125;      <span class="hljs-keyword">return</span> result;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">前序遍历结果<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>     中遍历结果<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>     后遍历结果<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span></code></pre><h3 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h3><p>前、中、后序查找的思路与遍历相似，当找到对应的元素时，直接返回即可。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建根节点</span>      BinarySearchTree tree = <span class="hljs-keyword">new</span> BinarySearchTree();      <span class="hljs-comment">//手动创建节点</span>      Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);      Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);      Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">"C"</span>);      Student student4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">"D"</span>);      Student student5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">"E"</span>);      student1.setLeft(student2);      student1.setRight(student3);      student2.setLeft(student4);      student3.setRight(student5);      <span class="hljs-comment">//指定根节点</span>      tree.setRoot(student1);      <span class="hljs-comment">//查找</span>      tree.preSearch(<span class="hljs-number">3</span>);      tree.midSearch(<span class="hljs-number">4</span>);      tree.lastSearch(<span class="hljs-number">7</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;   <span class="hljs-keyword">private</span> Student root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(Student root)</span> </span>&#123;      <span class="hljs-keyword">this</span>.root = root;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"前序查找"</span>);      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"树为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student result = root.preSearch(id);      <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);         System.out.println();         <span class="hljs-keyword">return</span>;      &#125;      System.out.println(result);      System.out.println();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"中序查找"</span>);      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"树为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student result = root.midSearch(id);      <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);         System.out.println();         <span class="hljs-keyword">return</span>;      &#125;      System.out.println(result);      System.out.println();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"后序查找"</span>);      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"树为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student result = root.lastSearch(id);      <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);         System.out.println();         <span class="hljs-keyword">return</span>;      &#125;      System.out.println(result);      System.out.println();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   Student left;   Student right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(Student left)</span> </span>&#123;      <span class="hljs-keyword">this</span>.left = left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> right;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(Student right)</span> </span>&#123;      <span class="hljs-keyword">this</span>.right = right;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 要查找的学生id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 查找到的学生</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">preSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-comment">//如果找到了，就返回</span>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.id == id) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-comment">//在左子树中查找，如果找到了就返回</span>      Student student = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         student = left.preSearch(id);      &#125;      <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> student;      &#125;      <span class="hljs-comment">//在右子树中查找，无论是否找到，都需要返回</span>      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         student = right.preSearch(id);      &#125;      <span class="hljs-keyword">return</span> student;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 中序查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 要查找的学生id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 查找到的学生</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">midSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      Student student = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         student = left.midSearch(id);      &#125;      <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> student;      &#125;      <span class="hljs-comment">//找到了就返回</span>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.id == id) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         student = right.midSearch(id);      &#125;      <span class="hljs-keyword">return</span> student;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 后序查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 要查找的学生id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 查找到的学生</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">lastSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      Student student = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         student = left.lastSearch(id);      &#125;      <span class="hljs-keyword">if</span>(student !=<span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> student;      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         student = right.lastSearch(id);      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.id == id) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-keyword">return</span> student;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">前序查找Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;中序查找Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;后序查找未找到该元素</code></pre><h3 id="二叉树的删除"><a href="#二叉树的删除" class="headerlink" title="二叉树的删除"></a>二叉树的删除</h3><h4 id="删除要求"><a href="#删除要求" class="headerlink" title="删除要求"></a>删除要求</h4><ul><li>如果删除的是叶子节点，则直接删除即可</li><li>如果删除的是非叶子节点，则<strong>删除该子树</strong></li></ul><h4 id="删除思路"><a href="#删除思路" class="headerlink" title="删除思路"></a>删除思路</h4><ul><li><p>因为我们的二叉树是<strong>单向的</strong>，所以我们是判断<strong>当前结点的子结点</strong>是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点</p></li><li><p>如果当前结点的<strong>左子结点不为空</strong>，并且左子结点就是要删除结点，就将 <strong>this.left = null</strong>; 并且就返回 (结束递归删除)</p></li><li><p>如果当前结点的<strong>右子结点不为空</strong>，并且右子结点就是要删除结点，就将 <strong>this.right= null</strong> ;并且就返回 (结束递归删除)</p></li><li><p>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</p></li><li><p>如果 4步也没有删除结点，则应当向右子树进行递归删除</p></li></ul><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建根节点</span>      BinaryDeleteTree deleteTree = <span class="hljs-keyword">new</span> BinaryDeleteTree();      <span class="hljs-comment">//手动创建节点</span>      StudentNode student1 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);      StudentNode student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);      StudentNode student3 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">3</span>, <span class="hljs-string">"C"</span>);      StudentNode student4 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">4</span>, <span class="hljs-string">"D"</span>);      StudentNode student5 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">5</span>, <span class="hljs-string">"E"</span>);      student1.setLeft(student2);      student1.setRight(student3);      student2.setLeft(student4);      student3.setRight(student5);      <span class="hljs-comment">//指定根节点</span>      deleteTree.setRoot(student1);      <span class="hljs-comment">//删除节点</span>      deleteTree.deleteNode(<span class="hljs-number">3</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryDeleteTree</span> </span>&#123;   StudentNode root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(StudentNode root)</span> </span>&#123;      <span class="hljs-keyword">this</span>.root = root;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 删除节点的id</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"删除节点"</span>);      <span class="hljs-keyword">if</span>(root.id == id) &#123;         root = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"根节点被删除"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//调用删除方法</span>      root.deleteNode(id);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentNode</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   StudentNode left;   StudentNode right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StudentNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(StudentNode left)</span> </span>&#123;      <span class="hljs-keyword">this</span>.left = left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StudentNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> right;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(StudentNode right)</span> </span>&#123;      <span class="hljs-keyword">this</span>.right = right;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"StudentNode&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 删除节点的id</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-comment">//如果左子树不为空且是要查找的节点，就删除</span>      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; left.id == id) &#123;         left = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"删除成功"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果右子树不为空且是要查找的节点，就删除</span>      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span> &amp;&amp; right.id == id) &#123;         right = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"删除成功"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//左递归，继续查找</span>      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.deleteNode(id);      &#125;      <span class="hljs-comment">//右递归，继续查找</span>      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.deleteNode(id);      &#125;   &#125;&#125;</code></pre><h3 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h3><h4 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a><strong>基本说明</strong></h4><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即<strong>数组可以转换成树</strong>，<strong>树也可以转换成数组</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200726130159.png" srcset="/img/loading.gif" alt=""></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>顺序二叉树通常只考虑<strong>完全二叉树</strong></li><li>第 n个元素的<strong>左</strong>子节点为 <strong>2 × n + 1</strong></li><li>第 n个元素的<strong>右</strong>子节点为 <strong>2 × n + 2</strong></li><li>第 n个元素的<strong>父</strong>节点为 <strong>(n-1) ÷2</strong><ul><li>其中<strong>n</strong> 表示二叉树中的第几个元素(从0开始编号)</li></ul></li></ul><p>遍历过程和二叉树的遍历类似，只不过递归的条件有所不同</p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;      ArrBinaryTree arrBinaryTree = <span class="hljs-keyword">new</span> ArrBinaryTree(arr);      <span class="hljs-comment">//前序遍历</span>      System.out.println(<span class="hljs-string">"数组前序遍历"</span>);      arrBinaryTree.preTraverse();      System.out.println();      <span class="hljs-comment">//中序遍历</span>      System.out.println(<span class="hljs-string">"数组中序遍历"</span>);      arrBinaryTree.midTraverse();      System.out.println();      <span class="hljs-comment">//后序遍历</span>      System.out.println(<span class="hljs-string">"数组后序遍历"</span>);      arrBinaryTree.lastTraverse();      System.out.println();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrBinaryTree</span> </span>&#123;   <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STEP = <span class="hljs-number">2</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">this</span>.arr = arr;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 数组的前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      preTraverse(<span class="hljs-number">0</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 数组的前序遍历</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> index 遍历到的数组元素下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"数组为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      System.out.print(arr[index] + <span class="hljs-string">" "</span>);      <span class="hljs-comment">//向左递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">1</span> &lt; arr.length) &#123;         preTraverse((index * STEP) + <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">//向右递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">2</span> &lt; arr.length) &#123;         preTraverse((index * STEP) + <span class="hljs-number">2</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">()</span> </span>&#123;      midTraverse(<span class="hljs-number">0</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"数组为空!"</span>);      &#125;      <span class="hljs-comment">//左递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">1</span> &lt; arr.length) &#123;         midTraverse((index * STEP) + <span class="hljs-number">1</span>);      &#125;      System.out.print(arr[index] + <span class="hljs-string">" "</span>);      <span class="hljs-comment">//右递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">2</span> &lt; arr.length) &#123;         midTraverse((index * STEP) + <span class="hljs-number">2</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">()</span> </span>&#123;      lastTraverse(<span class="hljs-number">0</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"数组为空!"</span>);      &#125;      <span class="hljs-comment">//左递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">1</span> &lt; arr.length) &#123;         lastTraverse((index * STEP) + <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">//右递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">2</span> &lt; arr.length) &#123;         lastTraverse((index * STEP) + <span class="hljs-number">2</span>);      &#125;      System.out.print(arr[index] + <span class="hljs-string">" "</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">数组前序遍历<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> 数组中序遍历<span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> 数组后序遍历<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span></code></pre><h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>因为一般的二叉树，叶子节点的左右指针都为空，这样就会造成<strong>空间的浪费</strong>。为了减少浪费，便有了线索化二叉树</p><ul><li><p>n个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指针域，存放指向该结点在<strong>某种遍历次序</strong>下的前驱和后继结点的指针</p></li><li><p>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树</p></li><li><p>根据线索性质的不同，线索二叉树可分为<strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种</p></li><li><p>如果一个节点已经有了左右孩子，那么该节点就不能被线索化了，所以线索化二叉树后，节点的left和right有如下两种情况</p><ul><li>left可能指向的是左孩子，也可能指向的是前驱节点</li><li>right可能指向的是右孩子，也可能指向的是后继节点</li></ul></li></ul><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><strong>中序线索化前</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200726155144.png" srcset="/img/loading.gif" alt=""></p><p><strong>中序线索化后</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200726155345.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p><strong>线索化思路</strong></p><ul><li>每个节点需要用两个变量来表示<strong>左右指针的类型</strong>（保存左右子树，还是前驱后继）</li><li>需要用两个变量来表示<strong>当前节点</strong>和当前节点的<strong>前驱节点</strong></li><li>通过将<strong>当前节点的左指针</strong>指向前驱节点，来实现前驱节点的绑定</li><li>通过将<strong>前驱节点的右指针</strong>指向当前节点，来实现后继节点的绑定</li></ul><p><strong>遍历方式</strong></p><ul><li>各个节点可以通过<strong>线性</strong>的方式遍历，无需使用递归的方式遍历</li><li>首先有一个外循环，代替递归操作，循环条件的暂存节点不为空</li><li>第一个内循环用于找到第一个元素，然后打印</li><li>第二个循环用于找到节点的后继元素</li><li>最后将暂存节点令为右孩子</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//初始化节点</span>Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"1"</span>);Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"3"</span>);Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">"6"</span>);Student student4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">"8"</span>);Student student5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">"10"</span>);Student student6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-string">"14"</span>);<span class="hljs-comment">//手动创建二叉树</span>ThreadedBinaryTree tree = <span class="hljs-keyword">new</span> ThreadedBinaryTree();student1.setLeft(student2);student1.setRight(student3);student2.setLeft(student4);student2.setRight(student5);student3.setLeft(student6);tree.setRoot(student1);tree.midThreaded();<span class="hljs-comment">//得到第五个节点的前驱节点和后继节点</span>System.out.println(<span class="hljs-string">"第五个节点的前驱节点和后继节点"</span>);System.out.println(student5.getLeft());System.out.println(student5.getRight());<span class="hljs-comment">//遍历线索化二叉树</span>System.out.println(<span class="hljs-string">"遍历线索化二叉树"</span>);tree.midThreadedTraverse();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadedBinaryTree</span> </span>&#123;<span class="hljs-keyword">private</span> Student root;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 指向当前节点的前一个节点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Student pre;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(Student root)</span> </span>&#123;<span class="hljs-keyword">this</span>.root = root;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 中序线索化</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 当前节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midThreaded</span><span class="hljs-params">(Student node)</span> </span>&#123;<span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//左线索化</span>midThreaded(node.getLeft());        <span class="hljs-comment">//线索化当前节点</span><span class="hljs-comment">//如果当前节点的左指针为空，就指向前驱节点，并改变左指针类型</span><span class="hljs-keyword">if</span>(node.getLeft() == <span class="hljs-keyword">null</span>) &#123;node.setLeft(pre);node.setLeftType(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//通过前驱节点来将右指针的值令为后继节点</span><span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span> &amp;&amp; pre.getRight() == <span class="hljs-keyword">null</span>) &#123;pre.setRight(node);pre.setRightType(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//处理一个节点后，让当前节点变为下一个节点的前驱节点</span>pre = node;<span class="hljs-comment">//右线索化</span>midThreaded(node.getRight());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midThreaded</span><span class="hljs-params">()</span> </span>&#123;midThreaded(root);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 遍历线索化后的二叉树</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midThreadedTraverse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//暂存遍历到的节点</span>Student tempNode = root;<span class="hljs-comment">//非递归的方法遍历，如果tempNode不为空就一直循环</span><span class="hljs-keyword">while</span>(tempNode != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//一直访问二叉树的左子树，直到某个节点的左子树指向前驱节点</span><span class="hljs-keyword">while</span>(tempNode.getLeftType() != <span class="hljs-number">1</span>) &#123;tempNode = tempNode.getLeft();&#125;<span class="hljs-comment">//找到了第一个节点</span>System.out.println(tempNode);<span class="hljs-comment">//再访问该节点的右子树，看是否保存了后继节点</span><span class="hljs-comment">//如果是，则打印该节点的后继节点信息</span><span class="hljs-keyword">while</span>(tempNode.getRightType() == <span class="hljs-number">1</span>) &#123;tempNode = tempNode.getRight();System.out.println(tempNode);&#125;tempNode = tempNode.getRight();&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> Student left;<span class="hljs-keyword">private</span> Student right;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 左、右指针的类型，0--&gt;指向的是左右孩子，1--&gt;指向的是前驱、后续节点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> leftType = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rightType = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(Student left)</span> </span>&#123;<span class="hljs-keyword">this</span>.left = left;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> right;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(Student right)</span> </span>&#123;<span class="hljs-keyword">this</span>.right = right;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeftType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> leftType;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeftType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> leftType)</span> </span>&#123;<span class="hljs-keyword">this</span>.leftType = leftType;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRightType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rightType;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRightType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rightType)</span> </span>&#123;<span class="hljs-keyword">this</span>.rightType = rightType;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +<span class="hljs-string">"id="</span> + id +<span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">第五个节点的前驱节点和后继节点Student&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'3'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'1'</span>&#125;遍历线索化二叉树Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'8'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'3'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=5, <span class="hljs-attribute">name</span>=<span class="hljs-string">'10'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'1'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=6, <span class="hljs-attribute">name</span>=<span class="hljs-string">'14'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'6'</span>&#125;</code></pre><h2 id="2、树的应用"><a href="#2、树的应用" class="headerlink" title="2、树的应用"></a>2、树的应用</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>详见<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#11%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F">排序算法——堆排序</a></p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200727192923.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>给定 n个权值作为 n个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度(wpl)达到最小</strong>，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)</li><li>哈夫曼树是带权路径长度最短的树，<strong>权值较大的结点离根较近</strong></li></ul><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><ul><li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为 <strong>L-1</strong></li><li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该<strong>结点的权</strong>。<ul><li><strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的<strong>乘积</strong>（W×L）</li></ul></li><li><strong>树的带权路径长度</strong>：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>（W1×L1+W2×L2…），记为WPL(weighted pathlength) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li><li>WPL最小的就是哈夫曼树</li></ul><h4 id="创建思路及图解"><a href="#创建思路及图解" class="headerlink" title="创建思路及图解"></a>创建思路及图解</h4><p><strong>创建思路</strong></p><ul><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出<strong>根节点权值最小</strong>的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树<strong>根节点权值的和</strong></li><li>再将这颗新的二叉树，以<strong>根节点的权值大小 再次排序</strong>，不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ul><p><strong>图解</strong></p><p>以{3, 6, 7, 1, 8, 29, 13}为例</p><p><strong>首先排序</strong>：{1, 3, 6, 7, 8, 13, 29}</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185121.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185142.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185223.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185340.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185434.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185516.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">29</span>, <span class="hljs-number">13</span>&#125;;      HuffmanTree huffmanTree = <span class="hljs-keyword">new</span> HuffmanTree();      Node root = huffmanTree.createHuffmanTree(arr);      root.preTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTree</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-comment">//创建数组用于存放Node</span>      ArrayList&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(arr.length);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> value : arr) &#123;         nodes.add(<span class="hljs-keyword">new</span> Node(value));      &#125;      <span class="hljs-comment">//对集合中的元素进行排序</span>      Collections.sort(nodes);      <span class="hljs-keyword">while</span>(nodes.size() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//左右子树在集合中对应的下标</span>         <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>;         <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">1</span>;         <span class="hljs-comment">//取出最小的两个节点</span>         Node leftNode = nodes.get(leftIndex);         Node rightNode = nodes.get(rightIndex);         <span class="hljs-comment">//创建父节点，并创建左右子树</span>         Node parent = <span class="hljs-keyword">new</span> Node(leftNode.value + rightNode.value);         parent.left = leftNode;         parent.right = rightNode;         <span class="hljs-comment">//从集合中移除两个最小的节点，并将父节点放入集合中</span>         nodes.add(parent);         nodes.remove(leftNode);         nodes.remove(rightNode);         <span class="hljs-comment">//再次比较</span>         Collections.sort(nodes);      &#125;      <span class="hljs-comment">//返回根节点</span>      <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt; </span>&#123;   <span class="hljs-keyword">int</span> value;   Node left;   Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Node&#123;"</span> +            <span class="hljs-string">"value="</span> + value +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 重写比较函数，用于排序</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;      <span class="hljs-keyword">return</span> value - o.value;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.print(<span class="hljs-keyword">this</span>.value + <span class="hljs-string">" "</span>);      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.left.preTraverse();      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.right.preTraverse();      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">前序遍历哈夫曼树<span class="hljs-number">67</span> <span class="hljs-number">29</span> <span class="hljs-number">38</span> <span class="hljs-number">15</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">23</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">13</span></code></pre><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h4 id="原理及图解"><a href="#原理及图解" class="headerlink" title="原理及图解"></a>原理及图解</h4><p><strong>前缀编码</strong>：任何一个字符的编码，都不会是其它的字符的前缀</p><ul><li>统计需编码的字符串中，各个字符出现的次数：如helloworld<ul><li>h:1 e:1 w:1 r:1 d:1 o:2 l:3</li></ul></li><li>将字符出现的次数作为权值，构建哈弗曼树。如下图</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200728190229.png" srcset="/img/loading.gif" alt=""></p><ul><li>根据哈弗曼树进行编码，向左的路径为0，向右的路径为1<ul><li>字符编码结果为：h:000 e:001 w:100 d:1010 r:1011 l:11 o:01</li><li>字符串编码结果为：000001111101100011011111010</li></ul></li></ul><h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><p>此处代码只实现了哈弗曼树的创建与每个字符的编码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">"helloworld"</span>;      <span class="hljs-comment">//哈夫曼编码</span>      HuffmanCode huffmanCode = <span class="hljs-keyword">new</span> HuffmanCode();      ArrayList&lt;Code&gt; list = huffmanCode.getList(str);      <span class="hljs-comment">//构建哈弗曼树</span>      Code root = huffmanCode.createHuffmanTree(list);      System.out.println(<span class="hljs-string">"前序遍历哈弗曼树"</span>);      root.preTraverse();      <span class="hljs-comment">//进行哈弗曼编码</span>      Map&lt;Byte, String&gt; codeMap = root.getCodeMap();      System.out.println(<span class="hljs-string">"哈弗曼编码"</span>);      System.out.println(codeMap);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanCode</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Code&gt; <span class="hljs-title">getList</span><span class="hljs-params">(String codes)</span> </span>&#123;      <span class="hljs-comment">//得到字符串对应的字节数组</span>      <span class="hljs-keyword">byte</span>[] byteCodes = codes.getBytes();      <span class="hljs-comment">//创建哈希表，用于存放数据及其权值（出现次数）</span>      Map&lt;Byte, Integer&gt; dataAndWight = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">byte</span> b : byteCodes) &#123;         Integer wight = dataAndWight.get(b);         <span class="hljs-comment">//如果还没有该数据，就创建并让其权值为1</span>         <span class="hljs-keyword">if</span>(dataAndWight.get(b) == <span class="hljs-keyword">null</span>) &#123;            dataAndWight.put(b, <span class="hljs-number">1</span>);         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果已经有了该数据，就让其权值加一</span>            dataAndWight.put(b, wight+<span class="hljs-number">1</span>);         &#125;      &#125;      <span class="hljs-comment">//创建List，用于返回</span>      ArrayList&lt;Code&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-comment">//遍历哈希表，放入List集合中</span>      <span class="hljs-keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry : dataAndWight.entrySet()) &#123;         list.add(<span class="hljs-keyword">new</span> Code(entry.getKey(), entry.getValue()));      &#125;      <span class="hljs-keyword">return</span> list;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Code <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(ArrayList&lt;Code&gt; lists)</span> </span>&#123;      <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">1</span>;      <span class="hljs-comment">//根据权值进行排序</span>      Collections.sort(lists);      <span class="hljs-keyword">while</span> (lists.size() &gt; <span class="hljs-number">1</span>) &#123;         Code leftCode = lists.get(leftIndex);         Code rightCode = lists.get(rightIndex);         Code parent = <span class="hljs-keyword">new</span> Code(<span class="hljs-keyword">null</span>,leftCode.weight + rightCode.weight);         parent.left = leftCode;         parent.right = rightCode;         lists.add(parent);         lists.remove(leftCode);         lists.remove(rightCode);         <span class="hljs-comment">//再次排序</span>         Collections.sort(lists);      &#125;      <span class="hljs-keyword">return</span> lists.get(<span class="hljs-number">0</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Code</span>&gt; </span>&#123;   Byte data;   <span class="hljs-keyword">int</span> weight;   Code left;   Code right;   <span class="hljs-keyword">private</span> Map&lt;Byte, String&gt; codeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Code</span><span class="hljs-params">(Byte data, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.weight = weight;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Code&#123;"</span> +            <span class="hljs-string">"data="</span> + data +            <span class="hljs-string">", weight="</span> + weight +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Byte, String&gt; <span class="hljs-title">getCodeMap</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> getCode(<span class="hljs-keyword">this</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> StringBuilder());   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对哈弗曼树中的叶子节点进行编码</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 根节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> code 左子树为0，右子树为1</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> stringBuilder 用于拼接的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;Byte, String&gt; <span class="hljs-title">getCode</span><span class="hljs-params">(Code node, String code, StringBuilder stringBuilder)</span> </span>&#123;      <span class="hljs-comment">//新建拼接路径</span>      StringBuilder appendCode = <span class="hljs-keyword">new</span> StringBuilder(stringBuilder);      appendCode.append(code);      <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//如果是非叶子结点，就继续向下遍历</span>         <span class="hljs-keyword">if</span>(node.data == <span class="hljs-keyword">null</span>) &#123;            getCode(node.left, <span class="hljs-string">"0"</span>, appendCode);            getCode(node.right, <span class="hljs-string">"1"</span>, appendCode);         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果是叶子节点，就将哈弗曼编码放入哈希表中</span>            codeMap.put(node.data, appendCode.toString());         &#125;      &#125;      <span class="hljs-keyword">return</span> codeMap;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Code o)</span> </span>&#123;      <span class="hljs-keyword">return</span> weight - o.weight;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">前序遍历哈弗曼树Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">10</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">4</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">2</span>&#125;Code&#123;data=<span class="hljs-number">114</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-number">100</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">2</span>&#125;Code&#123;data=<span class="hljs-number">101</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-number">119</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">6</span>&#125;Code&#123;data=<span class="hljs-number">108</span>, weight=<span class="hljs-number">3</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">3</span>&#125;Code&#123;data=<span class="hljs-number">104</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-number">111</span>, weight=<span class="hljs-number">2</span>&#125;每个字符对应的哈弗曼编码&#123;<span class="hljs-number">114</span>=<span class="hljs-number">000</span>, <span class="hljs-number">100</span>=<span class="hljs-number">001</span>, <span class="hljs-number">101</span>=<span class="hljs-number">010</span>, <span class="hljs-number">119</span>=<span class="hljs-number">011</span>, <span class="hljs-number">104</span>=<span class="hljs-number">110</span>, <span class="hljs-number">108</span>=<span class="hljs-number">10</span>, <span class="hljs-number">111</span>=<span class="hljs-number">111</span>&#125;</code></pre><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><strong>二叉排序树</strong>：BST: (Binary Sort(Search) Tree), 对于二叉排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong></p><ul><li><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点</li></ul><p> 比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729161543.png" srcset="/img/loading.gif" alt=""></p><h4 id="操作思路"><a href="#操作思路" class="headerlink" title="操作思路"></a>操作思路</h4><p><strong>添加</strong></p><ul><li>根据插入节点的值来寻找其应该插入的位置</li><li>新插入的节点都是<strong>叶子节点</strong></li></ul><p><strong>删除</strong></p><p>删除<strong>叶子节点</strong>（如删除值为2节点）</p><ul><li>找到待删除的节点</li><li>找到待删除节点的父节点</li><li>判断待删除节点是其<strong>父节点</strong>的左孩子还是右孩子，然后让其令为空</li></ul><p>删除<strong>只有一颗子树的节点</strong>（如删除值为1的节点）</p><ul><li>找到待删除的节点</li><li>找到待删除的节点的父节点</li><li>判断待删除节点是其<strong>父节点</strong>的左孩子还是右孩子</li><li>判断待删除节点的<strong>子树</strong>是其左孩子还是右孩子</li><li>让父节点指向待删除节点的子树指向待删除节点的子树</li></ul><p>删除有<strong>两颗子树的节点</strong>（如删除值为3的节点）</p><ul><li>找到待删除的节点</li><li>找到待删除的节点的父节点</li><li>判断待删除节点是其<strong>父节点</strong>的左孩子还是右孩子</li><li>顺着待删除节点的<strong>右子树</strong>，找到一个值最小的节点（该值的大小最接近待删除节点的值）</li><li>让父节点指向待删除节点的子树指向上一步找到的最小的节点</li></ul><p>删除<strong>根节点</strong>（如删除值为7的节点）</p><ul><li>删除根结点的方法和删除有两个子树的方法相似</li><li>找到一个接近根节点值的节点</li><li>删除该节点，将该节点的值赋值给根节点即可</li></ul><h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;;      <span class="hljs-comment">//创建二叉排序树</span>      BinarySortTree binarySortTree = <span class="hljs-keyword">new</span> BinarySortTree();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;         binarySortTree.addNode(<span class="hljs-keyword">new</span> Node(arr[i]));      &#125;      <span class="hljs-comment">//前序遍历</span>      System.out.println(<span class="hljs-string">"前序遍历二叉排序树"</span>);      binarySortTree.preTraverse();      System.out.println();      <span class="hljs-comment">//删除值为5、1、3、10、7的节点</span>      binarySortTree.deleteNode(<span class="hljs-number">2</span>);      binarySortTree.deleteNode(<span class="hljs-number">1</span>);      binarySortTree.deleteNode(<span class="hljs-number">10</span>);      binarySortTree.deleteNode(<span class="hljs-number">7</span>);      System.out.println(<span class="hljs-string">"前序遍历二叉排序树"</span>);      binarySortTree.preTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span> </span>&#123;   <span class="hljs-keyword">private</span> Node root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-comment">//如果根节点为空，就直接将该节点作为根节点</span>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         root = node;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//否则就插入该节点到对应的位置</span>      root.add(node);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"二叉树为空"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;         root.preTraverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getTargetNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"请先创建二叉树"</span>);         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> root.getTargetNode(targetValue);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getParentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"请先创建二叉树"</span>);         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> root.getParentNode(targetValue);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> targetValue 待删除节点的值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"请先创建二叉树"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//找到待删除结点</span>      Node targetNode = getTargetNode(targetValue);      <span class="hljs-keyword">if</span> (targetNode == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该节点，删除失败"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果只有一个根节点，就删除根节点</span>      <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;         root = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"删除成功"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//得到其父节点</span>      Node parentNode = getParentNode(targetValue);      <span class="hljs-comment">//如果父节点为空（待删除节点为根节点）</span>      <span class="hljs-keyword">if</span>(parentNode == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">int</span> minValue = getMinValue(targetNode.right);         deleteNode(minValue);         <span class="hljs-comment">//根节点的值令为最接近的值</span>         targetNode.value = minValue;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果待删除节点为叶子节点</span>      <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span> (parentNode.left != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.left == targetNode) &#123;            <span class="hljs-comment">//删除左子树</span>            parentNode.left = <span class="hljs-keyword">null</span>;            System.out.println(<span class="hljs-string">"删除成功"</span>);         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentNode.right != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.right == targetNode) &#123;            <span class="hljs-comment">//删除右子树</span>            parentNode.right = <span class="hljs-keyword">null</span>;            System.out.println(<span class="hljs-string">"删除成功"</span>);         &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//待删除节点有左右子树</span>         <span class="hljs-comment">//得到并删除待删除节点右子树中值最小的节点</span>         <span class="hljs-keyword">int</span> minValue = getMinValue(targetNode.right);         deleteNode(minValue);         <span class="hljs-comment">//将值最小的节点的值作为新的目标节点</span>         targetNode.value = minValue;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">//待删除节点只有左子树</span>         <span class="hljs-keyword">if</span>(targetNode.left != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span>(parentNode.left != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.left == targetNode) &#123;               parentNode.left = targetNode.left;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentNode.right != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.right == targetNode) &#123;               parentNode.right = targetNode.left;            &#125;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//待删除节点只有右子树</span>            <span class="hljs-keyword">if</span>(parentNode.left != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.left == targetNode) &#123;               parentNode.left = targetNode.right;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentNode.right != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.right == targetNode) &#123;               parentNode.right = targetNode.right;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 找到以node为根节点的二叉树的最小节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 作为根节点的节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 值最小的节点的值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinValue</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">while</span>(node.left != <span class="hljs-keyword">null</span>) &#123;         node = node.left;      &#125;      <span class="hljs-comment">//返回值最小的节点</span>      <span class="hljs-keyword">return</span> node.value;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">int</span> value;   Node left;   Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Node&#123;"</span> +            <span class="hljs-string">"value="</span> + value +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 添加节点到二叉排序树的对应位置</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 待插入的节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果该节点的值大待插入节点的值</span>      <span class="hljs-keyword">if</span> (value &gt; node.value) &#123;         <span class="hljs-comment">//如果该节点的左子树为空，就直接插入</span>         <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;            left = node;         &#125; <span class="hljs-keyword">else</span> &#123;            left.add(node);         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;            right = node;         &#125; <span class="hljs-keyword">else</span> &#123;            right.add(node);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 得到目标节点</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> targetValue 目标节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 目标节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getTargetNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-comment">//如果当前节点就是目标节点，就返回</span>      <span class="hljs-keyword">if</span> (value == targetValue) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-comment">//如果当前节点的值大于目标节点，就向左查找，反之向右查找</span>      <span class="hljs-keyword">if</span> (value &gt; targetValue) &#123;         <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> left.getTargetNode(targetValue);         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> right.getTargetNode(targetValue);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 得到目标节点的父节点</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> targetValue 目标节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 目标节点的父节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getParentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-comment">//如果左右子树是目标节点，就返回该节点，否则继续向下查找</span>      <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; left.value == targetValue) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; right.value == targetValue) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; value &gt; targetValue) &#123;            <span class="hljs-keyword">return</span> left.getParentNode(targetValue);         &#125;         <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; value &lt;= targetValue) &#123;            <span class="hljs-keyword">return</span> right.getParentNode(targetValue);         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//没有父节点（根节点）</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs crmsh">前序遍历二叉排序树<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">7</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">2</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">5</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">10</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">9</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">12</span>&#125;删除成功删除成功删除成功删除成功前序遍历二叉排序树<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">9</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">5</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">12</span>&#125;</code></pre><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><strong>为什么需要平衡二叉树</strong></p><ul><li>如果由数组{1, 2, 3, 4}来构建一颗二叉排序树，得到的二叉树不仅没有体现其特点，反而还退化成了链表</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730152912.png" srcset="/img/loading.gif" alt=""></p><p><strong>简介</strong></p><ul><li><p>平衡二叉树也叫平衡<strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为AVL树，可以保证<strong>查询效率较高</strong></p></li><li><p>具有以下特点：</p><ul><li><strong>它是一棵空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过</strong> <strong>1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong></li><li>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等</li></ul></li><li><p>下图所示的二叉树就是平衡二叉树</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730153215.png" srcset="/img/loading.gif" alt=""></p><h4 id="应用案例——左旋转"><a href="#应用案例——左旋转" class="headerlink" title="应用案例——左旋转"></a>应用案例——左旋转</h4><p>将由数列 {4,3,6,5,7,8}构建的二叉排序树，修改为一颗平衡二叉树</p><p>此处<strong>右子树的高度高于左子树，且差值大于1</strong>，所以需要进行<strong>左旋转</strong>，来降低右子树的高度</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730154440.png" srcset="/img/loading.gif" alt=""></p><p><strong>步骤</strong></p><ul><li>创建一个新节点，值为当前节点的值（4）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730200322.png" srcset="/img/loading.gif" alt=""></p><ul><li>让新节点的左子树指向当前节点的左子树</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730154609.png" srcset="/img/loading.gif" alt=""></p><ul><li>让新节点的右子树指向当前节点的右子树的左子树</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155228.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>将当前节点的值改为其右子树的值</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155216.png" srcset="/img/loading.gif" alt=""></p></li><li><p>将当前节点的右子树变为其右子树的右子树</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155146.png" srcset="/img/loading.gif" alt=""></p><ul><li>让当前节点的左子树指向新节点</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155127.png" srcset="/img/loading.gif" alt=""></p><p><strong>整理后结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155105.png" srcset="/img/loading.gif" alt=""></p><h4 id="应用案例——右旋转"><a href="#应用案例——右旋转" class="headerlink" title="应用案例——右旋转"></a>应用案例——右旋转</h4><p>当一颗二叉排序树的<strong>左子树高度大于右子树高度，且差值大于1</strong>时，需要进行右旋转，来降低左子树的高度</p><p><strong>步骤</strong></p><ul><li>创建一个新节点，其值为当前节点的值</li><li>将新节点的右子树指向当前节点的右子树</li><li>将新节点的左子树指向当前节点的左子树的右子树</li><li>将当前节点的值改为其左子树的值</li><li>将当前节点的左子树指向其左子树的左子树</li><li>将当前节点的右子树指向新节点</li></ul><h4 id="应用案例——双旋转"><a href="#应用案例——双旋转" class="headerlink" title="应用案例——双旋转"></a>应用案例——双旋转</h4><p>某些时候，只进行左旋转或者右旋转，并不能将二叉排序树变为平衡二叉树。这时就需要进行<strong>双旋转</strong>，即<strong>同时进行左旋转和右旋转</strong></p><ul><li>进行左旋转时，如果当前节点右子树的左子树高于其右子树，需要先进行左旋转</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730171100.png" srcset="/img/loading.gif" alt=""></p><ul><li>进行右旋转时，如果当前节点左子树的右子树高于其左子树，需要先进性右旋转</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730171151.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;      AVLTree tree = <span class="hljs-keyword">new</span> AVLTree();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;         tree.addNode(<span class="hljs-keyword">new</span> Node(value));      &#125;      System.out.println(<span class="hljs-string">"左右子树高度差值为 "</span> + tree.getDifference());      System.out.println(<span class="hljs-string">"前序遍历"</span>);      tree.preTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span> </span>&#123;   <span class="hljs-keyword">private</span> Node root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-comment">//如果根节点为空，就直接将该节点作为根节点</span>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         root = node;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//否则就插入该节点到对应的位置</span>      root.add(node);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"二叉树为空"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;         root.preTraverse();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 找到以node为根节点的二叉树的最小节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 作为根节点的节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 值最小的节点的值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinValue</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">while</span>(node.left != <span class="hljs-keyword">null</span>) &#123;         node = node.left;      &#125;      <span class="hljs-comment">//返回值最小的节点</span>      <span class="hljs-keyword">return</span> node.value;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDifference</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> leftHeight = root.getLeftHeight();      <span class="hljs-keyword">int</span> rightHeight = root.getRightHeight();      <span class="hljs-comment">//返回左右子树高度差值</span>      <span class="hljs-keyword">return</span> Math.abs(leftHeight - rightHeight);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">int</span> value;   Node left;   Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Node&#123;"</span> +            <span class="hljs-string">"value="</span> + value +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 添加节点到二叉排序树的对应位置</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 待插入的节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果该节点的值大待插入节点的值</span>      <span class="hljs-keyword">if</span> (value &gt; node.value) &#123;         <span class="hljs-comment">//如果该节点的左子树为空，就直接插入</span>         <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;            left = node;         &#125; <span class="hljs-keyword">else</span> &#123;            left.add(node);         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;            right = node;         &#125; <span class="hljs-keyword">else</span> &#123;            right.add(node);         &#125;      &#125;      <span class="hljs-comment">//如果右子树高度与左子树高度差值大于一，就进行左旋转</span>      <span class="hljs-keyword">if</span>(getRightHeight() - getLeftHeight() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//如果当前节点右子树的左子树高度高于右子树，其右子树先进行右旋转</span>         <span class="hljs-keyword">if</span>(right.getLeftHeight() &gt; right.getRightHeight()) &#123;            right.rightRotate();         &#125;         leftRotate();      &#125;      <span class="hljs-comment">//如果左子树高度与右子树的高度差值大于一，就进行右旋转</span>      <span class="hljs-keyword">if</span>(getLeftHeight() - getRightHeight() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//如果当前节点左子树的右子树高度高于左子树，其左子树先进行左旋转</span>         <span class="hljs-keyword">if</span>(left.getRightHeight() &gt; left.getLeftHeight()) &#123;            left.leftRotate();         &#125;         rightRotate();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获得该节点为根节点的树的高度</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 高度</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> Math.max(left == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : left.getHeight(), right == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : right.getHeight()) + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeftHeight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> left.getHeight();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRightHeight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> right.getHeight();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对二叉排序树进行左旋转（右子树高度较高）</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//创建新节点</span>      Node newNode = <span class="hljs-keyword">new</span> Node(value);      <span class="hljs-comment">//新节点的左子树指向当前节点的左子树</span>      newNode.left = left;      <span class="hljs-comment">//新节点的右子树指向当前节点的右子树的左子树</span>      newNode.right = right.left;      <span class="hljs-comment">//当前节点的值变为其右子树的值</span>      value = right.value;      <span class="hljs-comment">//当前节点的右子树指向其右子树的右子树</span>      right = right.right;      <span class="hljs-comment">//当前节点的左子树指向新节点</span>      left = newNode;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对二叉树进行右旋转（左子树高度较高）</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//创建新节点，值为当前节点的值</span>      Node newNode = <span class="hljs-keyword">new</span> Node(value);      <span class="hljs-comment">//新节点的右子树为当前节点的右子树</span>      newNode.right = right;      <span class="hljs-comment">//新节点的左子树为当前节点的左子树的右子树</span>      newNode.left = left.right;      <span class="hljs-comment">//当前节点的值为其左子树的值</span>      value = left.value;      <span class="hljs-comment">//当前节点的左子树为其左子树的左子树</span>      left = left.left;      <span class="hljs-comment">//当前节点的右子树为新节点</span>      right = newNode;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs crmsh">左右子树高度差值为 <span class="hljs-number">0</span>前序遍历<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">8</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">7</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">5</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">10</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">9</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">11</span>&#125;</code></pre><h2 id="3、多叉树"><a href="#3、多叉树" class="headerlink" title="3、多叉树"></a>3、多叉树</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>在二叉树中，每个节点最多有<strong>一个</strong>数据项和<strong>两个</strong>子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</p><p>多叉树通过重新组织节点，<strong>减少树的高度，能对二叉树进行优化</strong></p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730195237.png" srcset="/img/loading.gif" alt=""></p><p><strong>2-3树是最简单的B树结构，具有以下特点</strong></p><ul><li>2-3树的所有<strong>叶子节点都在同一层</strong>(只要是 B树都满足这个条件)</li><li>有两个子节点的节点叫<strong>二节点</strong>，二节点要么没有子节点，要么有两个子节点</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li><li>2-3树是由<strong>二节点和三节点构成的树</strong>（2和3）</li></ul><p><strong>2-3树插入规则</strong></p><ul><li><p>2-3树的所有<strong>叶子节点都在同一层</strong>.(只要是 B树都满足这个条件)</p></li><li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</p></li><li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p></li><li><p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3个条件</strong></p></li><li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p><ul><li>左边的子树值小于父节点的值</li><li>中间的子树值在父节点的值之间</li><li>右边子树的值大于父节点的值</li></ul></li></ul><h3 id="B树、B-和B-树"><a href="#B树、B-和B-树" class="headerlink" title="B树、B+和B*树"></a>B树、B+和B*树</h3><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a><strong>B树</strong></h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730192248.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>B树的阶：节点的<strong>最多子节点个数</strong>。比如 2-3树的阶是3，2-3-4树的阶是4</p></li><li><p>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</p></li><li><p>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据</p></li><li><p>搜索<strong>有可能在非叶子结点结束</strong></p></li><li><p>其搜索性能等价于在关键字全集内做一次二分查找</p></li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a><strong>B+树</strong></h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730193949.png" srcset="/img/loading.gif" alt=""></p><ul><li>B+树是B树的变体，也是一种多路搜索树</li><li>B+树的搜索与 B树也基本相同，区别是 B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫<strong>稠密索引</strong>】），且链表中的关键字(数据)恰好是有序的</li><li><strong>不可能在非叶子结点命中</strong></li><li><strong>非叶子结点</strong>相当于是叶子结点的<strong>索引</strong>（稀疏索引），<strong>叶子结点</strong>相当于是存储（关键字）<strong>数据</strong>的数据层</li><li>更适合文件索引系统</li><li>B树和 B+树各有自己的应用场景，不能说 B+树完全比 B树好，反之亦然</li></ul><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a><strong>B*树</strong></h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200801002754.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针</p></li><li><p>B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为 2/3，而B+树的块的最低使用率为的1/2</p></li><li><p>从第 1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</p></li></ul><h1 id="九、图结构"><a href="#九、图结构" class="headerlink" title="九、图结构"></a>九、图结构</h1><h2 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>当我们需要表示<strong>多对多</strong>的关系时，我们就需要<strong>图</strong></p></li><li><p>图是一种<strong>数据结构</strong>，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为<strong>边</strong>。结点也可以称为顶点</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200731153146.png" srcset="/img/loading.gif" alt=""></p><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ul><li>邻接矩阵是表示图形中<strong>顶点之间相邻关系</strong>的矩阵，对于n个顶点的图而言，矩阵是的row和 col表示的是1…n个点</li></ul><p>如上图的邻接矩阵就是</p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span></code></pre><p>其中0表示没有连接，1表示有连接</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ul><li>邻接矩阵需要为每个顶点都分配 n个边的空间，其实有很多边都是不存在,<strong>会造成空间的一定损失</strong></li><li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，<strong>邻接表由数组+链表组成</strong><ul><li>数组的索引代表顶点</li><li>链表中元素的值代表与该顶点相连的顶点的值</li></ul></li></ul><p>如上图的进阶表就是</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200731154231.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、图的创建"><a href="#2、图的创建" class="headerlink" title="2、图的创建"></a>2、图的创建</h2><h3 id="邻接矩阵创建图"><a href="#邻接矩阵创建图" class="headerlink" title="邻接矩阵创建图"></a>邻接矩阵创建图</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">5</span>;      String[] vertex = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;      Graph graph = <span class="hljs-keyword">new</span> Graph(sum);      <span class="hljs-comment">//指明图的顶点</span>      <span class="hljs-keyword">for</span>(String top : vertex) &#123;         graph.insertVertex(top);      &#125;      <span class="hljs-comment">//指明相连的顶点</span>      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">//显示邻接矩阵</span>      System.out.println(<span class="hljs-string">"邻接矩阵"</span>);      graph.showGraph();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;   ArrayList&lt;String&gt; vertexList;   <span class="hljs-keyword">int</span>[][] edges;   <span class="hljs-keyword">int</span> numOfEdges;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>&#123;      <span class="hljs-comment">//根据顶点总数进行初始化</span>      vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(sum);      edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum][sum];      numOfEdges = <span class="hljs-number">0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;      vertexList.add(vertex);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;      edges[vertex1][vertex2] = weight;      edges[vertex2][vertex1] = weight;      numOfEdges++;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfEdges</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> numOfEdges;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfVertex</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> vertexList.size();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2)</span> </span>&#123;      <span class="hljs-keyword">return</span> edges[vertex1][vertex2];   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] list : edges) &#123;         System.out.println(Arrays.toString(list));      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs json">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre><h2 id="3、图的遍历"><a href="#3、图的遍历" class="headerlink" title="3、图的遍历"></a>3、图的遍历</h2><p>对该图进行深度优先遍历和广度优先遍历</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200801122515.png" srcset="/img/loading.gif" alt=""></p><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><ul><li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li><li>这样的访问策略是<strong>优先往纵向挖掘深入</strong></li><li>深度优先搜索是一个递归的过程</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>访问初始结点v，并标记结点v为已访问</li><li>查找结点v的第一个邻接结点w</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤 3</li></ul><h4 id="实现代码-8"><a href="#实现代码-8" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">5</span>;String[] vertex = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;Graph graph = <span class="hljs-keyword">new</span> Graph(sum);<span class="hljs-comment">//指明图的顶点</span><span class="hljs-keyword">for</span>(String top : vertex) &#123;graph.insertVertex(top);&#125;<span class="hljs-comment">//指明相连的顶点</span>graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//显示邻接矩阵</span>System.out.println(<span class="hljs-string">"邻接矩阵"</span>);graph.showGraph();<span class="hljs-comment">//深度优先遍历</span>System.out.println(<span class="hljs-string">"进行深度优先遍历"</span>);graph.dfs();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 标记是否访问过该顶点，用于遍历</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isTraversed;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<span class="hljs-comment">//根据顶点总数进行初始化</span>vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(sum);edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum][sum];isTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[sum];numOfEdges = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;vertexList.add(vertex);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;edges[vertex1][vertex2] = weight;edges[vertex2][vertex1] = weight;numOfEdges++;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] list : edges) &#123;System.out.println(Arrays.toString(list));&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 深度优先遍历</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> vertex 开始顶点下标</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>&#123;<span class="hljs-comment">//被访问过了就返回</span><span class="hljs-keyword">if</span>(isTraversed[vertex]) &#123;<span class="hljs-keyword">return</span>;&#125;System.out.print(vertexList.get(vertex) + <span class="hljs-string">"-&gt;"</span>);<span class="hljs-comment">//标记已被访问</span>isTraversed[vertex] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//从相邻顶点开始深度优先遍历</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextVertex = vertex+<span class="hljs-number">1</span>; nextVertex&lt;vertexList.size(); nextVertex++) &#123;<span class="hljs-comment">//如果该顶点存在且未被访问，就向下访问</span><span class="hljs-keyword">if</span>(edges[vertex][nextVertex] != <span class="hljs-number">0</span> &amp;&amp; !isTraversed[nextVertex] ) &#123;dfs(nextVertex);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//对未被访问的顶点都进行深度优先遍历</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;vertexList.size(); i++) &#123;<span class="hljs-keyword">if</span>(!isTraversed[i]) &#123;dfs(i);&#125;&#125;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">邻接矩阵[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]进行深度优先遍历A-&gt;B-&gt;C-&gt;E-&gt;D-&gt;</code></pre><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><ul><li>类似于一个<strong>分层搜索</strong>的过程，广度优先遍历需要使用一个<strong>队列</strong>以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>访问初始结点 v并标记结点 v为已访问</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束</li><li>出队列，取得队头结点u</li><li>查找结点 u的第一个邻接结点 w。</li><li>若结点 u的邻接结点 w不存在，则转到步骤 3；否则循环执行以下三个步骤：<ul><li>若结点 w尚未被访问，则访问结点 w并标记为已访问</li><li>结点 w入队列</li><li>查找结点 u的继 w邻接结点后的下一个邻接结点 w，转到步骤6</li></ul></li></ul><h4 id="实现代码-9"><a href="#实现代码-9" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">5</span>;      String[] vertex = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;      Graph graph = <span class="hljs-keyword">new</span> Graph(sum);      <span class="hljs-comment">//指明图的顶点</span>      <span class="hljs-keyword">for</span>(String top : vertex) &#123;         graph.insertVertex(top);      &#125;      <span class="hljs-comment">//指明相连的顶点</span>      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">//显示邻接矩阵</span>      System.out.println(<span class="hljs-string">"邻接矩阵"</span>);      graph.showGraph();      <span class="hljs-comment">//广度优先遍历</span>      System.out.println(<span class="hljs-string">"进行广度优先遍历"</span>);      graph.bfs();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;   <span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 标记是否访问过该顶点，用于遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isTraversed;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 用于保存访问过的顶点</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>&#123;      <span class="hljs-comment">//根据顶点总数进行初始化</span>      vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(sum);      edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum][sum];      isTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[sum];      numOfEdges = <span class="hljs-number">0</span>;      queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;      vertexList.add(vertex);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;      edges[vertex1][vertex2] = weight;      edges[vertex2][vertex1] = weight;      numOfEdges++;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] list : edges) &#123;         System.out.println(Arrays.toString(list));      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 广度优先遍历</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> vertex 遍历顶点的下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>&#123;      <span class="hljs-comment">//未被访问，打印顶点信息</span>      <span class="hljs-keyword">if</span>(!isTraversed[vertex]) &#123;         System.out.print(vertexList.get(vertex) + <span class="hljs-string">"-&gt;"</span>);         isTraversed[vertex] = <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-comment">//继续访问相邻元素</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextVertex = vertex+<span class="hljs-number">1</span>; nextVertex &lt; vertexList.size(); nextVertex++) &#123;         <span class="hljs-comment">//如果存在且未被访问</span>         <span class="hljs-keyword">if</span>(edges[vertex][nextVertex] != <span class="hljs-number">0</span> &amp;&amp; !isTraversed[nextVertex]) &#123;            <span class="hljs-comment">//打印顶点信息</span>            System.out.print(vertexList.get(nextVertex) + <span class="hljs-string">"-&gt;"</span>);            <span class="hljs-comment">//标记为已访问</span>            isTraversed[nextVertex] = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//入队</span>            queue.add(nextVertex);         &#125;      &#125;      <span class="hljs-comment">//相邻元素访问完了（广度优先），再让队列中的元素出队，继续访问</span>      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;         <span class="hljs-comment">//队首元素出队，继续访问</span>         bfs(queue.remove());      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;vertexList.size(); i++) &#123;         <span class="hljs-comment">//未被访问过，就进行广度优先遍历</span>         <span class="hljs-keyword">if</span>(!isTraversed[i]) &#123;            bfs(i);         &#125;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">邻接矩阵[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]进行广度优先遍历A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;</code></pre><h1 id="十、算法"><a href="#十、算法" class="headerlink" title="十、算法"></a>十、算法</h1><h2 id="1、分治算法"><a href="#1、分治算法" class="headerlink" title="1、分治算法"></a>1、分治算法</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是<strong>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</strong>。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p><strong>分治法在每一层递归上都有三个步骤</strong>：</p><ul><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解</li></ul><h3 id="应用——汉诺塔"><a href="#应用——汉诺塔" class="headerlink" title="应用——汉诺塔"></a>应用——汉诺塔</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>A、B、C三个塔</p><ul><li>如果只有一个盘，直接A-&gt;C</li><li>如果大于等于两个盘，就分成两部分。<strong>最下面的一个盘为一部分，上面的所有盘为一部分</strong><ul><li>将上面部分的盘A-&gt;B</li><li>最下面的盘A-&gt;C</li><li>再将B中的盘B-&gt;C</li></ul></li></ul><h4 id="实现代码-10"><a href="#实现代码-10" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      hanoiTower(<span class="hljs-number">3</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 汉诺塔</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 盘的总数</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> a 第一个塔</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> b 第二个塔</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> c 第三个塔</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoiTower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b, <span class="hljs-keyword">char</span> c)</span> </span>&#123;      <span class="hljs-comment">//如果只有一个盘，把这个盘从A移动到C</span>      <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;         System.out.println(<span class="hljs-string">"把第"</span> + num + <span class="hljs-string">"个盘从"</span> + a + <span class="hljs-string">"-&gt;"</span> + c);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果大于等于两个盘，将上面部分的盘从A借助C移动到B</span>      hanoiTower(num-<span class="hljs-number">1</span>, a, c, b);      <span class="hljs-comment">//把最下面的盘从A移动到C</span>      System.out.println(<span class="hljs-string">"把第"</span> + num + <span class="hljs-string">"个盘从"</span> + a + <span class="hljs-string">"-&gt;"</span> + c);      <span class="hljs-comment">//把上面部分的盘从B借助A移动到C</span>      hanoiTower(num-<span class="hljs-number">1</span>, b, a, c);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">把第<span class="hljs-number">1</span>个盘从A-&gt;C把第<span class="hljs-number">2</span>个盘从A-&gt;B把第<span class="hljs-number">1</span>个盘从C-&gt;B把第<span class="hljs-number">3</span>个盘从A-&gt;C把第<span class="hljs-number">1</span>个盘从B-&gt;A把第<span class="hljs-number">2</span>个盘从B-&gt;C把第<span class="hljs-number">1</span>个盘从A-&gt;C</code></pre><h3 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h3><p>在刷leetcode时有幸看到了一位大佬写的关于递归的博客，在此转载贴出。</p><p><a href="https://lyl0724.github.io/2020/01/25/1/" target="_blank" rel="noopener">点此跳转</a></p><h2 id="2、动态规划"><a href="#2、动态规划" class="headerlink" title="2、动态规划"></a>2、动态规划</h2><h3 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h3><ul><li>动态规划(Dynamic Programming)算法的核心思想是：将<strong>大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li><li>动态规划可以通过<strong>填表</strong>的方式来逐步推进，得到最优解</li></ul><h3 id="算法应用——01背包问题"><a href="#算法应用——01背包问题" class="headerlink" title="算法应用——01背包问题"></a>算法应用——01背包问题</h3><table><thead><tr><th align="center">物品</th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">吉他</td><td align="center">1</td><td align="center">1500</td></tr><tr><td align="center">音响</td><td align="center">4</td><td align="center">3000</td></tr><tr><td align="center">电脑</td><td align="center">3</td><td align="center">2000</td></tr></tbody></table><p>一个背包最多装4kg的东西，求</p><ul><li>装入物品使得背包的总价值最大，且不超出背包的容量</li><li>要求装入的物品<strong>不能重复</strong>（01背包）</li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>算法的主要思想，利用动态规划来解决。每次遍历到的第 i个物品，根据 w[i]和 v[i]来确定是否需要将该物品放入背包中。即对于给定的 n个物品，<strong>设 v[i]、w[i]分别为第 i个物品的价值和重量</strong>，C为背包的容量。再令二维数组</p><pre><code class="hljs markdown">v[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]</code></pre><p>表示在前 i个物品中能够装入容量为 j的背包中的<strong>最大价值</strong>。则我们有下面的结果</p><pre><code class="hljs java"><span class="hljs-comment">//表示填入表的第一行和第一列是 0，主要是为了方便表示物品和容量</span>(<span class="hljs-number">1</span>) v[i][<span class="hljs-number">0</span>]=v[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 当准备加入新增的商品的重量大于当前背包的容量时，就直接使用上一个单元格的装入策略（装入物品的价值）</span>(<span class="hljs-number">2</span>) 当 w[i]&gt;j 时：v[i][j]=v[i-<span class="hljs-number">1</span>][j] <span class="hljs-comment">// 当准备加入的新增的商品的容量小于等于当前背包的容量,</span><span class="hljs-comment">// 装入的方式:</span>(<span class="hljs-number">3</span>) 当 j&gt;=w[i]时：v[i][j]=max&#123;v[i-<span class="hljs-number">1</span>][j], v[i]+v[i-<span class="hljs-number">1</span>][j-w[i]]&#125;v[i-<span class="hljs-number">1</span>][j]：上一个装法的总价值v[i] : 表示当前商品的价值v[i-<span class="hljs-number">1</span>][j-w[i]] ： 装入i-<span class="hljs-number">1</span>商品，到剩余空间j-w[i]的总价值</code></pre><p>简单来说：</p><ul><li><p>装入物品的容量大于背包容量时，直接使用之前装入背包物品的最大价值</p></li><li><p>装入物品容量小于等于背包容量时，比较</p><ul><li>装入该物品之前，背包物品的最大价值</li><li>装入该后，该物品的价值+剩余容量能放入物品的最大价值</li></ul><p>选取较大者</p></li></ul><h4 id="实现代码-11"><a href="#实现代码-11" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//各个物品的重量</span>      <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;      <span class="hljs-comment">//各个物品的价值</span>      <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>&#125;;      <span class="hljs-comment">//背包的最大容量</span>      <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">4</span>;      <span class="hljs-comment">//各种方法的价值的最大值，第0行和第0列值为0，方便后续操作</span>      <span class="hljs-keyword">int</span>[][] maxValue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[value.length+<span class="hljs-number">1</span>][maxSize+<span class="hljs-number">1</span>];      <span class="hljs-comment">//用于表示物品放入背包的方式</span>      <span class="hljs-keyword">int</span>[][] method = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[value.length+<span class="hljs-number">1</span>][maxSize+<span class="hljs-number">1</span>];      <span class="hljs-comment">//依次将物品放入背包</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;maxValue.length; i++) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;maxValue[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-comment">//如果物品的重量大于背包剩余的容量，就不放入</span>            <span class="hljs-comment">//i-1是因为下标是从1开始的，减一后才为0</span>            <span class="hljs-keyword">if</span>(weight[i-<span class="hljs-number">1</span>] &gt; j) &#123;               maxValue[i][j] = maxValue[i-<span class="hljs-number">1</span>][j];            &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">//背包剩余的容量</span>               <span class="hljs-keyword">int</span> remaining = j - weight[i-<span class="hljs-number">1</span>];               <span class="hljs-comment">//如果放入该物品前的最大价值大于放入该物品后的最大价值，就不放入该物品</span>               <span class="hljs-keyword">if</span>(maxValue[i-<span class="hljs-number">1</span>][j] &gt; value[i-<span class="hljs-number">1</span>]+maxValue[i-<span class="hljs-number">1</span>][remaining]) &#123;                  maxValue[i][j] = maxValue[i-<span class="hljs-number">1</span>][j];               &#125; <span class="hljs-keyword">else</span> &#123;                  maxValue[i][j] = value[i-<span class="hljs-number">1</span>]+maxValue[i-<span class="hljs-number">1</span>][remaining];                  <span class="hljs-comment">//存入放入方法</span>                  method[i][j] = <span class="hljs-number">1</span>;               &#125;            &#125;         &#125;      &#125;      <span class="hljs-comment">//打印放入背包的最大价值</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] arr : maxValue) &#123;         System.out.println(Arrays.toString(arr));      &#125;      <span class="hljs-comment">//打印价值最大的放法</span>      <span class="hljs-comment">//存放方法的二维数组的最大下标，从最后开始搜索存放方法</span>      <span class="hljs-keyword">int</span> i = method.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> j = method[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">if</span>(method[i][j] == <span class="hljs-number">1</span>) &#123;            System.out.println(<span class="hljs-string">"将第"</span> + i + <span class="hljs-string">"个物品放入背包"</span>);            <span class="hljs-comment">//背包剩余容量</span>            j -= weight[i-<span class="hljs-number">1</span>];         &#125;         i--;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3500</span>]将第<span class="hljs-number">3</span>个物品放入背包将第<span class="hljs-number">1</span>个物品放入背包</code></pre><h2 id="3、KMP算法"><a href="#3、KMP算法" class="headerlink" title="3、KMP算法"></a>3、KMP算法</h2><p>KMP是一个<strong>解决模式串在文本串是否出现过</strong>，如果出现过，找出最早出现的位置的经典算法</p><h3 id="算法应用——字符串匹配"><a href="#算法应用——字符串匹配" class="headerlink" title="算法应用——字符串匹配"></a>算法应用——字符串匹配</h3><h4 id="思路及图解"><a href="#思路及图解" class="headerlink" title="思路及图解"></a>思路及图解</h4><p><strong>问题：</strong>有一个字符串 str1= BBC ABCDAB ABCDABCDABDE，和一个子串 str2=ABCDABD。现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>首先，用 str1的第一个字符和 str2的<strong>第一个字符去比较，不符合，关键词向后移动一位</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803143823.png" srcset="/img/loading.gif" alt=""></p><ul><li>重复第一步，还是不符合，再后移</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803143912.png" srcset="/img/loading.gif" alt=""></p><ul><li>一直重复，直到 Str1有一个字符与 Str2的<strong>第一个字符符合为止</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803143947.png" srcset="/img/loading.gif" alt=""></p><ul><li>接着比较字符串和搜索词的下一个字符，还是符合</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803144059.png" srcset="/img/loading.gif" alt=""></p><ul><li>遇到 Str1有一个字符与 Str2对应的字符<strong>不符合</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803144203.png" srcset="/img/loading.gif" alt=""></p><p><strong>重要步骤</strong></p><ul><li><p>这时候，想到的是继续遍历 str1的下一个字符，重复第 1步。(其实是很不明智的，因为此时 BCD已经比较过了，<strong>没有必要再做重复的工作</strong>，一个基本事实是，当空格与D不匹配时，<strong>你其实知道前面六个字符是”ABCDAB”</strong></p><ul><li>KMP 算法的想法是：设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</li></ul></li><li><p>怎么做到把刚刚重复的步骤省略掉？可以对 str2计算出一张<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E8%A1%A8%E7%9A%84%E7%94%9F%E6%88%90">部分匹配表</a>，这张表的产生在后面介绍</p><ul><li><p>str2的部分匹配表如下</p><table><thead><tr><th>搜索词</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>部分匹配值</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table></li></ul></li></ul><ul><li><p>已知空格与 D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，<strong>最后一个匹配字符B</strong>对应的<strong>部分匹配值为 2</strong>，因此按照下面的公式算出向后移动的位数：</p><ul><li><strong>移动位数 = 已匹配的字符数 - 对应的部分匹配值</strong></li><li>因为 6 - 2 等于 4，<strong>所以将搜索词向后移动 4 位</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803144832.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803144853.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的<strong>部分匹配值为0</strong>。</p><p>所以，移动位数 = 2 - 0，结果为 2，于是将<strong>搜索词向后移 2 位</strong></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803145044.png" srcset="/img/loading.gif" alt=""></p><ul><li>因为空格与 A不匹配，继续后移一位</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803145118.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803145137.png" srcset="/img/loading.gif" alt=""></p><ul><li>逐位比较，直到发现 C与 D不匹配。于是，移动位数 = 6 - 2，继续<strong>将搜索词向后移动 4 位</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803145251.png" srcset="/img/loading.gif" alt=""></p><ul><li>逐位比较，直到搜索词的最后一位，发现完全匹配，<strong>于是搜索完成</strong>。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803145352.png" srcset="/img/loading.gif" alt=""></p><h4 id="部分匹配表的生成"><a href="#部分匹配表的生成" class="headerlink" title="部分匹配表的生成"></a>部分匹配表的生成</h4><p><strong>前缀与后缀</strong></p><ul><li>前缀：ABCD的前缀为[A, AB, ABC]</li><li>后缀：ABCD的后缀为[BCD, CD, D]</li></ul><p>部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p><ul><li><p>”A”的前缀和后缀都为空集，共有元素的长度为 0；</p></li><li><p>”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0；</p></li><li><p>”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0；</p></li><li><p>”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0；</p></li><li><p>”ABCDA”的前缀为[<strong>A</strong>, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, <strong>A</strong>]，共有元素为”A”，<strong>长度为 1</strong>；</p></li><li><p>”ABCDAB”的前缀为[A, <strong>AB,</strong> ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, <strong>AB</strong>, B]，共有元素为”AB”，<strong>长度为 2</strong>；</p></li><li><p>”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD,D]，共有元素的长度为 0。</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200803184352.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-12"><a href="#实现代码-12" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str1 = <span class="hljs-string">"BBC ABCDAB ABCDABCDABDE"</span>;      String str2 = <span class="hljs-string">"ABCDABD"</span>;<span class="hljs-keyword">int</span> result = getPosition(str1, str2);<span class="hljs-keyword">if</span>(result != -<span class="hljs-number">1</span>) &#123;System.out.print(<span class="hljs-string">"匹配位置是：str1["</span>);System.out.println(result + <span class="hljs-string">"]"</span>);&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">"匹配失败"</span>);&#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    *得到匹配字符串的部分匹配表</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> matchStr 用于匹配的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 部分匹配表</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getTable(String matchStr) &#123;      <span class="hljs-comment">//部分匹配值的数组</span>      <span class="hljs-keyword">int</span>[] sectionTable = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matchStr.length()];      <span class="hljs-comment">//匹配字符串的第一个元素没有前缀与后缀，部分匹配值为0</span>      sectionTable[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;      <span class="hljs-comment">//i用来指向部分匹配字符串末尾的字符，j用来指向开始的字符</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i&lt;matchStr.length(); i++) &#123;         <span class="hljs-comment">//当j&gt;0且前缀后缀不匹配时，使用部分匹配表中前一个表项的值</span>         <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; matchStr.charAt(j) != matchStr.charAt(i)) &#123;            j = sectionTable[j-<span class="hljs-number">1</span>];         &#125;         <span class="hljs-comment">//如果前缀后缀匹配，j向后移，继续比较</span>         <span class="hljs-keyword">if</span>(matchStr.charAt(j) == matchStr.charAt(i)) &#123;            j++;         &#125;         <span class="hljs-comment">//存入匹配值</span>         sectionTable[i] = j;      &#125;      <span class="hljs-keyword">return</span> sectionTable;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 通过KMP算法匹配字符串，若匹配成功，返回第一个字符出现的位置</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> str1 用于匹配的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> str2 要匹配的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 第一个字符出现的位置，没有则返回-1</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPosition</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;      <span class="hljs-comment">//获得str2的部分匹配表</span>      <span class="hljs-keyword">int</span>[] sectionTable = getTable(str2);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;         <span class="hljs-comment">//两个字符匹配</span>         <span class="hljs-keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;            j++;            <span class="hljs-keyword">if</span>(j == str2.length()) &#123;               <span class="hljs-comment">//如果匹配完成，返回第一个字符出现位置</span>               <span class="hljs-keyword">return</span> i - str2.length() + <span class="hljs-number">1</span>;            &#125;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果匹配失败了，使用部分匹配表，跳转到str1对应位置</span>            <span class="hljs-comment">//如果j==0，说明没有字符被被匹配，直接让i指向str1的下一个字符</span>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) &#123;               <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">//跳转步数 = 已经匹配的字符个数 - 部分匹配表对应的值</span>            <span class="hljs-keyword">int</span> position = j - sectionTable[j-<span class="hljs-number">1</span>];            i += position;            <span class="hljs-comment">//因为循环后会+1，所以此处i-1</span>            i--;            <span class="hljs-comment">//重置j，重新匹配</span>            j = <span class="hljs-number">0</span>;         &#125;      &#125;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">匹配位置是：str1[<span class="hljs-number">15</span>]</code></pre><h2 id="4、贪心算法"><a href="#4、贪心算法" class="headerlink" title="4、贪心算法"></a>4、贪心算法</h2><h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><ul><li>贪心算法(贪心算法)是指在对问题进行求解时，<strong>在每一步选择中都采取最好或者最优</strong>（即最有利)的选择，从而</li></ul><p><strong>希望能够导致结果是最好或者最优的算法</strong></p><ul><li>贪心算法所得到的结果<strong>不一定</strong>是最优的结果(有时候会是最优解)，但是都是<strong>相对近似</strong>(接近)最优解的结果</li></ul><h3 id="算法应用——集合覆盖"><a href="#算法应用——集合覆盖" class="headerlink" title="算法应用——集合覆盖"></a>算法应用——集合覆盖</h3><p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号</p><table><thead><tr><th>电台</th><th>覆盖地区个数</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>0</td><td>北京 上海 天津</td></tr><tr><td>K2</td><td>0</td><td>广州 北京 深圳</td></tr><tr><td>K3</td><td>0</td><td>成都 上海 杭州</td></tr><tr><td>K4</td><td>0</td><td>上海 天津</td></tr><tr><td>K5</td><td>0</td><td>杭州 大连</td></tr></tbody></table><h4 id="思路及图解-1"><a href="#思路及图解-1" class="headerlink" title="思路及图解"></a>思路及图解</h4><p><strong>思路</strong></p><ul><li><p>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系</p></li><li><p>将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</p></li><li><p>重复第 1步<strong>直到覆盖了全部的</strong>地区</p></li></ul><p><strong>图解</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200804125936.png" srcset="/img/loading.gif" alt=""></p><ul><li>遍历电台的覆盖地区，发现K1覆盖的地区最多，将K1覆盖的地区从地区集合中移除。然后将K1放入电台集合中，并更新覆盖地区个数</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200804130058.png" srcset="/img/loading.gif" alt=""></p><ul><li>遍历，发现K2覆盖的地区最多，将K2覆盖的地区从地区集合中移除。然后将K2放入电台集合中，并更新覆盖地区个数</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200804130307.png" srcset="/img/loading.gif" alt=""></p><ul><li>遍历，发现K3覆盖的地区最多，将K3覆盖的地区从地区集合中移除。然后将K3放入电台集合中，并更新覆盖地区个数</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200804130445.png" srcset="/img/loading.gif" alt=""></p><ul><li>遍历，发现K5覆盖的地区最多，将K5覆盖的地区从地区集合中移除。然后将K5放入电台集合中，并更新覆盖地区个数。所有区域都被覆盖，算法结束</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200804130608.png" srcset="/img/loading.gif" alt=""></p><h3 id="算法应用——钱币找零"><a href="#算法应用——钱币找零" class="headerlink" title="算法应用——钱币找零"></a>算法应用——钱币找零</h3><p>假设纸币金额为1元、5元、10元、20元、50元、100元</p><p>要凑成123元应该尽可能兑换少的纸币</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><ul><li>尽可能从大面值一直往下减即可</li></ul><h4 id="实现代码-13"><a href="#实现代码-13" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      splitChange(<span class="hljs-number">123</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 拆分零钱</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> money 钱币总金额</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">splitChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;      <span class="hljs-comment">//零钱金额，纸币的种类</span>      <span class="hljs-keyword">int</span>[] prices = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;;      <span class="hljs-comment">//用于记录每种纸币的数量，下标与prices数组的下标对应</span>      <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length];      <span class="hljs-comment">//剩下的金额</span>      <span class="hljs-keyword">int</span> surplus = money;      <span class="hljs-keyword">if</span>(money &gt; <span class="hljs-number">0</span>) &#123;         <span class="hljs-comment">//如果剩下的金额大于0</span>         <span class="hljs-keyword">while</span>(surplus &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//从大金额向小金额进行凑数</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;prices.length; i++) &#123;               <span class="hljs-comment">//每张钱币的数量</span>               <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;               <span class="hljs-comment">//如果该金额的钱币小于总金额，该钱币数量+1</span>               <span class="hljs-keyword">while</span> (surplus - prices[i] &gt;= <span class="hljs-number">0</span>) &#123;                  count++;                  surplus -= prices[i];               &#125;               counts[i] = count;            &#125;         &#125;      &#125;      <span class="hljs-comment">//打印结果</span>      System.out.println(<span class="hljs-string">"凑成"</span> + money +<span class="hljs-string">"元"</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;prices.length; i++) &#123;         <span class="hljs-keyword">if</span>(counts[i] != <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">"需要"</span> + prices[i] + <span class="hljs-string">"元的纸币"</span> + counts[i] + <span class="hljs-string">"张"</span>);         &#125;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">凑成<span class="hljs-number">123</span>元需要<span class="hljs-number">100</span>元的纸币<span class="hljs-number">1</span>张需要<span class="hljs-number">20</span>元的纸币<span class="hljs-number">1</span>张需要<span class="hljs-number">1</span>元的纸币<span class="hljs-number">3</span>张</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p>本博客根据<a href="https://www.bilibili.com/video/av81461839?from=search&seid=8445102345230304010" target="_blank" rel="noopener"><strong>黑马java并发编程教程</strong></a>学习而做的笔记，链接如下</p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 </p><ul><li><p>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication） </p></li><li><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP </p></li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><p><strong>进程切换和线程切换的主要区别</strong></p><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><p><strong>为什么TLB能加快访问速度</strong></p><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p><p>并行是多个CPU同时处理不同的线程。</p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力 </li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li><p>需要等待结果返回，才能继续运行就是同步 </p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><p>1) 设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…<br>2) 结论 </p><ul><li><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p></li><li><p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</p></li><li><p>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p></li></ul><p>结论 </p><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 </p><ul><li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</p></li><li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </p></li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p></li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Thread myThread = <span class="hljs-keyword">new</span> MyThread();        <span class="hljs-comment">// 启动线程</span>myThread.start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"my thread running..."</span>);&#125;&#125;</code></pre><p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程任务</span>Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Runnable running"</span>);&#125;&#125;;<span class="hljs-comment">//将Runnable对象传给Thread</span>Thread t = <span class="hljs-keyword">new</span> Thread(r);<span class="hljs-comment">//启动线程</span>t.start();&#125;&#125;</code></pre><p>或者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread2</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         System.out.println(<span class="hljs-string">"my runnable running..."</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();      Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);      thread.start();   &#125;&#125;</code></pre><p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程任务</span>Runnable r = () -&gt; &#123;            <span class="hljs-comment">//直接写方法体即可</span>System.out.println(<span class="hljs-string">"Runnable running"</span>);System.out.println(<span class="hljs-string">"Hello Thread"</span>);&#125;;<span class="hljs-comment">//将Runnable对象传给Thread</span>Thread t = <span class="hljs-keyword">new</span> Thread(r);<span class="hljs-comment">//启动线程</span>t.start();&#125;&#125;</code></pre><p>可以再Runnable上使用Alt+Enter</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" srcset="/img/loading.gif" alt=""></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了 </li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">//需要传入一个Callable对象</span>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;System.out.println(<span class="hljs-string">"线程执行!"</span>);Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;&#125;&#125;);Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">"t2"</span>);r1.start();<span class="hljs-comment">//获取线程中方法执行后的返回结果</span>System.out.println(task.get());&#125;&#125;</code></pre><p>或</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;      FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCall());      Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);      thread.start();      <span class="hljs-comment">// 获得线程运行后的返回值</span>      System.out.println(futureTask.get());   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"hello world"</span>;   &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong> </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能 </li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>  被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running  进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用  <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//休眠一分钟</span>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);</code></pre></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable  就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span></code></pre></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<span class="hljs-comment">//等待thread线程执行结束</span>thread.join();<span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span>thread.join(<span class="hljs-number">1000</span>);</code></pre><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。 </li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span>t1.isInterrupted();</code></pre><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;        break;    &#125;&#125;</code></pre><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-comment">//判断当前线程是否被打断了</span><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);                        <span class="hljs-comment">//终止线程执行</span><span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();<span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span>Thread.currentThread().interrupt();&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();&#125;&#125;</code></pre><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法   停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);</code></pre><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态 </p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li></ul></li><li><p>【阻塞状态】</p><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 </li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 </li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>NEW</strong>  线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） </li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。 </li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源 <ul><li>多个线程读共享资源其实也没有问题 </li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;       counter++; &#125; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;     counter--; &#125;</code></pre><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock </li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<span class="hljs-comment">//临界区</span>&#125;</code></pre><p>例：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object(); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                    <span class="hljs-keyword">synchronized</span> (room) &#123;             counter++;                    &#125;           &#125;        &#125;, <span class="hljs-string">"t1"</span>);     Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                     <span class="hljs-keyword">synchronized</span> (room) &#123;                        counter--;                      &#125;            &#125;     &#125;, <span class="hljs-string">"t2"</span>);     t1.start();        t2.start();     t1.join();       t2.join();        log.debug(<span class="hljs-string">"&#123;&#125;"</span>,counter); &#125;</code></pre><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在成员方法上</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<span class="hljs-comment">//在方法上加上synchronized关键字</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;&#125;&#125;&#125;</code></pre></li><li><p>加在静态方法上</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span>(Demo<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;&#125;&#125;&#125;</code></pre></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全 </p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必 （要看该对象<strong>是否被共享</strong>且被执行了读写操作）<ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><ul><li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" srcset="/img/loading.gif" alt=""></p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer </li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li><p>它们的每个方法是原子的（都被加上了synchronized）</p></li><li><p>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" srcset="/img/loading.gif" alt=""></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</li><li>如果<strong>已经绑定</strong>，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li><p>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</p></li><li><p>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</p></li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" srcset="/img/loading.gif" alt=""></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" srcset="/img/loading.gif" alt=""></p><ul><li>第二种情况</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" srcset="/img/loading.gif" alt=""></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" srcset="/img/loading.gif" alt=""></p><ul><li>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</li><li>处于BLOCKED和WAITING状态的线程都为<strong>阻塞</strong>状态，CPU都不会分给他们时间片。但是有所区别：<ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><span class="hljs-keyword">synchronized</span> (LOCK) &#123;LOCK.wait();&#125;&#125;&#125;</code></pre><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span>LOCK.wait();&#125;<span class="hljs-comment">//满足条件后再运行</span>&#125;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-comment">//唤醒所有等待线程</span>LOCK.notifyAll();&#125;</code></pre><h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String hello = <span class="hljs-string">"hello thread!"</span>;Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">"想要得到结果"</span>);<span class="hljs-keyword">synchronized</span> (guarded) &#123;System.out.println(<span class="hljs-string">"结果是："</span>+guarded.getResponse());&#125;System.out.println(<span class="hljs-string">"得到结果"</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">"设置结果"</span>);<span class="hljs-keyword">synchronized</span> (guarded) &#123;guarded.setResponse(hello);&#125;&#125;).start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 要返回的结果</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Object response;    <span class="hljs-comment">//优雅地使用wait/notify</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span><span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">this</span>.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span class="hljs-keyword">return</span> response;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<span class="hljs-keyword">this</span>.response = response;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//唤醒休眠的线程</span><span class="hljs-keyword">this</span>.notifyAll();&#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Guarded&#123;"</span> +<span class="hljs-string">"response="</span> + response +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>带超时判断的暂停</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//获取开始时间</span><span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<span class="hljs-comment">//用于保存已经等待了的时间</span><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><span class="hljs-keyword">long</span> waitTime = time -passedTime;<span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//等待剩余时间</span><span class="hljs-keyword">this</span>.wait(waitTime);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//获取当前时间</span>passedTime = System.currentTimeMillis()-currentTime            &#125;&#125;<span class="hljs-keyword">return</span> response;&#125;</code></pre><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> base = System.currentTimeMillis();        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"timeout value is negative"</span>);        &#125;        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                wait(<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                <span class="hljs-keyword">long</span> delay = millis - now;                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                wait(delay);                now = System.currentTimeMillis() - base;            &#125;        &#125;    &#125;</code></pre><h2 id="8、park-unpark"><a href="#8、park-unpark" class="headerlink" title="8、park/unpark"></a>8、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span>LockSupport.park;<span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread);</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"park"</span>);            <span class="hljs-comment">//暂停线程运行</span>LockSupport.park();System.out.println(<span class="hljs-string">"resume"</span>);&#125;, <span class="hljs-string">"t1"</span>);thread.start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"unpark"</span>);    <span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread);&#125;</code></pre><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象<strong>_counter, _cond,__mutex</strong>组成</p><ul><li><p>先调用park再调用unpark时</p><ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的<strong>_counter的值设为0</strong>；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" srcset="/img/loading.gif" alt=""></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" srcset="/img/loading.gif" alt=""></p><h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" srcset="/img/loading.gif" alt=""></p><h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE </li></ul><h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 <ul><li>竞争锁成功，t 线程从  WAITING –&gt; RUNNABLE </li><li>竞争锁失败，t 线程从  WAITING –&gt; BLOCKED </li></ul></li></ul></li></ul><h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul><li><strong>当前线程</strong>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING<ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从  TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从  TIMED_WAITING –&gt; BLOCKED </li></ul></li></ul><h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 t.join<strong>(long n</strong>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING <ul><li>注意是当前线程在t 线程对象的监视器上等待 </li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>当前线程等待时间超过了 n 毫秒，当前线程从  TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING </li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用  synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从  RUNNABLE –&gt; BLOCKED </li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED  的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然  BLOCKED </li></ul><h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;    <span class="hljs-comment">//额外创建对象来作为锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();&#125;</code></pre><h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (A) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">2000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">synchronized</span> (B) &#123;&#125;&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (B) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">synchronized</span> (A) &#123;&#125;&#125;&#125;).start();&#125;</code></pre><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p>jps+jstack ThreadID</p><ul><li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" srcset="/img/loading.gif" alt=""></p></li></ul><pre><code class="hljs angelscript">F:\Thread_study&gt;jps<span class="hljs-number">20672</span> RemoteMavenServer36<span class="hljs-number">22880</span> Jps<span class="hljs-number">4432</span> Launcher<span class="hljs-number">5316</span> Test5<span class="hljs-number">20184</span> KotlinCompileDaemon<span class="hljs-number">11132</span>F:\Thread_study&gt;jstack <span class="hljs-number">5316</span></code></pre></li></ul><ul><li><p>打印的结果</p><pre><code class="hljs java"><span class="hljs-comment">//找到一个java级别的死锁</span>Found one Java-level deadlock:=============================<span class="hljs-string">"Thread-1"</span>:  waiting to lock monitor <span class="hljs-number">0x0000000017f40de8</span> (object <span class="hljs-number">0x00000000d6188880</span>, a java.lang.Object),  which is held by <span class="hljs-string">"Thread-0"</span><span class="hljs-string">"Thread-0"</span>:  waiting to lock monitor <span class="hljs-number">0x0000000017f43678</span> (object <span class="hljs-number">0x00000000d6188890</span>, a java.lang.Object),  which is held by <span class="hljs-string">"Thread-1"</span></code></pre></li></ul><ul><li><p>jconsole检测死锁</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" srcset="/img/loading.gif" alt=""></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" srcset="/img/loading.gif" alt=""></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象</p><h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断 </li><li>可以设置超时时间 </li><li>可以设置为公平锁  (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//加锁</span>lock.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//需要执行的代码</span>&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;</code></pre><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//加锁，可打断锁</span>lock.lockInterruptibly();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();                <span class="hljs-comment">//被打断，返回，不再向下执行</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;&#125;);lock.lock();<span class="hljs-keyword">try</span> &#123;t1.start();Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//打断</span>t1.interrupt();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-comment">//未设置等待时间，一旦获取失败，直接返回false</span><span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;System.out.println(<span class="hljs-string">"获取失败"</span>);                <span class="hljs-comment">//获取失败，不再向下执行，返回</span><span class="hljs-keyword">return</span>;&#125;System.out.println(<span class="hljs-string">"得到了锁"</span>);lock.unlock();&#125;);lock.lock();<span class="hljs-keyword">try</span>&#123;t1.start();Thread.sleep(<span class="hljs-number">3000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><p>设置等待时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span><span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;System.out.println(<span class="hljs-string">"获取失败"</span>);<span class="hljs-comment">//获取失败，不再向下执行，直接返回</span><span class="hljs-keyword">return</span>;&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();<span class="hljs-comment">//被打断，不再向下执行，直接返回</span><span class="hljs-keyword">return</span>;&#125;System.out.println(<span class="hljs-string">"得到了锁"</span>);<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;);lock.lock();<span class="hljs-keyword">try</span>&#123;t1.start();<span class="hljs-comment">//打断等待</span>t1.interrupt();Thread.sleep(<span class="hljs-number">3000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比 </p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息 </li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 </li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//获得条件变量</span>Condition condition = lock.newCondition();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;lock.lock();<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">while</span>(!judge) &#123;System.out.println(<span class="hljs-string">"不满足条件，等待..."</span>);<span class="hljs-comment">//等待</span>condition.await();&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;System.out.println(<span class="hljs-string">"执行完毕！"</span>);lock.unlock();&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;lock.lock();<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1</span>);judge = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//释放</span>condition.signal();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;).start();&#125;</code></pre><h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;               setExclusiveOwnerThread(Thread.currentThread());               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         &#125;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == Thread.currentThread()) &#123;            <span class="hljs-keyword">int</span> state = getState();            compareAndSetState(state, state + <span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;         <span class="hljs-keyword">if</span> (getState() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();         &#125;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();         &#125;         <span class="hljs-keyword">int</span> state = getState();         <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            compareAndSetState(state, <span class="hljs-number">0</span>);         &#125; <span class="hljs-keyword">else</span> &#123;            compareAndSetState(state, state - <span class="hljs-number">1</span>);         &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> getState() &gt;= <span class="hljs-number">1</span>;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();      &#125;   &#125;   Sync sync = <span class="hljs-keyword">new</span> Sync();   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;      sync.acquire(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      sync.acquireInterruptibly(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, time);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;      sync.release(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> sync.newCondition();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;      MyLock lock = <span class="hljs-keyword">new</span> MyLock();      Object syncLock = <span class="hljs-keyword">new</span> Object();      Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;               lock.lock();               <span class="hljs-keyword">try</span> &#123;                  lock.lock();                  <span class="hljs-keyword">try</span> &#123;                     num++;                  &#125; <span class="hljs-keyword">finally</span> &#123;                     lock.unlock();                  &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                  lock.unlock();               &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               lock.unlock();            &#125;         &#125;      &#125;);      Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;               lock.lock();               <span class="hljs-keyword">try</span> &#123;                  lock.lock();                  <span class="hljs-keyword">try</span> &#123;                     num--;                  &#125; <span class="hljs-keyword">finally</span> &#123;                     lock.unlock();                  &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                  lock.unlock();               &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               lock.unlock();            &#125;         &#125;      &#125;);      t1.start();      t2.start();      t1.join();      t2.join();      <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;   &#125;&#125;</code></pre><h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//判断先执行的内容是否执行完毕</span><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-keyword">while</span> (!judge) &#123;<span class="hljs-keyword">try</span> &#123;LOCK.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;System.out.println(<span class="hljs-string">"2"</span>);&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;System.out.println(<span class="hljs-string">"1"</span>);judge = <span class="hljs-keyword">true</span>;               <span class="hljs-comment">//执行完毕，唤醒所有等待线程</span>LOCK.notifyAll();&#125;&#125;).start();&#125;</code></pre><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait/notify版本</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;<span class="hljs-keyword">static</span> Symbol symbol = <span class="hljs-keyword">new</span> Symbol();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;symbol.run(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;symbol.run(<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);&#125;).start();symbol.run(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;&#125;).start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Symbol</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<span class="hljs-keyword">while</span>(flag != <span class="hljs-keyword">this</span>.flag) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">this</span>.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;System.out.println(str);<span class="hljs-comment">//设置下一个运行的线程标记</span><span class="hljs-keyword">this</span>.flag = nextFlag;<span class="hljs-comment">//唤醒所有线程</span><span class="hljs-keyword">this</span>.notifyAll();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程的执行标记， 1-&gt;a 2-&gt;b 3-&gt;c</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFlag</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> flag;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag)</span> </span>&#123;<span class="hljs-keyword">this</span>.flag = flag;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> loopNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<span class="hljs-keyword">this</span>.loopNumber = loopNumber;&#125;&#125;</code></pre><p><strong>await/signal版本</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"a"</span>, conditionA, conditionB);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"b"</span>, conditionB, conditionC);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"c"</span>, conditionC, conditionA);&#125;).start();<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;awaitSignal.lock();<span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//唤醒一个等待的线程</span>conditionA.signal();&#125;<span class="hljs-keyword">finally</span> &#123;awaitSignal.unlock();&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, Condition thisCondition, Condition nextCondition)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;lock();<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//全部进入等待状态</span>thisCondition.await();System.out.print(str);nextCondition.signal();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;unlock();&#125;&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber=<span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> loopNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<span class="hljs-keyword">this</span>.loopNumber = loopNumber;&#125;&#125;</code></pre><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalStudy</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 创建ThreadLocal变量</span>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      ThreadLocal&lt;User&gt; userThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      <span class="hljs-comment">// 创建两个线程，分别使用上面的两个ThreadLocal变量</span>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// stringThreadLocal第一次赋值</span>         stringThreadLocal.set(<span class="hljs-string">"thread1 stringThreadLocal first"</span>);         <span class="hljs-comment">// stringThreadLocal第二次赋值</span>         stringThreadLocal.set(<span class="hljs-string">"thread1 stringThreadLocal second"</span>);         <span class="hljs-comment">// userThreadLocal赋值</span>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Nyima"</span>, <span class="hljs-number">20</span>));         <span class="hljs-comment">// 取值</span>         System.out.println(stringThreadLocal.get());         System.out.println(userThreadLocal.get());                    <span class="hljs-comment">// 移除</span> userThreadLocal.remove(); System.out.println(userThreadLocal.get());      &#125;);      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// stringThreadLocal第一次赋值</span>         stringThreadLocal.set(<span class="hljs-string">"thread2 stringThreadLocal first"</span>);         <span class="hljs-comment">// stringThreadLocal第二次赋值</span>         stringThreadLocal.set(<span class="hljs-string">"thread2 stringThreadLocal second"</span>);         <span class="hljs-comment">// userThreadLocal赋值</span>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Hulu"</span>, <span class="hljs-number">20</span>));         <span class="hljs-comment">// 取值</span>         System.out.println(stringThreadLocal.get());         System.out.println(userThreadLocal.get());      &#125;);      <span class="hljs-comment">// 启动线程</span>      thread1.start();      thread2.start();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;   String name;   <span class="hljs-keyword">int</span> age;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.age = age;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +            <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">", age="</span> + age +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">thread1 stringThreadLocal secondthread2 stringThreadLocal secondUser&#123;name=<span class="hljs-string">'Nyima'</span>, age=<span class="hljs-number">20</span>&#125;User&#123;name=<span class="hljs-string">'Hulu'</span>, age=<span class="hljs-number">20</span>&#125;<span class="hljs-keyword">null</span></code></pre><p>从运行结果可以看出</p><ul><li>每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的<ul><li>从线程1和线程2的打印结果可以看出</li></ul></li><li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul><li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li></ul></li><li>ThreadLocal可以进行以下几个操作<ul><li>set 设置值</li><li>get 取出值</li><li>remove 移除值</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; ... ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 放在后面说</span> ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>; ...&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="hljs-keyword">super</span>(k);            value = v;        &#125;    &#125;</code></pre><p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p><h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-comment">// 获取当前线程</span>    Thread t = Thread.currentThread();        <span class="hljs-comment">// 获得ThreadLocalMap对象 </span>    <span class="hljs-comment">// 这里的get会返回Thread类中的threadLocals</span>    ThreadLocalMap map = getMap(t);        <span class="hljs-comment">// 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// ThreadLocal自生的引用作为key，传入的值作为value</span>        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);&#125;</code></pre><p><strong>如果未创建</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;    <span class="hljs-comment">// 创建的同时设置想放入的值</span>    <span class="hljs-comment">// hreadLocal自生的引用作为key，传入的值作为value</span>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre><p><strong>get方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 获取当前线程</span>    Thread t = Thread.currentThread();<span class="hljs-comment">// 获取当前线程的threadLocals变量</span>    ThreadLocalMap map = getMap(t);        <span class="hljs-comment">// 判断threadLocals是否被初始化了</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 已经初始化则直接返回</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)            T result = (T)e.value;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-comment">// 否则就创建threadLocals</span>    <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 这个方法返回是null</span>    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);        <span class="hljs-comment">// 无论map创建与否，最终value的值都为null</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);    <span class="hljs-keyword">return</span> value;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>remove方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    ThreadLocalMap m = getMap(Thread.currentThread());    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 如果threadLocals已经被初始化，则移除</span>        m.remove(<span class="hljs-keyword">this</span>);&#125;</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p><p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p><h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p><pre><code class="hljs java">Thread.currentThread()</code></pre><p>所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，<strong>它能够让父线程中ThreadLocal的值传给子线程。</strong></p><p>也就是从main所在的线程，传给thread1或thread2</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      InheritableThreadLocal&lt;String&gt; stringInheritable = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();      <span class="hljs-comment">// 主线程赋对上面两个变量进行赋值</span>      stringThreadLocal.set(<span class="hljs-string">"this is threadLocal"</span>);      stringInheritable.set(<span class="hljs-string">"this is inheritableThreadLocal"</span>);      <span class="hljs-comment">// 创建线程</span>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// 获得ThreadLocal中存放的值</span>         System.out.println(stringThreadLocal.get());         <span class="hljs-comment">// 获得InheritableThreadLocal存放的值</span>         System.out.println(stringInheritable.get());      &#125;);      thread1.start();   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java"><span class="hljs-keyword">null</span><span class="hljs-keyword">this</span> is inheritableThreadLocal</code></pre><p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 传入父线程中的一个值，然后直接返回</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">childValue</span><span class="hljs-params">(T parentValue)</span> </span>&#123;        <span class="hljs-keyword">return</span> parentValue;    &#125;  <span class="hljs-comment">// 返回传入线程的inheritableThreadLocals</span>    <span class="hljs-comment">// Thread中有一个inheritableThreadLocals变量</span>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span>    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;    &#125; <span class="hljs-comment">// 创建一个inheritableThreadLocals</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);    &#125;&#125;</code></pre><p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p><h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;    init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"Thread-"</span> + nextThreadNum(), <span class="hljs-number">0</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;   ...        <span class="hljs-comment">// 获得当前线程的，在这里是主线程</span>    Thread parent = currentThread();       ...        <span class="hljs-comment">// 如果父线程的inheritableThreadLocals存在</span>    <span class="hljs-comment">// 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 设置子线程的inheritableThreadLocals</span>        <span class="hljs-keyword">this</span>.inheritableThreadLocals =            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);        <span class="hljs-comment">/* Stash the specified stack size in case the VM cares */</span>    <span class="hljs-keyword">this</span>.stackSize = stackSize;    <span class="hljs-comment">/* Set thread ID */</span>    tid = nextThreadID();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadLocalMap(parentMap);&#125;</code></pre><p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;    Entry[] parentTable = parentMap.table;    <span class="hljs-keyword">int</span> len = parentTable.length;    setThreshold(len);    table = <span class="hljs-keyword">new</span> Entry[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;        Entry e = parentTable[j];        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();            <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 这里调用了 childValue 方法</span>                <span class="hljs-comment">// 该方法会返回parent的值</span>                Object value = key.childValue(e.value);                                Entry c = <span class="hljs-keyword">new</span> Entry(key, value);                <span class="hljs-keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-keyword">null</span>)                    h = nextIndex(h, len);                table[h] = c;                size++;            &#125;        &#125;    &#125;&#125;</code></pre><p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p><p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 </p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-comment">//如果run为真，则一直执行</span>&#125;&#125;).start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"改变run的值为false"</span>);run = <span class="hljs-keyword">false</span>;&#125;</code></pre><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" srcset="/img/loading.gif" alt=""></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" srcset="/img/loading.gif" alt=""></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" srcset="/img/loading.gif" alt=""></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong> </li></ul><pre><code class="hljs java"><span class="hljs-comment">//使用易变关键字</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-comment">//如果run为真，则一直执行</span>&#125;&#125;).start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"改变run的值为false"</span>);run = <span class="hljs-keyword">false</span>;&#125;</code></pre><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li><p>因为使用了<strong>synchronized</strong>关键字</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<span class="hljs-comment">//使用了synchronized关键字</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            print(x);            newLine();        &#125;    &#125;</code></pre></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">//设置标记，用于判断是否被终止了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span>(stop) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);<span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;System.out.println(<span class="hljs-string">"被打断了"</span>);&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();        <span class="hljs-comment">//修改标记</span>stop = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong> </p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong> </p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.nyima.day1;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/3/26 16:11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">//设置标记，用于判断是否被终止了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">if</span> (starting) &#123;<span class="hljs-comment">//已被启动，直接返回</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//启动监视器，改变标记</span>starting = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span>(stop) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);<span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;System.out.println(<span class="hljs-string">"被打断了"</span>);&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();stop = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" srcset="/img/loading.gif" alt=""></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; System.out.println( a + b );<span class="hljs-comment">// 不能重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;</code></pre></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" srcset="/img/loading.gif" alt=""></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul><li>可见性 <ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中 </li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据 </li></ul></li><li>有序性 <ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后 </li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" srcset="/img/loading.gif" alt=""></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" srcset="/img/loading.gif" alt=""></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" srcset="/img/loading.gif" alt=""></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去 </li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p><pre><code class="hljs java">instance = <span class="hljs-keyword">new</span> Singleton();</code></pre><p>对应的汇编代码是</p><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span> lock addl <span class="hljs-string">...</span></code></pre><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p><ul><li>Lock前缀指令会引起处理器<strong>缓存回写到内存</strong><ul><li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li></ul></li><li>一个处理器的缓存回写到内存会<strong>导致其他处理器的缓存无效</strong><ul><li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li></ul></li></ul><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul><li><p>使用<strong>原子整数</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">AtomicInteger balance</span> = new AtomicInteger();</code></pre></li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;account.withdraw(<span class="hljs-number">10</span>);&#125;));&#125;ts.forEach(Thread::start);ts.forEach(t -&gt; &#123;<span class="hljs-keyword">try</span> &#123;t.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);<span class="hljs-keyword">long</span> end = System.nanoTime();System.out.println(account.getBalance() + <span class="hljs-string">" cost: "</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">" ms"</span>);&#125;&#125;<span class="hljs-comment">//线程不安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-keyword">private</span> Integer balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = balance;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;balance -= amount;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));&#125;&#125;<span class="hljs-comment">//线程安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-comment">//使用原子整数</span><span class="hljs-keyword">private</span> AtomicInteger balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//得到原子整数的值</span><span class="hljs-keyword">return</span> balance.get();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//获得修改前的值</span><span class="hljs-keyword">int</span> prev = balance.get();<span class="hljs-comment">//获得修改后的值</span><span class="hljs-keyword">int</span> next = prev-amount;<span class="hljs-comment">//比较并设值</span><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;</code></pre><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" srcset="/img/loading.gif" alt=""></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li><p>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</p></li><li><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><p><strong>注意</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</code></pre><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果 </p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" srcset="/img/loading.gif" alt=""></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </li><li>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </li><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger </li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><pre><code class="hljs java"> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span> <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span> <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span> <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span>System.out.println(i.getAndDecrement()); <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>)); <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>)); <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>)); <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x)); <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));</code></pre><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;account.withdraw(BigDecimal.TEN);&#125;));&#125;ts.forEach(Thread::start);ts.forEach(t -&gt; &#123;<span class="hljs-keyword">try</span> &#123;t.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);<span class="hljs-keyword">long</span> end = System.nanoTime();System.out.println(account.getBalance() + <span class="hljs-string">" cost: "</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">" ms"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<span class="hljs-comment">//原子引用，泛型类型为小数类型</span>AtomicReference&lt;BigDecimal&gt; balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> balance.get();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;BigDecimal pre = balance.get();BigDecimal next = pre.subtract(amount);<span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"10000"</span>)));&#125;&#125;</code></pre><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">"A"</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.get();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C</span>System.out.println(<span class="hljs-string">"change A-&gt;C "</span> + str.compareAndSet(pre, <span class="hljs-string">"C"</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"change A-&gt;B "</span> + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>));&#125;).start();Thread.sleep(<span class="hljs-number">500</span>);<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"change B-&gt;A "</span> + str.compareAndSet(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A"</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" srcset="/img/loading.gif" alt=""></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-comment">//指定版本号</span><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">"A"</span>, <span class="hljs-number">0</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.getReference();<span class="hljs-comment">//获得版本号</span><span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>System.out.println(<span class="hljs-string">"change A-&gt;C stamp "</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">"C"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change A-&gt;B stamp "</span> + stamp + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();Thread.sleep(<span class="hljs-number">500</span>);<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change B-&gt;A stamp "</span> + stamp +  str.compareAndSet(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" srcset="/img/loading.gif" alt=""></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-comment">//指定版本号</span><span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">"A"</span>, <span class="hljs-keyword">true</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.getReference();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>System.out.println(<span class="hljs-string">"change A-&gt;C mark "</span> +  str.compareAndSet(pre, <span class="hljs-string">"C"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;System.out.println(<span class="hljs-string">"change A-&gt;A mark "</span> + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"A"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" srcset="/img/loading.gif" alt=""></p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><p><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</p></li><li><p><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</p></li></ul><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul><li>提供者 <ul><li>无参又返回</li><li>()-&gt;返回结果</li></ul></li><li>方法<ul><li>有参有返回</li><li>(参数一…)-&gt;返回结果</li></ul></li><li>消费者<ul><li>有参无返回</li><li>(参数一…)-&gt;void</li></ul></li></ul><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域  字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdate</li></ul><p>原子更新器用于帮助我们改变某个对象中的某个属性</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Student student = <span class="hljs-keyword">new</span> Student();             <span class="hljs-comment">// 获得原子更新器</span>      <span class="hljs-comment">// 泛型</span>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span>      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");             <span class="hljs-comment">// 修改</span>      updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">"Nyima"</span>);      System.out.println(student);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">volatile</span> String name;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +            <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;</code></pre><h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p><ul><li>拥有属性的类的Class</li><li>属性的Class</li><li>属性的名称</li></ul><p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p><h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; <span class="hljs-function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-title">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass,</span></span><span class="hljs-function"><span class="hljs-params">                                                                Class&lt;W&gt; vclass,</span></span><span class="hljs-function"><span class="hljs-params">                                                                String fieldName)</span> </span>&#123;    <span class="hljs-comment">// 返回了一个AtomicReferenceFieldUpdaterImpl实例</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;        (tclass, vclass, fieldName, Reflection.getCallerClass());&#125;</code></pre><p>从newUpdater方法还并不能看出来具体的初始化过程</p><h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png" srcset="/img/loading.gif" alt=""></p><p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceFieldUpdaterImpl</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReferenceFieldUpdater</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt;</span></code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png" srcset="/img/loading.gif" alt=""></p><p><strong>构造方法</strong></p><pre><code class="hljs java">AtomicReferenceFieldUpdaterImpl(<span class="hljs-keyword">final</span> Class&lt;T&gt; tclass,                                <span class="hljs-keyword">final</span> Class&lt;V&gt; vclass,                                <span class="hljs-keyword">final</span> String fieldName,                                <span class="hljs-keyword">final</span> Class&lt;?&gt; caller) &#123;    <span class="hljs-comment">// 用于保存要被修改的属性</span>    <span class="hljs-keyword">final</span> Field field;        <span class="hljs-comment">// 属性的Class</span>    <span class="hljs-keyword">final</span> Class&lt;?&gt; fieldClass;        <span class="hljs-comment">// field的修饰符</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> modifiers;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 反射获得属性</span>        field = AccessController.doPrivileged(            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;                    <span class="hljs-comment">// tclass为传入的属性的Class，可以通过它来获得属性</span>                    <span class="hljs-keyword">return</span> tclass.getDeclaredField(fieldName);                &#125;            &#125;);                <span class="hljs-comment">// 获得属性的修饰符，主要用于判断</span>        <span class="hljs-comment">// 1、vclass 与 属性确切的类型是否匹配</span>        <span class="hljs-comment">// 2、是否为引用类型</span>        <span class="hljs-comment">// 3、被修改的属性是否加了volatile关键字</span>        modifiers = field.getModifiers();        sun.reflect.misc.ReflectUtil.ensureMemberAccess(            caller, tclass, <span class="hljs-keyword">null</span>, modifiers);        ClassLoader cl = tclass.getClassLoader();        ClassLoader ccl = caller.getClassLoader();        <span class="hljs-keyword">if</span> ((ccl != <span class="hljs-keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;            ((cl == <span class="hljs-keyword">null</span>) || !isAncestor(cl, ccl))) &#123;            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);        &#125;                <span class="hljs-comment">// 获得属性类的Class</span>        fieldClass = field.getType();    &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(pae.getException());    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);    &#125;    <span class="hljs-keyword">if</span> (vclass != fieldClass)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException();    <span class="hljs-keyword">if</span> (vclass.isPrimitive())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Must be reference type"</span>);    <span class="hljs-keyword">if</span> (!Modifier.isVolatile(modifiers))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Must be volatile type"</span>);    <span class="hljs-comment">// Access to protected field members is restricted to receivers only</span>    <span class="hljs-comment">// of the accessing class, or one of its subclasses, and the</span>    <span class="hljs-comment">// accessing class must in turn be a subclass (or package sibling)</span>    <span class="hljs-comment">// of the protected member's defining class.</span>    <span class="hljs-comment">// If the updater refers to a protected field of a declaring class</span>    <span class="hljs-comment">// outside the current package, the receiver argument will be</span>    <span class="hljs-comment">// narrowed to the type of the accessing class.</span> <span class="hljs-comment">// 对类中的属性进行初始化</span>    <span class="hljs-keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;                   tclass.isAssignableFrom(caller) &amp;&amp;                   !isSamePackage(tclass, caller))                  ? caller : tclass;    <span class="hljs-keyword">this</span>.tclass = tclass;    <span class="hljs-keyword">this</span>.vclass = vclass;    <span class="hljs-comment">// 获得偏移量</span>    <span class="hljs-keyword">this</span>.offset = U.objectFieldOffset(field);&#125;</code></pre><p><strong>可以看出，原子引用更新器确实使用了反射</strong></p><h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" srcset="/img/loading.gif" alt=""></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" srcset="/img/loading.gif" alt=""></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" srcset="/img/loading.gif" alt=""></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1] </li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" srcset="/img/loading.gif" alt=""></p><p><strong>累加主要调用以下方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||               !(uncontended = a.cas(v = a.value, v + x)))               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);       &#125;   &#125;</code></pre><p><strong>累加流程图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" srcset="/img/loading.gif" alt=""></p><h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;<span class="hljs-comment">// 通过反射获得Unsafe对象</span>Class unsafeClass = Unsafe<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span>Constructor constructor = unsafeClass.getDeclaredConstructor();<span class="hljs-comment">// 设置为允许访问私有内容</span>constructor.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 创建Unsafe对象</span>Unsafe unsafe = (Unsafe) constructor.newInstance();<span class="hljs-comment">// 创建Person对象</span>Person person = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">// 获得其属性 name 的偏移量</span>Field field = Person.class.getDeclaredField("name");<span class="hljs-keyword">long</span> offset = unsafe.objectFieldOffset(field);<span class="hljs-comment">// 通过unsafe的CAS操作改变值</span>unsafe.compareAndSwapObject(person, offset, <span class="hljs-keyword">null</span>, <span class="hljs-string">"Nyima"</span>);System.out.println(person);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span> <span class="hljs-keyword">volatile</span> String name;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> +<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];    <span class="hljs-comment">/** Cache the hash code for the string */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span>       <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p><strong>ﬁnal 的使用 **<br>发现该类、类中所有属性都是 **ﬁnal</strong> 的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 </li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><p>*<em>保护性拷贝 *</em></p><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;    <span class="hljs-comment">//返回的是一个新的对象</span>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;</code></pre><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);    &#125;</code></pre><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png" srcset="/img/loading.gif" alt=""></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li><li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li><li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,  TimeUnit.SECONDS, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;         threadPool.execute(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;               TimeUnit.SECONDS.sleep(<span class="hljs-number">10000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"任务正在执行!"</span>);         &#125;);      &#125;   &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义线程池</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 自定义阻塞队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 核心线程数</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;   <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 用于指定线程最大存活时间</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> TimeUnit timeUnit;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 工作线程类</span><span class="hljs-comment">    * 内部封装了Thread类，并且添加了一些属性</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;      Runnable task;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;         System.out.println(<span class="hljs-string">"初始化任务"</span>);         <span class="hljs-keyword">this</span>.task = task;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-comment">// 如果有任务就执行</span>         <span class="hljs-comment">// 如果阻塞队列中有任务，就继续执行</span>         <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = blockingQueue.take()) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               System.out.println(<span class="hljs-string">"执行任务"</span>);               task.run();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;               e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;               <span class="hljs-comment">// 任务执行完毕，设为空</span>               System.out.println(<span class="hljs-string">"任务执行完毕"</span>);               task = <span class="hljs-keyword">null</span>;            &#125;         &#125;         <span class="hljs-comment">// 移除任务</span>         <span class="hljs-keyword">synchronized</span> (workers) &#123;            System.out.println(<span class="hljs-string">"移除任务"</span>);            workers.remove(<span class="hljs-keyword">this</span>);         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, TimeUnit timeUnit, <span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;      <span class="hljs-keyword">this</span>.coreSize = coreSize;      <span class="hljs-keyword">this</span>.timeUnit = timeUnit;      blockingQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(capacity);      <span class="hljs-keyword">this</span>.timeout = timeout;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (workers) &#123;         <span class="hljs-comment">// 创建任务</span>         <span class="hljs-comment">// 池中还有空余线程时，可以运行任务</span>         <span class="hljs-comment">// 否则阻塞</span>         <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;            Worker worker = <span class="hljs-keyword">new</span> Worker(task);            workers.add(worker);            worker.start();         &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"线程池中线程已用完，请稍等"</span>);            blockingQueue.put(task);         &#125;      &#125;   &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阻塞队列</span><span class="hljs-comment"> * 用于存放主线程或其他线程产生的任务</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 阻塞队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span>  Deque&lt;T&gt; blockingQueue;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 阻塞队列容量</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 锁</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> ReentrantLock lock;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 条件队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> Condition fullQueue;   <span class="hljs-keyword">private</span> Condition emptyQueue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;      blockingQueue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(capacity);      lock = <span class="hljs-keyword">new</span> ReentrantLock();      fullQueue = lock.newCondition();      emptyQueue = lock.newCondition();      <span class="hljs-keyword">this</span>.capacity = capacity;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取任务的方法</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 加锁</span>      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 如果阻塞队列为空（没有任务），就一直等待</span>         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;               emptyQueue.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-comment">// 获取任务并唤醒生产者线程</span>         T task = blockingQueue.removeFirst();         fullQueue.signalAll();         <span class="hljs-keyword">return</span> task;      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">takeNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;      <span class="hljs-comment">// 转换等待时间</span>      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// awaitNanos会返回剩下的等待时间</span>               nanos = emptyQueue.awaitNanos(nanos);               <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span>) &#123;                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;               &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         T task = blockingQueue.removeFirst();         fullQueue.signalAll();         <span class="hljs-keyword">return</span> task;      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 放入任务的方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> task 放入阻塞队列的任务</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">while</span> (blockingQueue.size() == capacity) &#123;            <span class="hljs-keyword">try</span> &#123;               System.out.println(<span class="hljs-string">"阻塞队列已满"</span>);               fullQueue.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         blockingQueue.add(task);         <span class="hljs-comment">// 唤醒等待的消费者</span>         emptyQueue.signalAll();      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">return</span> blockingQueue.size();      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;&#125;</code></pre><p>实现了一个简单的线程池</p><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png" srcset="/img/loading.gif" alt=""></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><span class="hljs-comment">// runState is stored in the high-order bits</span><span class="hljs-comment">// RUNNING 高3位为111</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// SHUTDOWN 高3位为000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 001</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 010</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 011</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;</code></pre><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-comment">// 并不是所有平台的int都是32位。</span><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><span class="hljs-comment">// CAPACITY 的高3位为 0</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;</code></pre><p>获取线程池状态、线程数量以及合并两个值的操作</p><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><span class="hljs-comment">// 获取运行状态</span><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<span class="hljs-comment">// 获取运行线程数</span><span class="hljs-comment">// 该操作会让高3位为0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<span class="hljs-comment">// 计算ctl新值</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;</code></pre><h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    ...&#125;<span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();</code></pre><h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p><p>也是构造自定义线程池的方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span></span></code></pre><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize = 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li>阻塞队列满了，使用救急线程来执行任务<ul><li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ul></li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png" srcset="/img/loading.gif" alt=""></p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-keyword">static</span> AtomicInteger threadId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 手动创建线程池</span>      <span class="hljs-comment">// 创建有界阻塞队列</span>      ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 创建线程工厂</span>      ThreadFactory threadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;            Thread thread = <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">"working_thread_"</span>+threadId.getAndIncrement());            <span class="hljs-keyword">return</span> thread;         &#125;      &#125;;      <span class="hljs-comment">// 手动创建线程池</span>      <span class="hljs-comment">// 拒绝策略采用默认策略</span>      ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;         executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;               System.out.println(Thread.currentThread());               <span class="hljs-keyword">try</span> &#123;                  Thread.sleep(<span class="hljs-number">100000</span>);               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                  e.printStackTrace();               &#125;            &#125;         &#125;);      &#125;   &#125;&#125;</code></pre><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFixedThreadPool</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 自定义线程工厂</span>      ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;         AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">"myThread_"</span> + atomicInteger.getAndIncrement());         &#125;      &#125;;      <span class="hljs-comment">// 创建核心线程数量为2的线程池</span>      <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span>      ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>, factory);      <span class="hljs-comment">// 任务</span>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(Thread.currentThread().getName());            System.out.println(<span class="hljs-string">"this is fixedThreadPool"</span>);         &#125;      &#125;;            executorService.execute(runnable);   &#125;&#125;</code></pre><p>固定大小的线程池可以传入两个参数</p><ul><li>核心线程数：nThreads</li><li>线程工厂：threadFactory</li></ul><p>内部调用的构造方法</p><pre><code class="hljs java">ThreadPoolExecutor(nThreads, nThreads,                              <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                              <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                              threadFactory);</code></pre><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><pre><code class="hljs java">ExecutorService executorService = Executors.newCachedThreadPool();</code></pre><p><strong>内部构造方法</strong></p><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</code></pre><ul><li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p></li><li><p>阻塞队列使用的是SynchronousQueue</p><ul><li><strong>SynchronousQueue</strong>是一种特殊的队列<ul><li><strong>没有容量</strong>，没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li></ul></li></ul><h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><pre><code class="hljs java">ExecutorService service = Executors.newSingleThreadExecutor();</code></pre><p><strong>内部构造方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService    (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                            <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                            <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</code></pre><p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p><h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul><li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p><ul><li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li></ul></li><li><p>SingleThread和newFixedThreadPool(1)的区别</p><ul><li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<span class="hljs-comment">// 改变核心线程数</span>threadPool.setCorePoolSize(<span class="hljs-number">2</span>);</code></pre><ul><li>而SingleThread无法修改核心线程数</li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><pre><code class="hljs java">execute(Runnable command)</code></pre><p>传入一个Runnable对象，执行其中的run方法</p><p><strong>源码解析</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 获取ctl</span>    <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-comment">// 判断当前启用的线程数是否小于核心线程数</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-comment">// 为该任务分配线程</span>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))            <span class="hljs-comment">// 分配成功就返回</span>            <span class="hljs-keyword">return</span>;                <span class="hljs-comment">// 分配失败再次获取ctl</span>        c = ctl.get();    &#125;        <span class="hljs-comment">// 分配和信息线程失败以后</span>    <span class="hljs-comment">// 如果池状态为RUNNING并且插入到任务队列成功</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;                <span class="hljs-comment">// 双重检测，可能在添加后线程池状态变为了非RUNNING</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();                <span class="hljs-comment">// 如果池状态为非RUNNING，则不会执行新来的任务</span>        <span class="hljs-comment">// 将该任务从阻塞队列中移除</span>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            <span class="hljs-comment">// 调用拒绝策略，拒绝该任务的执行</span>            reject(command);                <span class="hljs-comment">// 如果没有正在运行的线程</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            <span class="hljs-comment">// 就创建新线程来执行该任务</span>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;        <span class="hljs-comment">// 如果添加失败了（任务队列已满），就调用拒绝策略</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre><p>其中调用了<strong>addWoker()</strong>方法，再看看看这个方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    retry:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// Check if queue empty only if necessary.</span>        <span class="hljs-comment">// 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;               ! workQueue.isEmpty()))            <span class="hljs-comment">// 创建新线程失败</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 获得当前工作线程数</span>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);            <span class="hljs-comment">// 参数中 core 为true</span>            <span class="hljs-comment">// CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span>            <span class="hljs-comment">// 如果工作线程数大于了核心线程数，则创建失败</span>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 通过CAS操作改变c的值</span>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-comment">// 更改成功就跳出多重循环，且不再运行循环</span>                <span class="hljs-keyword">break</span> retry;            <span class="hljs-comment">// 更改失败，重新获取ctl的值</span>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-comment">// 跳出多重循环，且重新进入循环</span>                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-comment">// 用于标记work中的任务是否成功执行</span>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 用于标记worker是否成功加入了线程池中</span>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 创建新线程来执行任务</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            <span class="hljs-comment">// 加锁</span>            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Recheck while holding lock.</span>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                <span class="hljs-comment">// shut down before lock acquired.</span>                <span class="hljs-comment">// 加锁的同时再次检测</span>                <span class="hljs-comment">// 避免在释放锁之前调用了shut down</span>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">// 将线程添加到线程池中</span>                    workers.add(w);                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    <span class="hljs-comment">// 添加成功标志位变为true</span>                    workerAdded = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-comment">// 如果worker成功加入了线程池，就执行其中的任务</span>            <span class="hljs-keyword">if</span> (workerAdded) &#123;                t.start();                <span class="hljs-comment">// 启动成功</span>                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 如果执行失败</span>        <span class="hljs-keyword">if</span> (! workerStarted)            <span class="hljs-comment">// 调用添加失败的函数</span>            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre><h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><pre><code class="hljs java"><span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span></code></pre><p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p><p><strong>使用</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><span class="hljs-comment">// 通过Future来捕获返回值</span>Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"hello submit"</span>;   &#125;&#125;);<span class="hljs-comment">// 查看捕获的返回值</span>System.out.println(future.get());</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 将线程池的状态改为 SHUTDOWN</span><span class="hljs-comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();                <span class="hljs-comment">// 修改线程池状态为 SHUTDOWN</span>        advanceRunState(SHUTDOWN);          <span class="hljs-comment">// 中断空闲线程（没有执行任务的线程）</span>        <span class="hljs-comment">// Idle：空闲的</span>        interruptIdleWorkers();        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">// 尝试终结，不一定成功</span>    <span class="hljs-comment">// </span>    tryTerminate();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-comment">// 终结失败的条件</span>        <span class="hljs-comment">// 线程池状态为RUNNING</span>        <span class="hljs-comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span>        <span class="hljs-comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span>        <span class="hljs-keyword">if</span> (isRunning(c) ||            runStateAtLeast(c, TIDYING) ||            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span>;                <span class="hljs-comment">// 如果活跃线程数不为0</span>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span>            <span class="hljs-comment">// 中断空闲线程</span>            interruptIdleWorkers(ONLY_ONE);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 处于可以终结的状态</span>            <span class="hljs-comment">// 通过CAS将线程池状态改为TIDYING</span>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;                <span class="hljs-keyword">try</span> &#123;                    terminated();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 通过CAS将线程池状态改为TERMINATED</span>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));                    termination.signalAll();                &#125;                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        <span class="hljs-comment">// else retry on failed CAS</span>    &#125;&#125;</code></pre><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 将线程池的状态改为 STOP</span><span class="hljs-comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><span class="hljs-comment">* 会将阻塞队列中未执行的任务返回给调用者</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;    List&lt;Runnable&gt; tasks;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();                <span class="hljs-comment">// 修改状态为STOP，不执行任何任务</span>        advanceRunState(STOP);                <span class="hljs-comment">// 中断所有线程</span>        interruptWorkers();                <span class="hljs-comment">// 将未执行的任务从队列中移除，然后返回给调用者</span>        tasks = drainQueue();    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span>    tryTerminate();    <span class="hljs-keyword">return</span> tasks;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <url>/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><p>本博客根据<a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=2" target="_blank" rel="noopener"><strong>黑马Redis教程</strong></a>学习而做的笔记，链接如下</p><h2 id="一、Redis常用指令"><a href="#一、Redis常用指令" class="headerlink" title="一、Redis常用指令"></a>一、Redis常用指令</h2><pre><code class="hljs awk"><span class="hljs-regexp">//</span>启动容器docker run -d -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -it   --name=<span class="hljs-string">"myredis"</span>  redis输入密码：auth 密码<span class="hljs-regexp">//</span>进入redis容器docker exec -it myredis  redis-cli<span class="hljs-regexp">//</span>退出quit<span class="hljs-keyword">exit</span><span class="hljs-regexp">//</span>清屏clear<span class="hljs-regexp">//</span>获取帮助, 可以使用Tab键来切换help 命令名称help @组名</code></pre><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p><strong>所有的key都为String类型，讨论数据类型是说的value的类型</strong></p><h3 id="1、String"><a href="#1、String" class="headerlink" title="1、String"></a>1、String</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs q"><span class="hljs-comment">//设置String</span><span class="hljs-built_in">set</span> <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span>mset key1 value1 key2 value2...<span class="hljs-comment">//设置生命周期</span>setex <span class="hljs-built_in">key</span> seconds <span class="hljs-built_in">value</span> <span class="hljs-comment">//得到String</span><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span> mget key1 key2...<span class="hljs-comment">//删除String</span>del <span class="hljs-built_in">key</span><span class="hljs-comment">//向字符串的后面追加字符，如果有就补在后面，如果没有就新建</span>append <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span></code></pre><h4 id="string-类型数据的扩展操作"><a href="#string-类型数据的扩展操作" class="headerlink" title="string 类型数据的扩展操作"></a>string 类型数据的扩展操作</h4><p> <strong>String作为数值的操作</strong></p><pre><code class="hljs gauss"><span class="hljs-comment">//增长指令，只有当value为数字时才能增长</span>incr <span class="hljs-built_in">key</span>  incrby <span class="hljs-built_in">key</span> increment  incrbyfloat <span class="hljs-built_in">key</span> increment <span class="hljs-comment">//减少指令，有当value为数字时才能减少</span>decr <span class="hljs-built_in">key</span>  decrby <span class="hljs-built_in">key</span> increment</code></pre><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。 </li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。 </li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。                 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p><strong>tips：</strong></p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong> </li><li>此方案适用于所有数据库，且支持数据库集群</li></ul><p><strong>指定生命周期</strong></p><pre><code class="hljs q"><span class="hljs-comment">//设置数据的生命周期，单位 秒</span>setex <span class="hljs-built_in">key</span> seconds <span class="hljs-built_in">value</span><span class="hljs-comment">//设置数据的生命周期，单位 毫秒</span>psetex <span class="hljs-built_in">key</span> milliseconds <span class="hljs-built_in">value</span></code></pre><p><strong>tips</strong></p><ul><li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 </li></ul><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142355.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、Hash"><a href="#2、Hash" class="headerlink" title="2、Hash"></a>2、Hash</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142425.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs q"><span class="hljs-comment">//插入（如果已存在同名的field，会被覆盖）</span>hset <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span>hmset <span class="hljs-built_in">key</span> field1 value1 field2 value2...<span class="hljs-comment">//插入（如果已存在同名的field，不会被覆盖）</span>hsetnx <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><span class="hljs-comment">//取出</span>hget <span class="hljs-built_in">key</span> fieldhgetall <span class="hljs-built_in">key</span><span class="hljs-comment">//删除</span><span class="hljs-built_in">hdel</span> <span class="hljs-built_in">key</span> field1 field2...<span class="hljs-comment">//获取field数量</span>hlen <span class="hljs-built_in">key</span><span class="hljs-comment">//查看是否存在</span>hexists <span class="hljs-built_in">key</span> field<span class="hljs-comment">//获取哈希表中所有的字段名或字段值 </span>hkeys <span class="hljs-built_in">key</span>hvals <span class="hljs-built_in">key</span><span class="hljs-comment">//设置指定字段的数值数据增加指定范围的值 </span>hincrby <span class="hljs-built_in">key</span> field increment hdecrby <span class="hljs-built_in">key</span> field increment</code></pre><h4 id="hash-类型数据操作的注意事项"><a href="#hash-类型数据操作的注意事项" class="headerlink" title="hash 类型数据操作的注意事项"></a>hash 类型数据操作的注意事项</h4><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong> </li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈 </li></ul><h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 </li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 </li><li>list类型：保存多个数据，底层使用双向链表存储结构实现 </li><li><strong>元素有序，且可重</strong></li></ul><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs tcl">//添加修改数据,lpush为从左边添加，rpush为从右边添加lpush key value1 value2 value3...rpush key value1 value2 value3...//查看数据, 从左边开始向右查看. 如果不知道<span class="hljs-keyword">list</span>有多少个元素，end的值可以为<span class="hljs-number">-1</span>,代表倒数第一个元素//lpush先进的元素放在最后,rpush先进的元素放在最前面<span class="hljs-keyword">lrange</span> key start end//得到长度llen key//取出对应索引的元素<span class="hljs-keyword">lindex</span> key index//获取并移除元素（从<span class="hljs-keyword">list</span>左边或者右边移除）lpop keyrpop key</code></pre><h4 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs gams"><span class="hljs-comment">//规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><span class="hljs-function"><span class="hljs-title">blpop</span></span> key1 key2... timeout<span class="hljs-function"><span class="hljs-title">brpop</span></span> key1 key2... timeout<span class="hljs-comment">//移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span>lrem key count value</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。 </li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作 </li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载 </li></ul><h3 id="4、Set"><a href="#4、Set" class="headerlink" title="4、Set"></a>4、Set</h3><ul><li><strong>不重复且无序</strong></li></ul><h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs gauss"><span class="hljs-comment">//添加元素</span>sadd <span class="hljs-built_in">key</span> member1 member2...<span class="hljs-comment">//查看元素</span>smembers <span class="hljs-built_in">key</span><span class="hljs-comment">//移除元素</span>srem <span class="hljs-built_in">key</span> member<span class="hljs-comment">//查看元素个数</span>scard <span class="hljs-built_in">key</span><span class="hljs-comment">//查看某个元素是否存在</span>sismember <span class="hljs-built_in">key</span> member</code></pre><h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><pre><code class="hljs gams"><span class="hljs-comment">//从set中任意选出count个元素</span>srandmember key count<span class="hljs-comment">//从set中任意选出count个元素并移除</span>spop key count<span class="hljs-comment">//求两个集合的交集、并集、差集</span><span class="hljs-function"><span class="hljs-title">sinter</span></span> key1 key2...<span class="hljs-function"><span class="hljs-title">sunion</span></span> key1 key2...<span class="hljs-function"><span class="hljs-title">sdiff</span></span> key1 key2...<span class="hljs-comment">//求两个set的交集、并集、差集，并放入另一个set中</span><span class="hljs-function"><span class="hljs-title">sinterstore</span></span> destination key1 key2...<span class="hljs-function"><span class="hljs-title">sunionstore</span></span> destination key1 key2...<span class="hljs-function"><span class="hljs-title">sdiffstore</span></span> destination key1 key2...<span class="hljs-comment">//求指定元素从原集合放入目标集合中</span>smove source destination key</code></pre><h3 id="5、sorted-set"><a href="#5、sorted-set" class="headerlink" title="5、sorted_set"></a>5、sorted_set</h3><ul><li><p><strong>不重但有序（score）</strong></p></li><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式 </p></li><li><p>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据 </p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段 </p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142442.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs sql">//插入元素, 需要指定score(用于排序)zadd key score1 member1 score2 member2//查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来zrange key <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)//查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来zrevrange <span class="hljs-keyword">key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)//移除元素zrem <span class="hljs-keyword">key</span> member1 member2...//按条件获取数据, 其中<span class="hljs-keyword">offset</span>为索引开始位置，<span class="hljs-keyword">count</span>为获取的数目zrangebyscore <span class="hljs-keyword">key</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span> [withscore] [<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> <span class="hljs-keyword">count</span>]zrevrangebyscore <span class="hljs-keyword">key</span> <span class="hljs-keyword">max</span> <span class="hljs-keyword">min</span> [withscore] [<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> <span class="hljs-keyword">count</span>]//按条件移除元素zremrangebyrank <span class="hljs-keyword">key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>zremrangebysocre <span class="hljs-keyword">key</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>//按照从大到小的顺序移除<span class="hljs-keyword">count</span>个值zpopmax <span class="hljs-keyword">key</span> [<span class="hljs-keyword">count</span>]//按照从小到大的顺序移除<span class="hljs-keyword">count</span>个值zpopmin <span class="hljs-keyword">key</span> [<span class="hljs-keyword">count</span>]//获得元素个数zcard <span class="hljs-keyword">key</span>//获得元素在范围内的个数zcount <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>//求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目zinterstore destination numkeys key1 key2...zunionstore destination numkeys key1 key2...</code></pre><p><strong>注意</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong> </li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引 </li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong> </li></ul><h4 id="拓展操作-1"><a href="#拓展操作-1" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs maxima">//查看某个元素的索引(排名)zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>//查看某个元素索引的值zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>//增加某个元素索引的值zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992 </li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong> </li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果 </li></ul><h2 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h2><h3 id="1、Key的特征"><a href="#1、Key的特征" class="headerlink" title="1、Key的特征"></a>1、Key的特征</h3><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据 </li></ul><h3 id="2、Key的操作"><a href="#2、Key的操作" class="headerlink" title="2、Key的操作"></a>2、Key的操作</h3><h4 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs gauss"><span class="hljs-comment">//查看key是否存在</span>exists <span class="hljs-built_in">key</span><span class="hljs-comment">//删除key</span>del <span class="hljs-built_in">key</span><span class="hljs-comment">//查看key的类型</span><span class="hljs-built_in">type</span> <span class="hljs-built_in">key</span></code></pre><h4 id="拓展操作（时效性操作）"><a href="#拓展操作（时效性操作）" class="headerlink" title="拓展操作（时效性操作）"></a>拓展操作（时效性操作）</h4><pre><code class="hljs gauss"><span class="hljs-comment">//设置生命周期</span>expire <span class="hljs-built_in">key</span> secondspexpire <span class="hljs-built_in">key</span> milliseconds<span class="hljs-comment">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span>ttl <span class="hljs-built_in">key</span>pttl <span class="hljs-built_in">key</span><span class="hljs-comment">//将有时限的数据设置为永久有效</span>persist <span class="hljs-built_in">key</span></code></pre><h4 id="拓展操作（查询操作）"><a href="#拓展操作（查询操作）" class="headerlink" title="拓展操作（查询操作）"></a>拓展操作（查询操作）</h4><pre><code class="hljs q"><span class="hljs-comment">//根据key查询符合条件的数据</span><span class="hljs-built_in">keys</span> pattern</code></pre><p><strong>查询规则</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142500.png" srcset="/img/loading.gif" alt=""></p><h4 id="拓展操作（其他操作）"><a href="#拓展操作（其他操作）" class="headerlink" title="拓展操作（其他操作）"></a>拓展操作（其他操作）</h4><pre><code class="hljs haxe"><span class="hljs-comment">//重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span>rename key <span class="hljs-keyword">new</span><span class="hljs-type">Key</span><span class="hljs-type">renamenx</span> key <span class="hljs-keyword">new</span><span class="hljs-type">Key</span><span class="hljs-type"></span><span class="hljs-type"></span>//查看所有关于key的操作, 可以使用Tab快速切换help @generic</code></pre><h3 id="3、数据库通用操作"><a href="#3、数据库通用操作" class="headerlink" title="3、数据库通用操作"></a>3、数据库通用操作</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>Redis为每个服务提供有16个数据库，编号从0到15 </li><li>每个数据库之间的数据相互独立 </li></ul><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>切换数据库 0~15select index<span class="hljs-string">//</span>其他操作<span class="hljs-keyword">quit</span>ping<span class="hljs-keyword">echo</span> massage</code></pre><h4 id="拓展操作-2"><a href="#拓展操作-2" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs stata"><span class="hljs-comment">//移动数据, 必须保证目的数据库中没有该数据</span><span class="hljs-keyword">mov</span> key <span class="hljs-keyword">db</span><span class="hljs-comment">//查看该库中数据总量</span>dbsize</code></pre><h2 id="三、Jedis"><a href="#三、Jedis" class="headerlink" title="三、Jedis"></a>三、Jedis</h2><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p><h3 id="1、Java操作redis的步骤"><a href="#1、Java操作redis的步骤" class="headerlink" title="1、Java操作redis的步骤"></a>1、Java操作redis的步骤</h3><ul><li>连接Redis</li></ul><pre><code class="hljs java"><span class="hljs-comment">//参数为Redis所在的ip地址和端口号</span>Jedis jedis = <span class="hljs-keyword">new</span> Jedis(String host, <span class="hljs-keyword">int</span> port)</code></pre><ul><li>操作Redis</li></ul><pre><code class="hljs java"><span class="hljs-comment">//操作redis的指令和redis本身的指令几乎一致</span>jedis.set(String key, String value);</code></pre><ul><li>断开连接</li></ul><pre><code class="hljs java">jedis.close();</code></pre><h3 id="2、配置工具"><a href="#2、配置工具" class="headerlink" title="2、配置工具"></a>2、配置工具</h3><ul><li>配置文件</li></ul><pre><code class="hljs properties"><span class="hljs-meta">redis.host</span>=<span class="hljs-string">47.103.10.63</span><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">redis.maxTotal</span>=<span class="hljs-string">30</span><span class="hljs-meta">redis.maxIdle</span>=<span class="hljs-string">10</span></code></pre><ul><li>工具类</li></ul><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<span class="hljs-keyword">import</span> java.util.ResourceBundle;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/4/6 16:24</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis jedis = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<span class="hljs-comment">//使用静态代码块，只加载一次</span><span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">//读取配置文件</span>ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="hljs-string">"redis"</span>);<span class="hljs-comment">//获取配置文件中的数据</span>host = resourceBundle.getString(<span class="hljs-string">"redis.host"</span>);port = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.port"</span>));<span class="hljs-comment">//读取最大连接数</span>maxTotal = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.maxTotal"</span>));<span class="hljs-comment">//读取最大活跃数</span>maxIdle = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.maxIdle"</span>));JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();jedisPoolConfig.setMaxTotal(maxTotal);jedisPoolConfig.setMaxIdle(maxIdle);<span class="hljs-comment">//获取连接池</span>JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port);jedis = jedisPool.getResource();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> jedis;&#125;&#125;</code></pre><h2 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h2><h3 id="Redis容器配置redis-conf"><a href="#Redis容器配置redis-conf" class="headerlink" title="Redis容器配置redis.conf"></a>Redis容器配置redis.conf</h3><ul><li><p>redis容器里边的配置文件是需要在<strong>创建容器时映射</strong>进来的 </p><pre><code class="hljs axapta">停止容器：docker <span class="hljs-keyword">container</span> stop myredis删除容器：docker <span class="hljs-keyword">container</span> rm myredis</code></pre></li><li><p>重新开始创建容器</p><pre><code class="hljs groovy"><span class="hljs-number">1.</span> 创建docker统一的外部配置文件mkdir -p docker<span class="hljs-regexp">/redis/</span>&#123;conf,data&#125;<span class="hljs-number">2.</span> 在conf目录创建redis.conf的配置文件touch <span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<span class="hljs-number">3.</span> redis.conf文件的内容需要自行去下载，网上很多<span class="hljs-number">4.</span> 创建启动容器，加载配置文件并持久化数据docker run -d --privileged=<span class="hljs-literal">true</span> -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v <span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.<span class="hljs-string">conf:</span><span class="hljs-regexp">/etc/</span>redis<span class="hljs-regexp">/redis.conf -v /</span>docker<span class="hljs-regexp">/redis/</span><span class="hljs-string">data:</span><span class="hljs-regexp">/data --name myredis redis redis-server /</span>etc<span class="hljs-regexp">/redis/</span>redis.conf --appendonly yes</code></pre></li><li><p>文件目录</p><pre><code class="hljs awk"><span class="hljs-regexp">/docker/</span>redis</code></pre></li></ul><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h4><p>利用<strong>永久性</strong>存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。 </p><h4 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h4><p><strong>防止</strong>数据的意外<strong>丢失</strong>，确保数据<strong>安全性</strong> </p><h4 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h4><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong> </li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong> </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142523.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h3><h4 id="RDB启动方式——save"><a href="#RDB启动方式——save" class="headerlink" title="RDB启动方式——save"></a>RDB启动方式——save</h4><ul><li><p>命令</p><pre><code class="hljs ebnf"><span class="hljs-attribute">save</span></code></pre></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><h4 id="RDB配置相关命令"><a href="#RDB配置相关命令" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li>dbfilename dump.rdb <ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb </li><li>经验：通常设置为dump-端口号.rdb</li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径 </li><li>经验：通常设置成存储空间较大的目录中，目录名称data </li></ul></li><li>rdbcompression yes <ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 </li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大） </li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 </li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险 </li></ul></li></ul><h4 id="RDB启动方式——save指令工作原理"><a href="#RDB启动方式——save指令工作原理" class="headerlink" title="RDB启动方式——save指令工作原理"></a>RDB启动方式——save指令工作原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142541.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：<strong>save指令</strong>的执行会<strong>阻塞</strong>当前Redis服务器，直到当前RDB过程完成为止，有可能会造成<strong>长时间阻塞</strong>，线上环境<strong>不建议使用</strong>。   </p><h4 id="RDB启动方式——bgsave"><a href="#RDB启动方式——bgsave" class="headerlink" title="RDB启动方式——bgsave"></a>RDB启动方式——bgsave</h4><ul><li><p>命令</p><pre><code class="hljs ebnf"><span class="hljs-attribute">bgsave</span></code></pre></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong> </p></li></ul><h4 id="RDB启动方式-——-bgsave指令工作原理"><a href="#RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="RDB启动方式 —— bgsave指令工作原理"></a>RDB启动方式 —— bgsave指令工作原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142558.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>： <strong>bgsave命令</strong>是针对save阻塞问题做的<strong>优化</strong>。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用，推荐使用bgsave</p><p><strong>bgsave的保存操作可以通过redis的日志查看</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker logs myredis</span></code></pre><h4 id="RDB启动方式-——save配置"><a href="#RDB启动方式-——save配置" class="headerlink" title="RDB启动方式 ——save配置"></a>RDB启动方式 ——save配置</h4><ul><li><p>配置</p><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes</code></pre></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化 </p></li><li><p>参数</p><ul><li>second：监控时间范围 </li><li>changes：监控key的变化量 </li></ul></li><li><p>配置位置</p><p>在<strong>conf文件</strong>中进行配置 </p></li></ul><h4 id="RDB启动方式-——save配置原理"><a href="#RDB启动方式-——save配置原理" class="headerlink" title="RDB启动方式 ——save配置原理"></a>RDB启动方式 ——save配置原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142617.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系 </li><li>save配置启动后执行的是<strong>bgsave操作</strong> </li></ul><h4 id="RDB启动方式对比"><a href="#RDB启动方式对比" class="headerlink" title="RDB启动方式对比"></a>RDB启动方式对比</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142629.png" srcset="/img/loading.gif" alt=""></p><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong> </li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景 </li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong> </li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象 </li></ul></li></ul><h3 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h3><h4 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h4><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程  </li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式 </li></ul><h4 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142645.png" srcset="/img/loading.gif" alt=""></p><h4 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h4><ul><li>always<ul><li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li></ul></li><li>everysec<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置 </li><li>在系统突然宕机的情况下丢失1秒内的数据 </li></ul></li><li>no<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong> </li></ul></li></ul><h4 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h4><ul><li><p>配置</p><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span></code></pre><ul><li>​    作用<ul><li>是否开启AOF持久化功能，<strong>默认为不开启状态</strong> </li></ul></li></ul></li><li><p>配置</p><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span></code></pre><ul><li>作用<ul><li>AOF写数据策略 </li></ul></li></ul></li></ul><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率 </li><li>提高持久化效率，降低持久化写时间，提高IO性能 </li><li>降低数据恢复用时，提高数据恢复效率 </li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>进程内已超时的数据不再写入文件 </li><li>忽略<strong>无效指令</strong>，重写时使用进程内数据直接生成，这样新的AOF文件<strong>只保留最终数据的写入命令</strong><ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 </li></ul></li><li>对同一数据的多条写命令合并为一条命令 <ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 </li></ul></li></ul><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>手动重写</p><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span></code></pre></li><li><p>自动重写</p><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-<span class="hljs-built_in">min</span>-<span class="hljs-built_in">size</span> <span class="hljs-built_in">size</span> <span class="hljs-keyword">auto</span>-aof-rewrite-percentage percentage</code></pre></li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142657.png" srcset="/img/loading.gif" alt=""></p><h5 id="AOF自动重写"><a href="#AOF自动重写" class="headerlink" title="AOF自动重写"></a>AOF自动重写</h5><ul><li><p>自动重写触发条件设置 </p><pre><code class="hljs arduino"><span class="hljs-comment">//触发重写的最小大小</span><span class="hljs-keyword">auto</span>-aof-rewrite-<span class="hljs-built_in">min</span>-<span class="hljs-built_in">size</span> <span class="hljs-built_in">size</span> <span class="hljs-comment">//触发重写须达到的最小百分比</span><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percent</code></pre></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） </p><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>当前<span class="hljs-string">.aof</span>的文件大小aof_current_size <span class="hljs-string">//</span>基础文件大小aof_base_size</code></pre></li><li><p>自动重写触发条件 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png" srcset="/img/loading.gif" alt=""></p></li></ul><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142734.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142755.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142814.png" srcset="/img/loading.gif" alt=""></p><h5 id="缓冲策略"><a href="#缓冲策略" class="headerlink" title="缓冲策略"></a>缓冲策略</h5><p> AOF缓冲区同步文件策略，由参数<strong>appendfsync</strong>控制 </p><ul><li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用 来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依 赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之 前，如果此时系统故障宕机，缓冲区内数据将丢失。 </li><li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道 写入硬盘完成后返回，保证了数据持久化。 </li></ul><h4 id="4、RDB-VS-AOF"><a href="#4、RDB-VS-AOF" class="headerlink" title="4、RDB VS AOF"></a>4、RDB VS AOF</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142837.png" srcset="/img/loading.gif" alt=""></p><h5 id="RDB与AOF的选择之惑"><a href="#RDB与AOF的选择之惑" class="headerlink" title="RDB与AOF的选择之惑"></a>RDB与AOF的选择之惑</h5><ul><li>对数据非常<strong>敏感</strong>，建议使用默认的<strong>AOF</strong>持久化方案  <ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。 </li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong> </li></ul></li><li>数据呈现<strong>阶段有效性</strong>，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案 </li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对 <ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 </li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong> </li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong> </li><li><strong>灾难恢复选用RDB</strong> </li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li></ul></li></ul><h2 id="五、Redis事务"><a href="#五、Redis事务" class="headerlink" title="五、Redis事务"></a>五、Redis事务</h2><h3 id="1、Redis事务的定义"><a href="#1、Redis事务的定义" class="headerlink" title="1、Redis事务的定义"></a>1、Redis事务的定义</h3><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p><h3 id="2、事务的基本操作"><a href="#2、事务的基本操作" class="headerlink" title="2、事务的基本操作"></a>2、事务的基本操作</h3><ul><li><p>开启事务</p><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span></code></pre><ul><li>作用<ul><li>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中 </li></ul></li></ul></li><li><p>取消事务</p><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span></code></pre><ul><li>作用<ul><li>终止当前事务的定义，发生在multi之后，exec之前 </li></ul></li></ul></li><li><p>执行事务</p><pre><code class="hljs bash"><span class="hljs-built_in">exec</span></code></pre><ul><li>作用<ul><li>设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用 </li></ul></li></ul></li></ul><h3 id="3、事务操作的基本流程"><a href="#3、事务操作的基本流程" class="headerlink" title="3、事务操作的基本流程"></a>3、事务操作的基本流程</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142857.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、事务操作的注意事项"><a href="#4、事务操作的注意事项" class="headerlink" title="4、事务操作的注意事项"></a>4、事务操作的注意事项</h3><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p><ul><li>语法错误 <ul><li>指命令书写格式有误  例如执行了一条不存在的指令</li></ul></li><li>处理结果 <ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li></ul><p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong> </p><ul><li>运行错误 <ul><li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作 </li></ul></li><li>处理结果 <ul><li>能够正确运行的命令会执行，运行错误的命令不会被执行 </li></ul></li></ul><p><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。 </p><h3 id="5、基于特定条件的事务执行"><a href="#5、基于特定条件的事务执行" class="headerlink" title="5、基于特定条件的事务执行"></a>5、基于特定条件的事务执行</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">watch</span></span> key1, key2....</code></pre></li><li><p>取消对<strong>所有</strong>key的监视</p><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span></code></pre></li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li><p>使用 setnx 设置一个公共锁 </p><pre><code class="hljs cs"><span class="hljs-comment">//上锁</span>setnx <span class="hljs-keyword">lock</span>-key <span class="hljs-keyword">value</span><span class="hljs-comment">//释放锁</span>del <span class="hljs-keyword">lock</span>-key</code></pre><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁 </li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性 </p><h4 id="分布式锁加强"><a href="#分布式锁加强" class="headerlink" title="分布式锁加强"></a>分布式锁加强</h4><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁 </p><pre><code class="hljs sql">expire <span class="hljs-keyword">lock</span>-<span class="hljs-keyword">key</span> <span class="hljs-keyword">seconds</span>pexpire <span class="hljs-keyword">lock</span>-<span class="hljs-keyword">key</span> milliseconds</code></pre></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。 </p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 </li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 </li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110% </li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可 </li></ul></li></ul><h2 id="六、删除策略"><a href="#六、删除策略" class="headerlink" title="六、删除策略"></a>六、删除策略</h2><h3 id="1、数据删除策略"><a href="#1、数据删除策略" class="headerlink" title="1、数据删除策略"></a>1、数据删除策略</h3><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><ul><li>Redis中的数据，在expire中以哈希的方式保存在其中。其value是数据在内存中的地址，filed是对应的生命周期</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142921.png" srcset="/img/loading.gif" alt=""></p><h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 </p><h3 id="2、三种删除策略"><a href="#2、三种删除策略" class="headerlink" title="2、三种删除策略"></a>2、三种删除策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><ul><li><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</p></li><li><p>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用  </p></li><li><p>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </p></li><li><p>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</p></li></ul><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><ul><li>数据到达过期时间，不做处理。等下次访问该数据时 <ul><li>如果未过期，返回数据 </li><li>发现已过期，删除，返回不存在 </li></ul></li><li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除 </li><li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据 </li><li>总结：用存储空间换取处理器性能 （拿空间换时间） </li></ul><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142941.png" srcset="/img/loading.gif" alt=""></p><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度 </li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置 </li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查） </li></ul><h3 id="3、逐出算法"><a href="#3、逐出算法" class="headerlink" title="3、逐出算法"></a>3、逐出算法</h3><p>*<em>当新数据进入redis时，如果内存不足怎么办？ *</em></p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()</strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为<strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 </li></ul><h4 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><ul><li><p>最大可使用内存 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span></code></pre><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。 </p></li><li><p>每次选取待删除数据的个数 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span></code></pre><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 </p></li><li><p>删除策略</p><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span></code></pre><p>达到最大内存后的，对被挑选出来的数据进行删除的策略 </p></li></ul><h4 id="影响数据逐出的相关配置-1"><a href="#影响数据逐出的相关配置-1" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142953.png" srcset="/img/loading.gif" alt=""></p><p><strong>LRU</strong>：最长时间没被使用的数据</p><p><strong>LFU</strong>：一段时间内使用次数最少的数据</p><h4 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a><strong>数据逐出策略配置依据</strong></h4><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143004.png" srcset="/img/loading.gif" alt=""></p><h2 id="七、高级数据类型"><a href="#七、高级数据类型" class="headerlink" title="七、高级数据类型"></a>七、高级数据类型</h2><h3 id="1、Bitmaps"><a href="#1、Bitmaps" class="headerlink" title="1、Bitmaps"></a>1、Bitmaps</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p>获取指定key对应偏移量上的bit值 </p><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span></code></pre></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0 </p><pre><code class="hljs excel">setbit key <span class="hljs-built_in">offset</span> <span class="hljs-built_in">value</span></code></pre></li></ul><h4 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h4><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中 </p><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key1<span class="hljs-meta"> [key2...]</span></code></pre><ul><li>and：交 </li><li>or：并 </li><li>not：非 </li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量 </p><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]</code></pre></li></ul><h3 id="2、HyperLogLog"><a href="#2、HyperLogLog" class="headerlink" title="2、HyperLogLog"></a>2、HyperLogLog</h3><h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><ul><li>基数是数据集<strong>去重后元素个数</strong> </li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143020.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加数据</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfadd</span></span> key element1, element2...</code></pre></li><li><p>统计数据</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfcount</span></span> key1 key2....</code></pre></li><li><p>合并数据</p><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span></code></pre></li></ul><h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><ul><li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据 </li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong> </li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数 </li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong> </li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少 </li></ul><h3 id="3、GEO"><a href="#3、GEO" class="headerlink" title="3、GEO"></a>3、GEO</h3><h4 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加坐标点</p><pre><code class="hljs routeros">geoadd key longitude latitude member [longitude latitude member <span class="hljs-built_in">..</span>.] georadius key longitude latitude<span class="hljs-built_in"> radius </span>m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code></pre></li><li><p>获取坐标点</p><pre><code class="hljs routeros">geopos key member [member <span class="hljs-built_in">..</span>.] georadiusbymember key member<span class="hljs-built_in"> radius </span>m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code></pre></li><li><p>计算坐标点距离 </p><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]</code></pre></li></ul><h2 id="八、主从复制"><a href="#八、主从复制" class="headerlink" title="八、主从复制"></a>八、主从复制</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143033.png" srcset="/img/loading.gif" alt=""></p><ul><li>提供数据方：master <ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li>接收数据的方：slave<ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li>需要解决的问题<ul><li><strong>数据同步</strong></li></ul></li><li>核心工作<ul><li>master的数据<strong>复制</strong>到slave中 </li></ul></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中 </p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master </p><p>职责： </p><ul><li>master: <ul><li>写数据 </li><li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave </li><li>读数据（可忽略） </li></ul></li><li>slave: <ul><li>读数据 </li><li>写数据（<strong>禁止</strong>） </li></ul></li></ul><h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力 </li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 </li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 </li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 </li></ul><h3 id="3、工作流程"><a href="#3、工作流程" class="headerlink" title="3、工作流程"></a>3、工作流程</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a><strong>总述</strong></h4><ul><li>主从复制过程大体可以分为3个阶段 <ul><li>建立连接阶段（即准备阶段） </li><li>数据同步阶段 </li><li>命令传播阶段 </li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143046.png" srcset="/img/loading.gif" alt=""></p><h4 id="阶段一：建立连接"><a href="#阶段一：建立连接" class="headerlink" title="阶段一：建立连接"></a>阶段一：建立连接</h4><ul><li><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号  </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143102.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>*<em>主从连接（slave连接master） *</em></p><ul><li><p>方式一：客户端发送命令 </p><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></li><li><p>方式二：启动服务器参数</p><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></li><li><p>方式三：服务器配置 （常用）</p><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200821110845.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><strong>主从断开连接</strong></p><ul><li><p><strong>客户端</strong>发送命令  </p><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one</code></pre><ul><li>说明： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据 </li></ul></li></ul><p><strong>授权访问</strong></p><ul><li><p>master客户端发送命令设置密码 </p><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>master配置文件设置密码</p><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> requirepass &lt;password&gt; config <span class="hljs-builtin-name">get</span> requirepass</code></pre></li><li><p>slave客户端发送命令设置密码 </p><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>slave配置文件设置密码 </p><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>slave启动服务器设置密码 </p><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;</code></pre></li></ul><h4 id="阶段二：数据同步阶段"><a href="#阶段二：数据同步阶段" class="headerlink" title="阶段二：数据同步阶段"></a>阶段二：数据同步阶段</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143117.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>全量复制</strong><ul><li>将master执行bgsave之前，master中所有的数据同步到slave中</li></ul></li><li><strong>部分复制</strong>（增量复制）<ul><li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li></ul></li></ul><h5 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h5><ol><li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行 </li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。 </li></ol><pre><code class="hljs angelscript">repl-backlog-size <span class="hljs-number">1</span>mb</code></pre><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><h5 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h5><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务 </li></ol><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span></code></pre><ol start="2"><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰 </li><li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li></ol><h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong> </li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 </li></ul><ul><li>主从复制过程大体可以分为3个阶段 <ul><li>建立连接阶段（即准备阶段） </li><li>数据同步阶段 </li><li>命令传播阶段 </li></ul></li></ul><h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><ul><li>命令传播阶段出现了断网现象 <ul><li>网络闪断闪连 </li><li>短时间网络中断 </li><li>长时间网络中断 </li></ul></li></ul><ul><li><p>部分复制的<strong>三个核心要素</strong> </p><ul><li><p>服务器的运行 id（run id） </p></li><li><p>主服务器的复制积压缓冲区 </p></li><li><p>主从服务器的复制偏移量 </p></li></ul></li></ul><h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul><li><p>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id </p></li><li><p>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如- - </p><ul><li>fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce </li></ul></li><li><p>作用：运行id被用于在服务器间进行传输，识别身份 </p><ul><li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 </li></ul></li><li><p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid </p></li></ul><h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul><li><p>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 </p></li><li><p>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </p></li><li><p>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </p></li><li><p>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 </p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143134.png" srcset="/img/loading.gif" alt=""></p><h5 id="复制缓冲区内部工作原理"><a href="#复制缓冲区内部工作原理" class="headerlink" title="复制缓冲区内部工作原理"></a>复制缓冲区内部工作原理</h5><ul><li><p>组成 </p><ul><li>偏移量 </li><li>字节值 </li></ul></li><li><p>工作原理 </p><ul><li>通过offset区分不同的slave当前数据传播的差异 </li><li>master记录<strong>已发送</strong>的信息对应的offset </li><li>slave记录<strong>已接收</strong>的信息对应的offset </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143149.png" srcset="/img/loading.gif" alt=""></p></li></ul><h5 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h5><ul><li><p>概念：一个数字，描述复制缓冲区中的指令字节位置 </p></li><li><p>分类： </p><ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） </li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） </li></ul></li><li><p>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次 </p></li><li><p>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用 </p></li></ul><h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143228.png" srcset="/img/loading.gif" alt=""></p><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><ul><li><p>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 </p></li><li><p>master心跳： </p><ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒 </li><li>作用：判断slave是否在线 </li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 </li></ul></li><li><p>slave心跳任务 </p><ul><li>指令：REPLCONF ACK {offset} </li><li>周期：1秒 </li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 </li><li>作用2：判断master是否在线 </li></ul></li></ul><h5 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h5><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span></code></pre><ul><li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 </li></ul></li><li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认 </p></li><li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li></ul><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143241.png" srcset="/img/loading.gif" alt=""></p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143304.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143317.png" srcset="/img/loading.gif" alt=""></p><h4 id="频繁的网络中断"><a href="#频繁的网络中断" class="headerlink" title="频繁的网络中断"></a>频繁的网络中断</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143327.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200821110907.png" srcset="/img/loading.gif" alt=""></p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143352.png" srcset="/img/loading.gif" alt=""></p><h2 id="九、哨兵"><a href="#九、哨兵" class="headerlink" title="九、哨兵"></a>九、哨兵</h2><h3 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h3><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master。 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143401.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、作用-1"><a href="#2、作用-1" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>监控 <ul><li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测 </li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 </li></ul></li><li>自动故障转移 <ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址 </li></ul></li></ul><p><strong>注意：</strong><br>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong> </p><h3 id="3、配置哨兵"><a href="#3、配置哨兵" class="headerlink" title="3、配置哨兵"></a>3、配置哨兵</h3><ul><li><p>配置一拖二的主从结构  </p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><ul><li>参看sentinel.conf</li></ul></li><li><p>启动哨兵 </p><pre><code class="hljs css"><span class="hljs-selector-tag">redis-sentinel</span> <span class="hljs-selector-tag">sentinel</span>端口号 <span class="hljs-selector-class">.conf</span></code></pre></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143413.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、工作原理"><a href="#4、工作原理" class="headerlink" title="4、工作原理"></a>4、工作原理</h3><h4 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h4><ul><li>用于同步各个节点的状态信息 <ul><li>获取各个sentinel的状态（是否在线） </li></ul></li><li>获取master的状态 <ul><li>master属性 <ul><li>runid </li><li>role：master </li><li>各个slave的详细信息 </li></ul></li></ul></li><li>获取所有slave的状态（根据master中的slave信息） <ul><li>slave属性 <ul><li>runid </li><li>role：slave </li><li>master_host、master_port </li><li>offset</li><li>…</li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143539.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143602.png" srcset="/img/loading.gif" alt=""></p><h4 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h4><ul><li>各个哨兵将得到的信息相互同步（信息对称）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143614.png" srcset="/img/loading.gif" alt=""></p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h5 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h5><ul><li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li><li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143633.png" srcset="/img/loading.gif" alt=""></p><h5 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h5><ul><li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li><li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143649.png" srcset="/img/loading.gif" alt=""></p><h5 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h5><ul><li>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：<ul><li>服务器列表中挑选备选master </li><li>在线的 </li><li>响应慢的 </li><li>与原master断开时间久的 </li><li>优先原则 <ul><li>优先级 </li><li>offset </li><li>runid </li></ul></li><li>发送指令（ sentinel ） <ul><li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li><li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li></ul></li></ul></li></ul><h2 id="十、集群"><a href="#十、集群" class="headerlink" title="十、集群"></a>十、集群</h2><h3 id="1、简介-3"><a href="#1、简介-3" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><ul><li>集群就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果 </li></ul><h4 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h4><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong> </li><li>分散单台服务器的存储压力，实现<strong>可扩展性</strong> </li><li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong> </li></ul><h3 id="2、Redis集群结构设计"><a href="#2、Redis集群结构设计" class="headerlink" title="2、Redis集群结构设计"></a>2、Redis集群结构设计</h3><h4 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h4><ul><li>通过算法设计，计算出key应该保存的位置 </li><li>将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143701.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143712.png" srcset="/img/loading.gif" alt=""></p><ul><li>增强可扩展性 ——槽</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143720.png" srcset="/img/loading.gif" alt=""></p><h4 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h4><ul><li>各个数据库互相连通，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143733.png" srcset="/img/loading.gif" alt=""></p><h2 id="十一、企业级解决方案"><a href="#十一、企业级解决方案" class="headerlink" title="十一、企业级解决方案"></a>十一、企业级解决方案</h2><h3 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h3><h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><ul><li>请求数量较高 </li><li>主从之间数据吞吐量较大，数据同步操作频度较高 </li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>前置准备工作： <ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据 </li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合 </li></ul></li><li>准备工作： <ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据 </li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程 </li><li>热点数据主从同时预热 </li></ul></li><li>实施： <ul><li>使用脚本程序固定触发数据预热过程 </li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好 </li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ </p><h3 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol><li>系统平稳运行过程中，忽然数据库连接量激增 </li><li>应用服务器无法及时处理请求 </li><li>大量408，500错误页面出现 </li><li>客户反复刷新页面获取数据 </li><li>数据库崩溃 </li><li>应用服务器崩溃 </li><li>重启应用服务器无效 </li><li>Redis服务器崩溃  </li><li>Redis集群崩溃 </li><li>重启数据库后再次被瞬间流量放倒 </li></ol><h4 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 </li><li>数据库同时接收到大量的请求无法及时处理 </li><li>Redis大量请求被积压，开始出现超时现象 </li><li>数据库流量激增，数据库崩溃 </li><li>重启后仍然面对缓存中无数据可用 </li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解 </li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想 </li></ol><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>短时间范围内</li><li>大量key集中过期 </li></ul><h4 id="解决方案（道）"><a href="#解决方案（道）" class="headerlink" title="解决方案（道）"></a>解决方案（道）</h4><ol><li>更多的页面静态化处理 </li><li>构建<strong>多级缓存架构</strong> Nginx缓存+redis缓存+ehcache缓存 </li><li>检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等 </li><li>灾难预警机制 监控redis服务器性能指标 <ul><li>CPU占用、CPU使用率 </li><li>内存容量</li><li>查询平均响应时间 </li><li>线程数 </li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 </li></ol><p>解决方案（术） </p><ol><li>LRU与LFU切换 </li><li>数据有效期策略调整 <ul><li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟 </li><li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量 </li></ul></li><li><strong>超热</strong>数据使用永久key</li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 </li><li>加锁  <strong>慎用！</strong> </li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143749.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol><li>系统平稳运行过程中 </li><li>数据库连接量<strong>瞬间激增</strong> </li><li>Redis服务器无大量key过期 </li><li>Redis内存平稳，无波动 </li><li>Redis服务器CPU正常</li><li><strong>数据库崩溃</strong> </li></ol><h4 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>Redis中<strong>某个key过期，该key访问量巨大</strong> </li><li>多个数据请求从服务器直接压到Redis后，均未命中 </li><li>Redis在短时间内发起了大量对数据库中同一数据的访问 </li></ol><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>单个key高热数据</li><li>key过期 </li></ul><h4 id="解决方案（术）"><a href="#解决方案（术）" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h4><ol><li><p>预先设定 </p><p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong> </p><p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整 </p><ul><li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key </li></ul></li><li><p>后台刷新数据 </p><ul><li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 </li></ul></li><li><p>二级缓存 </p><ul><li>设置不同的失效时间，保障不会被同时淘汰就行 </li></ul></li><li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong> </p></li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可 </p><h3 id="4、缓存穿透"><a href="#4、缓存穿透" class="headerlink" title="4、缓存穿透"></a>4、缓存穿透</h3><h4 id="恶意请求"><a href="#恶意请求" class="headerlink" title="恶意请求"></a>恶意请求</h4><p>我们的数据库中的主键都是从0开始的，即使我们将数据库中的所有数据都放到了缓存中。当有人用id=-1来发生<strong>恶意请求</strong>时，<strong>因为redis中没有这个数据，就会直接访问数据库，这就称谓缓存穿透</strong></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>在程序中进行数据的合法性检验，如果不合法直接返回</li><li>使用<a href="https://www.bilibili.com/video/BV19i4y1u7rV?from=search&seid=8200619784088161214" target="_blank" rel="noopener"><strong>布隆过滤器</strong></a></li></ul><h4 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h4><p>想要尽量避免缓存穿透，一个办法就是对数据进行<strong>预校验</strong>，在对Redis和数据库进行操作前，<strong>先检查数据是否存在，如果不存在就直接返回。</strong>如果我们想要查询一个元素是否存在，要保证查询效率，可以选择HashSet，但是如果有10亿个数据，都用HashSet进行存储，<strong>内存肯定是无法容纳的</strong>。这时就需要布隆过滤器了</p><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（bit数组）和一系列随机映射函数（hash）。布隆过滤器可以用于检索一个元素是否在一个集合中</p><p>因为是基于<strong>位数组和hash函数</strong>的，所以它的<strong>优点</strong>是<strong>空间效率和查询</strong>时间都远远超过一般的算法。但<strong>缺点</strong>也很明显，那就是有一定的误识别率和删除困难。但是可以通过增加位数组的大小和增加hash函数个数来<strong>降低</strong>误识别率（<strong>只能降低，没法避免</strong>）</p><p><strong>放入过程</strong></p><p>布隆过滤器初始化后，位数组中的值都为0。当一个变量将要放入布隆过滤器时，会通过多个hash函数映射到位数组的各个位上，然后<strong>将对应位置为1</strong></p><p><strong>查询过程</strong></p><p>查询依然是通过多个hash函数映射到位数组的各个位上，如果各个位都为1，说明该元素<strong>可能存在，注意是可能存在！！</strong>。但是如果通过映射后，位数组对应位上<strong>不为1，那么该元素肯定不存在</strong></p><p><strong>放入过程图解</strong></p><p>比如我们的布隆过滤器位一个<strong>8位的位数组</strong>，并且有<strong>3个hash函数</strong>对元素进行计算，映射到数组中的各个位上</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191457.png" srcset="/img/loading.gif" alt=""></p><p>我们将字符串”Nyima”放入布隆过滤器中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191637.png" srcset="/img/loading.gif" alt=""></p><p>接下来将字符串”Cpower”放入布隆过滤器中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191725.png" srcset="/img/loading.gif" alt=""></p><p><strong>查询过程图解</strong></p><p>比如我们要查询字符串”Cpower”是否存在，通过3个hash函数映射到了位数组的三个位置上， 三个位置都为1，那么该<strong>字符串可能存在</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191725.png" srcset="/img/loading.gif" alt=""></p><p>比如我们要查询字符串”SWPU”是否存在，通过3个hash函数映射到了位数组的三个位置，发现有一个位置不为1，那么该<strong>字符串肯定不存在</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204192628.png" srcset="/img/loading.gif" alt=""></p><p>比如我们要查询字符串”Hulu”是否存在，通过3个hash函数映射到了位数组的三个位置，发现所有位置都为1，但是我们前面并没有将字符串”Hulu”放入布隆过滤器中，所以这里<strong>发生了误判</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204192741.png" srcset="/img/loading.gif" alt=""></p><p><strong>增加位数组的大小和hash函数个数可以降低误判率，但是无法避免误判</strong></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
